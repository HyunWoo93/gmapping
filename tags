!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A simple gradient descent scan matcher	openslam_gmapping/docs/scanmatcher.tex	/^\\newpage$/;"	s
ABSTRACT_ENCODING_PREFIXES	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string ABSTRACT_ENCODING_PREFIXES[] = {$/;"	m	namespace:sensor_msgs::image_encodings
ACCESSTATE_H	openslam_gmapping/include/gmapping/grid/accessstate.h	2;"	d
APPS	openslam_gmapping/gfs-carmen/Makefile	/^APPS= gfs-carmen$/;"	m
APPS	openslam_gmapping/gfs-carmen/Makefile	/^APPS=$/;"	m
APPS	openslam_gmapping/grid/Makefile	/^APPS= map_test$/;"	m
APPS	openslam_gmapping/log/Makefile	/^APPS= log_test log_plot scanstudio2carmen rdk2carmen$/;"	m
ARRAY2D_H	openslam_gmapping/include/gmapping/grid/array2d.h	2;"	d
ATTRIBUTE_ALIGNED128	geometry/tf/include/tf/LinearMath/Scalar.h	109;"	d
ATTRIBUTE_ALIGNED128	geometry/tf/include/tf/LinearMath/Scalar.h	137;"	d
ATTRIBUTE_ALIGNED128	geometry/tf/include/tf/LinearMath/Scalar.h	44;"	d
ATTRIBUTE_ALIGNED128	geometry/tf/include/tf/LinearMath/Scalar.h	55;"	d
ATTRIBUTE_ALIGNED128	geometry/tf/include/tf/LinearMath/Scalar.h	87;"	d
ATTRIBUTE_ALIGNED16	geometry/tf/include/tf/LinearMath/Scalar.h	107;"	d
ATTRIBUTE_ALIGNED16	geometry/tf/include/tf/LinearMath/Scalar.h	135;"	d
ATTRIBUTE_ALIGNED16	geometry/tf/include/tf/LinearMath/Scalar.h	42;"	d
ATTRIBUTE_ALIGNED16	geometry/tf/include/tf/LinearMath/Scalar.h	53;"	d
ATTRIBUTE_ALIGNED16	geometry/tf/include/tf/LinearMath/Scalar.h	85;"	d
ATTRIBUTE_ALIGNED64	geometry/tf/include/tf/LinearMath/Scalar.h	108;"	d
ATTRIBUTE_ALIGNED64	geometry/tf/include/tf/LinearMath/Scalar.h	136;"	d
ATTRIBUTE_ALIGNED64	geometry/tf/include/tf/LinearMath/Scalar.h	43;"	d
ATTRIBUTE_ALIGNED64	geometry/tf/include/tf/LinearMath/Scalar.h	54;"	d
ATTRIBUTE_ALIGNED64	geometry/tf/include/tf/LinearMath/Scalar.h	86;"	d
AUTOGEN	common_msgs/actionlib_msgs/scripts/genaction.py	/^AUTOGEN="# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\\n"$/;"	v
AUTOPTR_H	openslam_gmapping/include/gmapping/utils/autoptr.h	2;"	d
AccessibilityState	openslam_gmapping/include/gmapping/grid/accessstate.h	/^enum AccessibilityState{Outside=0x0, Inside=0x1, Allocated=0x2};$/;"	g	namespace:GMapping
ActionSpecException	common_msgs/actionlib_msgs/scripts/genaction.py	/^class ActionSpecException(Exception): pass$/;"	c
Allocated	openslam_gmapping/include/gmapping/grid/accessstate.h	/^enum AccessibilityState{Outside=0x0, Inside=0x1, Allocated=0x2};$/;"	e	enum:GMapping::AccessibilityState
AngularVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^  AngularVelocitySquareTest() {$/;"	f	class:AngularVelocitySquareTest
AngularVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^class AngularVelocitySquareTest : public ::testing::Test {$/;"	c	file:
Arcball	geometry/tf/src/tf/transformations.py	/^class Arcball(object):$/;"	c
Array2D	openslam_gmapping/include/gmapping/grid/array2d.h	/^Array2D<Cell,debug>::Array2D(const Array2D<Cell,debug> & g){$/;"	f	class:GMapping::Array2D
Array2D	openslam_gmapping/include/gmapping/grid/array2d.h	/^Array2D<Cell,debug>::Array2D(int xsize, int ysize){$/;"	f	class:GMapping::Array2D
Array2D	openslam_gmapping/include/gmapping/grid/array2d.h	/^template<class Cell, const bool debug=false> class Array2D{$/;"	c	namespace:GMapping
BAYER_BGGR16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_BGGR16="bayer_bggr16";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_BGGR8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_BGGR8="bayer_bggr8";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_GBRG16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_GBRG16="bayer_gbrg16";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_GBRG8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_GBRG8="bayer_gbrg8";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_GRBG16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_GRBG16="bayer_grbg16";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_GRBG8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_GRBG8="bayer_grbg8";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_RGGB16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_RGGB16="bayer_rggb16";$/;"	m	namespace:sensor_msgs::image_encodings
BAYER_RGGB8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BAYER_RGGB8="bayer_rggb8";$/;"	m	namespace:sensor_msgs::image_encodings
BGR16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BGR16 = "bgr16";$/;"	m	namespace:sensor_msgs::image_encodings
BGR8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BGR8 = "bgr8";$/;"	m	namespace:sensor_msgs::image_encodings
BGRA16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BGRA16 = "bgra16";$/;"	m	namespace:sensor_msgs::image_encodings
BGRA8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string BGRA8 = "bgra8";$/;"	m	namespace:sensor_msgs::image_encodings
Backward	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
Beam	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		struct Beam{$/;"	s	class:GMapping::RangeSensor
CARMENCONFIGURATION_H	openslam_gmapping/log/carmenconfiguration.h	2;"	d
CARMENWRAPPER_H	openslam_gmapping/carmenwrapper/carmenwrapper.h	25;"	d
CGrid	openslam_gmapping/grid/map_test.cpp	/^typedef Map< SimpleCell, HierarchicalArray2D<SimpleCell> > CGrid;$/;"	t	file:
CHECK_QUATERNION_NEAR	geometry/tf/test/tf_unittest.cpp	270;"	d	file:
CHECK_TRANSFORMS_NEAR	geometry/tf/test/tf_unittest.cpp	274;"	d	file:
CMD_PARSE_BEGIN	openslam_gmapping/include/gmapping/utils/commandline.h	60;"	d
CMD_PARSE_BEGIN_SILENT	openslam_gmapping/include/gmapping/utils/commandline.h	73;"	d
CMD_PARSE_END	openslam_gmapping/include/gmapping/utils/commandline.h	66;"	d
CMD_PARSE_END_SILENT	openslam_gmapping/include/gmapping/utils/commandline.h	79;"	d
COMMANDLINE_H	openslam_gmapping/include/gmapping/utils/commandline.h	25;"	d
CONFIGURATION_H	openslam_gmapping/include/gmapping/log/configuration.h	2;"	d
CONNECTIVITY_ERROR	geometry/tf/include/tf/tf.h	/^enum ErrorValues { NO_ERROR = 0, LOOKUP_ERROR, CONNECTIVITY_ERROR, EXTRAPOLATION_ERROR};$/;"	e	enum:tf::ErrorValues
CONVERSIONS_KDL_MSG_H	geometry/kdl_conversions/include/kdl_conversions/kdl_msg.h	33;"	d
CONVERSIONS_TF_EIGEN_H	geometry/tf_conversions/include/tf_conversions/tf_eigen.h	33;"	d
CONVERSIONS_TF_KDL_H	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	31;"	d
CanTransformAccum	geometry/tf/src/tf.cpp	/^struct CanTransformAccum$/;"	s	file:
CarmenConfiguration	openslam_gmapping/log/carmenconfiguration.h	/^class CarmenConfiguration: public Configuration, public std::map<std::string, std::vector<std::string> >{$/;"	c	namespace:GMapping
CarmenWrapper	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^class CarmenWrapper {$/;"	c	namespace:GMapping
CommentRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct CommentRecord: public Record{$/;"	s	file:
CommentRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct CommentRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
CompactFrameID	geometry/tf/include/tf/time_cache.h	/^typedef uint32_t CompactFrameID;$/;"	t	namespace:tf
Configuration	openslam_gmapping/include/gmapping/log/configuration.h	/^class Configuration{$/;"	c	namespace:GMapping
ConnectivityException	geometry/tf/include/tf/exceptions.h	/^typedef tf2::ConnectivityException ConnectivityException;$/;"	t	namespace:tf
Covariance3	openslam_gmapping/grid/graphmap.cpp	/^struct Covariance3{$/;"	s	namespace:GMapping	file:
Covariance3	openslam_gmapping/include/gmapping/utils/stat.h	/^struct Covariance3{$/;"	s	namespace:GMapping
CovarianceMatrix	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		typedef Covariance3 CovarianceMatrix;$/;"	t	class:GMapping::ScanMatcher
DATASMOOTHER_H	openslam_gmapping/utils/datasmoother.h	2;"	d
DEBUG	openslam_gmapping/gfs-carmen/gfs-carmen.cpp	30;"	d	file:
DEBUG	openslam_gmapping/gui/gsp_thread.cpp	33;"	d	file:
DEBUG	openslam_gmapping/scanmatcher/scanmatch_test.cpp	14;"	d	file:
DEBUG_STREAM	openslam_gmapping/include/gmapping/utils/point.h	8;"	d
DEFAULT_CACHE_TIME	geometry/tf/include/tf/tf.h	/^  static const double DEFAULT_CACHE_TIME;  \/\/!< 10.0 is the default amount of time to cache data in seconds, set in cpp file. $/;"	m	class:tf::Transformer
DEFAULT_CACHE_TIME	geometry/tf/src/tf.cpp	/^const double tf::Transformer::DEFAULT_CACHE_TIME = 10.0;$/;"	m	class:tf::Transformer	file:
DEFAULT_MAX_EXTRAPOLATION_DISTANCE	geometry/tf/include/tf/tf.h	/^  static const int64_t DEFAULT_MAX_EXTRAPOLATION_DISTANCE = 0ULL; \/\/!< The default amount of time to extrapolate \/\/deprecated since integration with tf2$/;"	m	class:tf::Transformer
DEFAULT_MAX_STORAGE_TIME	geometry/tf/include/tf/time_cache.h	/^  static const int64_t DEFAULT_MAX_STORAGE_TIME = 1ULL * 1000000000LL; \/\/!< default value of 10 seconds storage$/;"	m	class:tf::TimeCache
DIncompatibleMatrixException	openslam_gmapping/utils/dmatrix.h	/^class DIncompatibleMatrixException: public std::exception {};$/;"	c	namespace:GMapping
DMATRIX_HXX	openslam_gmapping/utils/dmatrix.h	2;"	d
DMatrix	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X>::DMatrix(const DMatrix& m) {$/;"	f	class:GMapping::DMatrix
DMatrix	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X>::DMatrix(int n,int m) {$/;"	f	class:GMapping::DMatrix
DMatrix	openslam_gmapping/utils/dmatrix.h	/^template <class X> class DMatrix {$/;"	c	namespace:GMapping
DNotInvertibleMatrixException	openslam_gmapping/utils/dmatrix.h	/^class DNotInvertibleMatrixException: public std::exception {};$/;"	c	namespace:GMapping
DNotSquareMatrixException	openslam_gmapping/utils/dmatrix.h	/^class DNotSquareMatrixException: public std::exception {};$/;"	c	namespace:GMapping
Data	openslam_gmapping/utils/datasmoother.h	/^  typedef std::vector<DataPoint> Data;$/;"	t	class:GMapping::DataSmoother
DataPoint	openslam_gmapping/utils/datasmoother.h	/^    DataPoint(double _x=0.0, double _y=0.0) { x=_x;y=_y;}$/;"	f	struct:GMapping::DataSmoother::DataPoint
DataPoint	openslam_gmapping/utils/datasmoother.h	/^  struct DataPoint {$/;"	s	class:GMapping::DataSmoother
DataSmoother	openslam_gmapping/utils/datasmoother.h	/^  DataSmoother(double parzenWindow) {$/;"	f	class:GMapping::DataSmoother
DataSmoother	openslam_gmapping/utils/datasmoother.h	/^class DataSmoother {$/;"	c	namespace:GMapping
DoneEvent	openslam_gmapping/gui/gsp_thread.h	/^		struct DoneEvent: public Event{$/;"	s	struct:GridSlamProcessorThread
DoubleArray2D	openslam_gmapping/include/gmapping/grid/map.h	/^typedef Array2D<double> DoubleArray2D;$/;"	t	namespace:GMapping
DoubleAutoPtr	openslam_gmapping/utils/autoptr_test.cpp	/^typedef autoptr<double> DoubleAutoPtr;$/;"	t	file:
DoubleDeque	openslam_gmapping/gui/qgraphpainter.h	/^typedef std::deque<double> DoubleDeque;$/;"	t
DoubleMap	openslam_gmapping/include/gmapping/grid/map.h	/^typedef Map<double, DoubleArray2D, false> DoubleMap;$/;"	t	namespace:GMapping
EIGEN_KDL_CONVERSIONS_H	geometry/eigen_conversions/include/eigen_conversions/eigen_kdl.h	35;"	d
EIGEN_MSG_CONVERSIONS_H	geometry/eigen_conversions/include/eigen_conversions/eigen_msg.h	35;"	d
EXTRAPOLATE_BACK	geometry/tf/include/tf/time_cache.h	/^enum ExtrapolationMode {  ONE_VALUE, INTERPOLATE, EXTRAPOLATE_BACK, EXTRAPOLATE_FORWARD };$/;"	e	enum:tf::ExtrapolationMode
EXTRAPOLATE_FORWARD	geometry/tf/include/tf/time_cache.h	/^enum ExtrapolationMode {  ONE_VALUE, INTERPOLATE, EXTRAPOLATE_BACK, EXTRAPOLATE_FORWARD };$/;"	e	enum:tf::ExtrapolationMode
EXTRAPOLATION_ERROR	geometry/tf/include/tf/tf.h	/^enum ErrorValues { NO_ERROR = 0, LOOKUP_ERROR, CONNECTIVITY_ERROR, EXTRAPOLATION_ERROR};$/;"	e	enum:tf::ErrorValues
EigenCovariance3	openslam_gmapping/include/gmapping/utils/stat.h	/^struct EigenCovariance3{$/;"	s	namespace:GMapping
EmptyFrameID	geometry/tf/include/tf/message_filter.h	/^  EmptyFrameID,$/;"	e	enum:tf::filter_failure_reasons::FilterFailureReason
EntropyRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct EntropyRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
ErrorValues	geometry/tf/include/tf/tf.h	/^enum ErrorValues { NO_ERROR = 0, LOOKUP_ERROR, CONNECTIVITY_ERROR, EXTRAPOLATION_ERROR};$/;"	g	namespace:tf
Event	openslam_gmapping/gui/gsp_thread.h	/^		struct Event{$/;"	s	struct:GridSlamProcessorThread
EventDeque	openslam_gmapping/gui/gsp_thread.h	/^		typedef deque<Event*> EventDeque;$/;"	t	struct:GridSlamProcessorThread
EvolutionModel	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^struct EvolutionModel{$/;"	s	file:
EvolutionModel	openslam_gmapping/particlefilter/range_bearing.cpp	/^struct EvolutionModel{$/;"	s	file:
ExtrapolationException	geometry/tf/include/tf/exceptions.h	/^typedef tf2::ExtrapolationException ExtrapolationException;$/;"	t	namespace:tf
ExtrapolationMode	geometry/tf/include/tf/time_cache.h	/^enum ExtrapolationMode {  ONE_VALUE, INTERPOLATE, EXTRAPOLATE_BACK, EXTRAPOLATE_FORWARD };$/;"	g	namespace:tf
FILLIMAGE_HH	common_msgs/sensor_msgs/include/sensor_msgs/fill_image.h	36;"	d
FSRMOVEMENT_H	openslam_gmapping/utils/movement.h	2;"	d
FSRMovement	openslam_gmapping/utils/movement.cpp	/^FSRMovement::FSRMovement(const FSRMovement& move1, const FSRMovement& move2) {$/;"	f	class:GMapping::FSRMovement
FSRMovement	openslam_gmapping/utils/movement.cpp	/^FSRMovement::FSRMovement(const FSRMovement& src) {$/;"	f	class:GMapping::FSRMovement
FSRMovement	openslam_gmapping/utils/movement.cpp	/^FSRMovement::FSRMovement(const OrientedPoint& pt1, const OrientedPoint& pt2) {$/;"	f	class:GMapping::FSRMovement
FSRMovement	openslam_gmapping/utils/movement.cpp	/^FSRMovement::FSRMovement(double f, double s, double r) {$/;"	f	class:GMapping::FSRMovement
FSRMovement	openslam_gmapping/utils/movement.h	/^class FSRMovement  {$/;"	c	namespace:GMapping
FailureCallback	geometry/tf/include/tf/message_filter.h	/^  typedef boost::function<void(const MConstPtr&, FilterFailureReason)> FailureCallback;$/;"	t	class:tf::MessageFilter
FailureSignal	geometry/tf/include/tf/message_filter.h	/^  typedef boost::signals2::signal<void(const MConstPtr&, FilterFailureReason)> FailureSignal;$/;"	t	class:tf::MessageFilter
FilterFailureReason	geometry/tf/include/tf/message_filter.h	/^enum FilterFailureReason$/;"	g	namespace:tf::filter_failure_reasons
FilterFailureReason	geometry/tf/include/tf/message_filter.h	/^typedef filter_failure_reasons::FilterFailureReason FilterFailureReason;$/;"	t	namespace:tf
FloatPoint	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	typedef point<float> FloatPoint;$/;"	t	struct:GMapping::PointAccumulator
Forward	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
FramePair	geometry/tf/src/change_notifier.cpp	/^  FramePair(const std::string& source_frame, const std::string& target_frame, double translational_update_distance, double angular_update_distance) : $/;"	f	class:FramePair
FramePair	geometry/tf/src/change_notifier.cpp	/^class FramePair$/;"	c	file:
Frequancy Based Occupancy grids	openslam_gmapping/docs/scanmatcher.tex	/^In the following we present two simple approaches for performing these two steps.$/;"	s
FullPath	geometry/tf/src/tf.cpp	/^  FullPath,$/;"	e	enum:WalkEnding	file:
GFSMainWindow	openslam_gmapping/gui/gfs_simplegui.cpp	/^  GFSMainWindow(GridSlamProcessorThread* t){$/;"	f	class:GFSMainWindow
GFSMainWindow	openslam_gmapping/gui/gfs_simplegui.cpp	/^class GFSMainWindow: public QMainWindow{$/;"	c	file:
GFSREADER_H	openslam_gmapping/gridfastslam/gfsreader.h	2;"	d
GFSReader	openslam_gmapping/gridfastslam/gfsreader.cpp	/^namespace GFSReader{$/;"	n	namespace:GMapping	file:
GFSReader	openslam_gmapping/gridfastslam/gfsreader.h	/^namespace GFSReader{$/;"	n	namespace:GMapping
GMapping	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/grid/graphmap.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/gridfastslam/gfsreader.cpp	/^namespace  GMapping { $/;"	n	file:
GMapping	openslam_gmapping/gridfastslam/gfsreader.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/gridfastslam/motionmodel.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/gui/qparticleviewer.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/grid/accessstate.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/grid/array2d.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/grid/harray2d.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/grid/map.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^namespace  GMapping { $/;"	n
GMapping	openslam_gmapping/include/gmapping/log/configuration.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/log/sensorlog.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/scanmatcher/icp.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometrysensor.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/utils/autoptr.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/include/gmapping/utils/point.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/include/gmapping/utils/stat.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/log/carmenconfiguration.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/log/carmenconfiguration.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/log/configuration.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/log/sensorlog.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/log/sensorstream.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/log/sensorstream.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/scanmatcher/lumiles.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/scanmatcher/smmap.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_base/sensor.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/sensor/sensor_base/sensorreading.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_odometry/odometryreading.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_odometry/odometrysensor.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/sensor/sensor_range/rangesensor.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/utils/datasmoother.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/utils/dmatrix.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/utils/movement.cpp	/^namespace GMapping {$/;"	n	file:
GMapping	openslam_gmapping/utils/movement.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/utils/optimizer.h	/^namespace GMapping {$/;"	n
GMapping	openslam_gmapping/utils/orientedboundingbox.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/utils/printmemusage.cpp	/^namespace GMapping{$/;"	n	file:
GMapping	openslam_gmapping/utils/printmemusage.h	/^namespace GMapping{$/;"	n
GMapping	openslam_gmapping/utils/stat.cpp	/^namespace GMapping {$/;"	n	file:
GRAPHMAP_H	openslam_gmapping/grid/graphmap.cpp	2;"	d	file:
GRIDLINETRAVERSAL_H	openslam_gmapping/scanmatcher/gridlinetraversal.h	2;"	d
GRIDSLAMPROCESSOR_H	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	2;"	d
GSP_THREAD_H	openslam_gmapping/gui/gsp_thread.h	25;"	d
Gaussian3	openslam_gmapping/include/gmapping/utils/stat.h	/^struct Gaussian3{$/;"	s	namespace:GMapping
GraphMapEdge	openslam_gmapping/grid/graphmap.cpp	/^struct GraphMapEdge{$/;"	s	namespace:GMapping	file:
GraphMapPatch	openslam_gmapping/grid/graphmap.cpp	/^struct GraphMapPatch{$/;"	s	namespace:GMapping	file:
GraphPatchDirectoryCell	openslam_gmapping/grid/graphmap.cpp	/^struct GraphPatchDirectoryCell: public std::set<GraphMapPatch::Vertex*> {$/;"	s	namespace:GMapping	file:
GraphPatchGraph	openslam_gmapping/grid/graphmap.cpp	/^struct GraphPatchGraph: public Graph<GraphMapPatch, Covariance3>{$/;"	s	namespace:GMapping	file:
GridLineTraversal	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^struct GridLineTraversal {$/;"	s	namespace:GMapping
GridLineTraversalLine	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^} GridLineTraversalLine;$/;"	t	namespace:GMapping	typeref:struct:GMapping::__anon6
GridSlamProcessor	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor::GridSlamProcessor(): m_infoStream(cout){$/;"	f	class:GMapping::GridSlamProcessor
GridSlamProcessor	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor::GridSlamProcessor(const GridSlamProcessor& gsp) $/;"	f	class:GMapping::GridSlamProcessor
GridSlamProcessor	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor::GridSlamProcessor(std::ostream& infoS): m_infoStream(infoS){$/;"	f	class:GMapping::GridSlamProcessor
GridSlamProcessor	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^  class GridSlamProcessor{$/;"	c	namespace:GMapping
GridSlamProcessorThread	openslam_gmapping/gui/gsp_thread.cpp	/^GridSlamProcessorThread::GridSlamProcessorThread(): GridSlamProcessor(cerr){$/;"	f	class:GridSlamProcessorThread
GridSlamProcessorThread	openslam_gmapping/gui/gsp_thread.h	/^struct GridSlamProcessorThread : public GridSlamProcessor {$/;"	s
HARRAY2D_H	openslam_gmapping/include/gmapping/grid/harray2d.h	2;"	d
HierarchicalArray2D	openslam_gmapping/include/gmapping/grid/harray2d.h	/^HierarchicalArray2D<Cell>::HierarchicalArray2D(const HierarchicalArray2D& hg)$/;"	f	class:GMapping::HierarchicalArray2D
HierarchicalArray2D	openslam_gmapping/include/gmapping/grid/harray2d.h	/^HierarchicalArray2D<Cell>::HierarchicalArray2D(int xsize, int ysize, int patchMagnitude) $/;"	f	class:GMapping::HierarchicalArray2D
HierarchicalArray2D	openslam_gmapping/include/gmapping/grid/harray2d.h	/^class HierarchicalArray2D: public Array2D<autoptr< Array2D<Cell> > >{$/;"	c	namespace:GMapping
I	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::I(int n) {$/;"	f	class:GMapping::DMatrix
INTERPOLATE	geometry/tf/include/tf/time_cache.h	/^enum ExtrapolationMode {  ONE_VALUE, INTERPOLATE, EXTRAPOLATE_BACK, EXTRAPOLATE_FORWARD };$/;"	e	enum:tf::ExtrapolationMode
IODELIM	common_msgs/actionlib_msgs/scripts/genaction.py	/^IODELIM   = '---'$/;"	v
Identity	geometry/tf/src/tf.cpp	/^  Identity,$/;"	e	enum:WalkEnding	file:
InputSensorStream	openslam_gmapping/log/sensorstream.cpp	/^InputSensorStream::InputSensorStream(const SensorMap& sensorMap, std::istream& is):$/;"	f	class:GMapping::InputSensorStream
InputSensorStream	openslam_gmapping/log/sensorstream.h	/^class InputSensorStream: public SensorStream{$/;"	c	namespace:GMapping
Inside	openslam_gmapping/include/gmapping/grid/accessstate.h	/^enum AccessibilityState{Outside=0x0, Inside=0x1, Allocated=0x2};$/;"	e	enum:GMapping::AccessibilityState
IntPoint	openslam_gmapping/include/gmapping/utils/point.h	/^typedef point<int> IntPoint;$/;"	t	namespace:GMapping
InvalidArgument	geometry/tf/include/tf/exceptions.h	/^typedef tf2::InvalidArgumentException InvalidArgument; $/;"	t	namespace:tf
LASER_MAXBEAMS	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	10;"	d
LINEBUFFER_SIZE	openslam_gmapping/log/carmenconfiguration.cpp	11;"	d	file:
LINEBUFFER_SIZE	openslam_gmapping/log/sensorlog.cpp	9;"	d	file:
LINEBUFFER_SIZE	openslam_gmapping/log/sensorstream.cpp	7;"	d	file:
LOOKUP_ERROR	geometry/tf/include/tf/tf.h	/^enum ErrorValues { NO_ERROR = 0, LOOKUP_ERROR, CONNECTIVITY_ERROR, EXTRAPOLATION_ERROR};$/;"	e	enum:tf::ErrorValues
LUMILESPROCESSOR	openslam_gmapping/scanmatcher/lumiles.h	2;"	d
L_Event	geometry/tf/include/tf/message_filter.h	/^  typedef std::list<MEvent> L_Event;$/;"	t	class:tf::MessageFilter
L_TransformStorage	geometry/tf/include/tf/time_cache.h	/^  typedef std::set<TransformStorage> L_TransformStorage;$/;"	t	class:tf::TimeCache
LaserRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct LaserRecord: public Record{$/;"	s	file:
LaserRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct LaserRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
Left	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
LikelyhoodModel	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^struct LikelyhoodModel{$/;"	s	file:
LikelyhoodModel	openslam_gmapping/particlefilter/range_bearing.cpp	/^struct LikelyhoodModel{$/;"	s	file:
LinearVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^  LinearVelocitySquareTest() {$/;"	f	class:LinearVelocitySquareTest
LinearVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^class LinearVelocitySquareTest : public ::testing::Test {$/;"	c	file:
LogSensorStream	openslam_gmapping/log/sensorstream.cpp	/^LogSensorStream::LogSensorStream(const SensorMap& sensorMap, const SensorLog* log):$/;"	f	class:GMapping::LogSensorStream
LogSensorStream	openslam_gmapping/log/sensorstream.h	/^class LogSensorStream: public SensorStream{$/;"	c	namespace:GMapping
LookupException	geometry/tf/include/tf/exceptions.h	/^typedef tf2::LookupException LookupException;$/;"	t	namespace:tf
LuMilesProcessor	openslam_gmapping/scanmatcher/lumiles.h	/^class LuMilesProcessor{$/;"	c	namespace:GMapping
MACRO_PARAMS_H	openslam_gmapping/include/gmapping/utils/macro_params.h	2;"	d
MAP_H	openslam_gmapping/include/gmapping/grid/map.h	2;"	d
MAP_IDX	slam_gmapping/gmapping/src/slam_gmapping.cpp	127;"	d	file:
MAX	openslam_gmapping/scanmatcher/eig3.cpp	8;"	d	file:
MAXDOUBLE	openslam_gmapping/include/gmapping/utils/gvalues.h	4;"	d
MAXLINELENGHT	openslam_gmapping/log/scanstudio2carmen.cpp	8;"	d	file:
MAXREADINGS	openslam_gmapping/log/scanstudio2carmen.cpp	9;"	d	file:
MAX_FILENAME	openslam_gmapping/gui/gfs2img.cpp	12;"	d	file:
MAX_GRAPH_DEPTH	geometry/tf/include/tf/tf.h	/^  static const unsigned int MAX_GRAPH_DEPTH = 100UL;   \/\/!< The maximum number of time to recurse before assuming the tree has a loop.$/;"	m	class:tf::Transformer
MAX_LASER_BEAMS	openslam_gmapping/gui/gfs2img.cpp	11;"	d	file:
MAX_LENGTH_LINKED_LIST	geometry/tf/include/tf/time_cache.h	/^  static const unsigned int MAX_LENGTH_LINKED_LIST = 1000000; \/\/!< Maximum length of linked list, to make sure not to be able to use unlimited memory.$/;"	m	class:tf::TimeCache
MAX_LINE_LENGHT	openslam_gmapping/gridfastslam/gfs2log.cpp	10;"	d	file:
MAX_LINE_LENGHT	openslam_gmapping/gridfastslam/gfs2rec.cpp	9;"	d	file:
MAX_LINE_LENGHT	openslam_gmapping/gridfastslam/gfs2stream.cpp	9;"	d	file:
MAX_LINE_LENGHT	openslam_gmapping/gridfastslam/gfsreader.h	11;"	d
MAX_STRING_LENGTH	openslam_gmapping/gui/gsp_thread.h	40;"	d
MAX_STRING_LENGTH	openslam_gmapping/scanmatcher/scanmatch_test.cpp	15;"	d	file:
MConstPtr	geometry/tf/include/tf/message_filter.h	/^  typedef boost::shared_ptr<M const> MConstPtr;$/;"	t	class:tf::MessageFilter
MEMBER_PARAM_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	24;"	d
MEMBER_PARAM_SET	openslam_gmapping/include/gmapping/utils/macro_params.h	21;"	d
MEMBER_PARAM_SET_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	17;"	d
MEvent	geometry/tf/include/tf/message_filter.h	/^  typedef ros::MessageEvent<M const> MEvent;$/;"	t	class:tf::MessageFilter
MIN_INTERPOLATION_DISTANCE	geometry/tf/include/tf/time_cache.h	/^  static const int MIN_INTERPOLATION_DISTANCE = 5; \/\/!< Number of nano-seconds to not interpolate below.$/;"	m	class:tf::TimeCache
MONO16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string MONO16="mono16";$/;"	m	namespace:sensor_msgs::image_encodings
MONO8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string MONO8="mono8";$/;"	m	namespace:sensor_msgs::image_encodings
MOTIONMODEL_H	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	2;"	d
M_PI	openslam_gmapping/include/gmapping/utils/gvalues.h	20;"	d
Map	openslam_gmapping/grid/graphmap.cpp	/^typedef Map<GraphPatchDirectoryCell>, Array2D::set<GraphPatchDirectoryCell> >$/;"	t	namespace:GMapping	file:
Map	openslam_gmapping/include/gmapping/grid/map.h	/^Map<Cell,Storage,isClass>::Map(const Point& center, double worldSizeX, double worldSizeY, double delta):$/;"	f	class:GMapping::Map
Map	openslam_gmapping/include/gmapping/grid/map.h	/^Map<Cell,Storage,isClass>::Map(const Point& center, double xmin, double ymin, double xmax, double ymax, double delta):$/;"	f	class:GMapping::Map
Map	openslam_gmapping/include/gmapping/grid/map.h	/^Map<Cell,Storage,isClass>::Map(int mapSizeX, int mapSizeY, double delta):$/;"	f	class:GMapping::Map
Map	openslam_gmapping/include/gmapping/grid/map.h	/^class Map{$/;"	c	namespace:GMapping
MapClientTest	slam_gmapping/gmapping/test/rtest.cpp	/^    MapClientTest()$/;"	f	class:MapClientTest
MapClientTest	slam_gmapping/gmapping/test/rtest.cpp	/^class MapClientTest : public testing::Test$/;"	c	file:
MapEvent	openslam_gmapping/gui/gsp_thread.h	/^		struct MapEvent: public Event{$/;"	s	struct:GridSlamProcessorThread
MatchingParameters	openslam_gmapping/gui/qparticleviewer.h	/^		struct MatchingParameters{$/;"	s	class:GMapping::QParticleViewer
Matrix3x3	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Matrix3x3 () {}$/;"	f	class:tf::Matrix3x3
Matrix3x3	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Matrix3x3(const tfScalar& xx, const tfScalar& xy, const tfScalar& xz,$/;"	f	class:tf::Matrix3x3
Matrix3x3	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE Matrix3x3 (const Matrix3x3& other)$/;"	f	class:tf::Matrix3x3
Matrix3x3	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	explicit Matrix3x3(const Quaternion& q) { setRotation(q); }$/;"	f	class:tf::Matrix3x3
Matrix3x3	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^class Matrix3x3 {$/;"	c	namespace:tf
Matrix3x3Data	geometry/tf/include/tf/LinearMath/Matrix3x3.h	26;"	d
Matrix3x3DoubleData	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^struct	Matrix3x3DoubleData$/;"	s	namespace:tf
Matrix3x3FloatData	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^struct	Matrix3x3FloatData$/;"	s	namespace:tf
MessageFilter	geometry/tf/include/tf/message_filter.h	/^  MessageFilter(F& f, Transformer& tf, const std::string& target_frame, uint32_t queue_size, ros::NodeHandle nh = ros::NodeHandle(), ros::Duration max_rate = ros::Duration(0.01))$/;"	f	class:tf::MessageFilter
MessageFilter	geometry/tf/include/tf/message_filter.h	/^  MessageFilter(Transformer& tf, const std::string& target_frame, uint32_t queue_size, ros::NodeHandle nh = ros::NodeHandle(), ros::Duration max_rate = ros::Duration(0.01))$/;"	f	class:tf::MessageFilter
MessageFilter	geometry/tf/include/tf/message_filter.h	/^class MessageFilter : public MessageFilterBase, public message_filters::SimpleFilter<M>$/;"	c	namespace:tf
MessageFilterBase	geometry/tf/include/tf/message_filter.h	/^class MessageFilterBase$/;"	c	namespace:tf
Mock	geometry/tf/test/testPython.py	/^class Mock:$/;"	c
MotionModel	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^struct MotionModel{$/;"	s	namespace:GMapping
MotionModelConditioningAngularCovariance	openslam_gmapping/gridfastslam/motionmodel.cpp	6;"	d	file:
MotionModelConditioningLinearCovariance	openslam_gmapping/gridfastslam/motionmodel.cpp	5;"	d	file:
Move	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	g	struct:GMapping::Optimizer
NO_ERROR	geometry/tf/include/tf/tf.h	/^enum ErrorValues { NO_ERROR = 0, LOOKUP_ERROR, CONNECTIVITY_ERROR, EXTRAPOLATION_ERROR};$/;"	e	enum:tf::ErrorValues
NeffRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct NeffRecord: public Record{$/;"	s	file:
NeffRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct NeffRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
Notation	openslam_gmapping/docs/scanmatcher.tex	/^We first introduce the notation, then we describe how to compute an occupancy grid map, given a known set od poses. Subsequantly we present a simple gradient based scan matchgin algorithm.$/;"	s
Notification	geometry/tf/test/test_message_filter.cpp	/^	Notification(int expected_count)$/;"	f	class:Notification
Notification	geometry/tf/test/test_message_filter.cpp	/^class Notification$/;"	c	file:
OBJS	openslam_gmapping/gfs-carmen/Makefile	/^OBJS= $/;"	m
OBJS	openslam_gmapping/grid/Makefile	/^OBJS= $/;"	m
OBJS	openslam_gmapping/log/Makefile	/^OBJS= configuration.o carmenconfiguration.o sensorlog.o sensorstream.o$/;"	m
ODOMETRYREADING_H	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	2;"	d
ODOMETRYSENSOR_H	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometrysensor.h	2;"	d
ONE_VALUE	geometry/tf/include/tf/time_cache.h	/^enum ExtrapolationMode {  ONE_VALUE, INTERPOLATE, EXTRAPOLATE_BACK, EXTRAPOLATE_FORWARD };$/;"	e	enum:tf::ExtrapolationMode
ORIENTENDBOUNDINGBOX_H	openslam_gmapping/utils/orientedboundingbox.h	2;"	d
OdometryReading	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^class OdometryReading: public SensorReading{$/;"	c	namespace:GMapping
OdometryReading	openslam_gmapping/sensor/sensor_odometry/odometryreading.cpp	/^OdometryReading::OdometryReading(const OdometrySensor* odo, double time):$/;"	f	class:GMapping::OdometryReading
OdometryRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct OdometryRecord: public Record{$/;"	s	file:
OdometryRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct OdometryRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
OdometrySensor	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometrysensor.h	/^class OdometrySensor: public Sensor{$/;"	c	namespace:GMapping
OdometrySensor	openslam_gmapping/sensor/sensor_odometry/odometrysensor.cpp	/^OdometrySensor::OdometrySensor(const std::string& name, bool ideal): Sensor(name){ m_ideal=ideal;}$/;"	f	class:GMapping::OdometrySensor
Optimizer	openslam_gmapping/utils/optimizer.h	/^Optimizer<Likelihood, Map>::Optimizer(const OptimizerParams& p):$/;"	f	class:GMapping::Optimizer
Optimizer	openslam_gmapping/utils/optimizer.h	/^struct Optimizer {$/;"	s	namespace:GMapping
OptimizerParams	openslam_gmapping/utils/optimizer.h	/^struct OptimizerParams{$/;"	s	namespace:GMapping
OrientedBoundingBox	openslam_gmapping/utils/orientedboundingbox.h	/^class OrientedBoundingBox {$/;"	c	namespace:GMapping
OrientedBoundingBox	openslam_gmapping/utils/orientedboundingbox.hxx	/^OrientedBoundingBox<NUMERIC>::OrientedBoundingBox(std::vector< point<NUMERIC> > p) {$/;"	f	class:OrientedBoundingBox
OrientedPoint	openslam_gmapping/include/gmapping/utils/point.h	/^typedef orientedpoint<double, double> OrientedPoint;$/;"	t	namespace:GMapping
OrientedPointVector	openslam_gmapping/gui/qparticleviewer.h	/^		typedef std::vector<OrientedPoint> OrientedPointVector;$/;"	t	class:GMapping::QParticleViewer
OutTheBack	geometry/tf/include/tf/message_filter.h	/^  OutTheBack,$/;"	e	enum:tf::filter_failure_reasons::FilterFailureReason
Outside	openslam_gmapping/include/gmapping/grid/accessstate.h	/^enum AccessibilityState{Outside=0x0, Inside=0x1, Allocated=0x2};$/;"	e	enum:GMapping::AccessibilityState
PARAM_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	13;"	d
PARAM_SET	openslam_gmapping/include/gmapping/utils/macro_params.h	9;"	d
PARAM_SET_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	4;"	d
PARTICLEFILTER_H	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	2;"	d
PARTICLEFILTER_H	openslam_gmapping/particlefilter/pf.h	2;"	d
PLUMB_BOB	common_msgs/sensor_msgs/include/sensor_msgs/distortion_models.h	/^    const std::string PLUMB_BOB = "plumb_bob";$/;"	m	namespace:sensor_msgs::distortion_models
PRINTMEMUSAGE_H	openslam_gmapping/utils/printmemusage.h	2;"	d
P_TimeAndFrameID	geometry/tf/include/tf/time_cache.h	/^typedef std::pair<ros::Time, CompactFrameID> P_TimeAndFrameID;$/;"	t	namespace:tf
Particle	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor::Particle::Particle(const ScanMatcherMap& m):$/;"	f	class:GMapping::GridSlamProcessor::Particle
Particle	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    struct Particle{$/;"	s	class:GMapping::GridSlamProcessor
Particle	openslam_gmapping/particlefilter/particlefilter.cpp	/^	typedef particle<State, Numeric> Particle;$/;"	t	struct:auxiliaryEvolver	file:
Particle	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^struct Particle{$/;"	s	file:
Particle	openslam_gmapping/particlefilter/range_bearing.cpp	/^	Particle(): p(0,0), w(0){}$/;"	f	struct:Particle
Particle	openslam_gmapping/particlefilter/range_bearing.cpp	/^struct Particle{$/;"	s	file:
ParticleMoveEvent	openslam_gmapping/gui/gsp_thread.h	/^		struct ParticleMoveEvent: public Event{$/;"	s	struct:GridSlamProcessorThread
ParticleVector	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    typedef std::vector<Particle> ParticleVector;$/;"	t	class:GMapping::GridSlamProcessor
Point	geometry/tf/include/tf/transform_datatypes.h	/^typedef tf::Vector3 Point;$/;"	t	namespace:tf
Point	openslam_gmapping/include/gmapping/utils/point.h	/^typedef point<double> Point;$/;"	t	namespace:GMapping
PointAccumulator	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	PointAccumulator(): acc(0,0), n(0), visits(0){}$/;"	f	struct:GMapping::PointAccumulator
PointAccumulator	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	PointAccumulator(int i): acc(0,0), n(0), visits(0){assert(i==-1);}$/;"	f	struct:GMapping::PointAccumulator
PointAccumulator	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^struct PointAccumulator{$/;"	s	namespace:GMapping
PointCloud2ConstIterator	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  PointCloud2ConstIterator(const sensor_msgs::PointCloud2 &cloud_msg, const std::string &field_name) :$/;"	f	class:sensor_msgs::PointCloud2ConstIterator
PointCloud2ConstIterator	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^class PointCloud2ConstIterator : public impl::PointCloud2IteratorBase<T, const T, const unsigned char, const sensor_msgs::PointCloud2, PointCloud2ConstIterator>$/;"	c	namespace:sensor_msgs
PointCloud2Iterator	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  PointCloud2Iterator(sensor_msgs::PointCloud2 &cloud_msg, const std::string &field_name) :$/;"	f	class:sensor_msgs::PointCloud2Iterator
PointCloud2Iterator	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^class PointCloud2Iterator : public impl::PointCloud2IteratorBase<T, T, unsigned char, sensor_msgs::PointCloud2, PointCloud2Iterator>$/;"	c	namespace:sensor_msgs
PointCloud2IteratorBase	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^PointCloud2IteratorBase<T, TT, U, C, V>::PointCloud2IteratorBase() : data_char_(0), data_(0), data_end_(0)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
PointCloud2IteratorBase	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^PointCloud2IteratorBase<T, TT, U, C, V>::PointCloud2IteratorBase(C &cloud_msg, const std::string &field_name)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
PointCloud2IteratorBase	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^class PointCloud2IteratorBase$/;"	c	namespace:sensor_msgs::impl
PointCloud2Modifier	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline PointCloud2Modifier::PointCloud2Modifier(PointCloud2& cloud_msg) : cloud_msg_(cloud_msg)$/;"	f	class:sensor_msgs::PointCloud2Modifier
PointCloud2Modifier	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^class PointCloud2Modifier$/;"	c	namespace:sensor_msgs
PointList	openslam_gmapping/grid/graphmap.cpp	/^	typedef typename std::list<IntPoint> PointList; $/;"	t	struct:GMapping::GraphMapPatch	file:
PointPair	openslam_gmapping/include/gmapping/scanmatcher/icp.h	/^typedef std::pair<Point,Point> PointPair;$/;"	t	namespace:GMapping
PointPairList	openslam_gmapping/scanmatcher/icptest.cpp	/^typedef std::list<PointPair> PointPairList;$/;"	t	file:
PointSet	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		typedef std::set< point<int>, pointcomparator<int> > PointSet;$/;"	t	class:GMapping::HierarchicalArray2D
PointVector	openslam_gmapping/scanmatcher/lumiles.h	/^	typedef std:vector<Point> PointVector;$/;"	m	class:GMapping::LuMilesProcessor
Pose	geometry/tf/include/tf/transform_datatypes.h	/^typedef tf::Transform Pose;$/;"	t	namespace:tf
PoseConversions	geometry/tf/test/test_datatype_conversion.py	/^class PoseConversions(unittest.TestCase):$/;"	c
PoseKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^void PoseKDLToMsg(const KDL::Frame &k, geometry_msgs::Pose &m) { poseKDLToMsg(k, m);}$/;"	f	namespace:tf
PoseKDLToTF	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline PoseKDLToTF(const KDL::Frame &k, tf::Pose &t) {poseKDLToTF(k, t);};$/;"	f	namespace:tf
PoseMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^void PoseMsgToKDL(const geometry_msgs::Pose &m, KDL::Frame &k) { poseMsgToKDL(m, k);}$/;"	f	namespace:tf
PoseRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	PoseRecord(bool ideal=false){$/;"	f	struct:PoseRecord
PoseRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct PoseRecord: public Record{$/;"	s	file:
PoseRecord	openslam_gmapping/gridfastslam/gfsreader.cpp	/^PoseRecord::PoseRecord(bool ideal){$/;"	f	class:GMapping::GFSReader::PoseRecord
PoseRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct PoseRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
PoseTFToKDL	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline PoseTFToKDL(const tf::Pose &t, KDL::Frame &k) {poseTFToKDL(t, k);};$/;"	f	namespace:tf
QGRAPHPAINTER_H	openslam_gmapping/gui/qgraphpainter.h	25;"	d
QGraphPainter	openslam_gmapping/gui/qgraphpainter.cpp	/^QGraphPainter::QGraphPainter( QWidget * parent, const char * name, WFlags f):$/;"	f	class:QGraphPainter
QGraphPainter	openslam_gmapping/gui/qgraphpainter.h	/^class QGraphPainter :  public QWidget{$/;"	c
QMAPPAINTER_H	openslam_gmapping/gui/qmappainter.h	2;"	d
QMapPainter	openslam_gmapping/gui/qmappainter.cpp	/^QMapPainter::QMapPainter( QWidget * parent, const char * name, WFlags f):$/;"	f	class:QMapPainter
QMapPainter	openslam_gmapping/gui/qmappainter.h	/^class QMapPainter :  public QWidget{$/;"	c
QNavigatorWidget	openslam_gmapping/gui/qnavigatorwidget.cpp	/^QNavigatorWidget::QNavigatorWidget( QWidget * parent, const char * name, WFlags f)$/;"	f	class:QNavigatorWidget
QNavigatorWidget	openslam_gmapping/gui/qnavigatorwidget.h	/^class QNavigatorWidget :  public QMapPainter{$/;"	c
QPARTICLEVIEWER_H	openslam_gmapping/gui/qparticleviewer.h	25;"	d
QParticleViewer	openslam_gmapping/gui/qparticleviewer.cpp	/^QParticleViewer::QParticleViewer( QWidget * parent, const char * name , WFlags f, GridSlamProcessorThread* thread): QWidget(parent, name, f|WRepaintNoErase|WResizeNoErase){$/;"	f	class:QParticleViewer
QParticleViewer	openslam_gmapping/gui/qparticleviewer.h	/^class QParticleViewer :  public QWidget{$/;"	c	namespace:GMapping
QPixmapDumper	openslam_gmapping/gui/qpixmapdumper.cpp	/^QPixmapDumper::QPixmapDumper(std::string p, int c){$/;"	f	class:QPixmapDumper
QPixmapDumper	openslam_gmapping/gui/qpixmapdumper.h	/^struct QPixmapDumper{$/;"	s
QSLAMandNavWidget	openslam_gmapping/gui/qslamandnavwidget.cpp	/^QSLAMandNavWidget::QSLAMandNavWidget( QWidget * parent, const char * name, WFlags f)$/;"	f	class:QSLAMandNavWidget
QSLAMandNavWidget	openslam_gmapping/gui/qslamandnavwidget.h	/^class QSLAMandNavWidget :  public QMapPainter{$/;"	c
QUATERNION_TOLERANCE	geometry/tf/include/tf/transform_datatypes.h	/^static const double QUATERNION_TOLERANCE = 0.1f;$/;"	m	namespace:tf
QualificationModel	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^struct QualificationModel{$/;"	s	file:
Quaternion	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion() {}$/;"	f	class:tf::Quaternion
Quaternion	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion(const Vector3& axis, const tfScalar& angle) $/;"	f	class:tf::Quaternion
Quaternion	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion(const tfScalar& x, const tfScalar& y, const tfScalar& z, const tfScalar& w) $/;"	f	class:tf::Quaternion
Quaternion	geometry/tf/include/tf/LinearMath/Quaternion.h	/^  Quaternion(const tfScalar& yaw, const tfScalar& pitch, const tfScalar& roll) __attribute__((deprecated))$/;"	f	class:tf::Quaternion
Quaternion	geometry/tf/include/tf/LinearMath/Quaternion.h	/^class Quaternion : public QuadWord {$/;"	c	namespace:tf
QuaternionKDLToTF	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline QuaternionKDLToTF(const KDL::Rotation &k, tf::Quaternion &t) {quaternionKDLToTF(k, t);};$/;"	f	namespace:tf
QuaternionTFToKDL	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline QuaternionTFToKDL(const tf::Quaternion &t, KDL::Rotation &k) {quaternionTFToKDL(t, k);};$/;"	f	namespace:tf
RANGEREADING_H	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	2;"	d
RANGESENSOR_H	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	2;"	d
RATIONAL_POLYNOMIAL	common_msgs/sensor_msgs/include/sensor_msgs/distortion_models.h	/^    const std::string RATIONAL_POLYNOMIAL = "rational_polynomial";$/;"	m	namespace:sensor_msgs::distortion_models
RGB16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string RGB16 = "rgb16";$/;"	m	namespace:sensor_msgs::image_encodings
RGB8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string RGB8 = "rgb8";$/;"	m	namespace:sensor_msgs::image_encodings
RGBA16	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string RGBA16 = "rgba16";$/;"	m	namespace:sensor_msgs::image_encodings
RGBA8	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string RGBA8 = "rgba8";$/;"	m	namespace:sensor_msgs::image_encodings
RangeReading	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	/^class RangeReading: public SensorReading, public std::vector<double>{$/;"	c	namespace:GMapping
RangeReading	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^RangeReading::RangeReading(const RangeSensor* rs, double time):$/;"	f	class:GMapping::RangeReading
RangeReading	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^RangeReading::RangeReading(unsigned int n_beams, const double* d, const RangeSensor* rs, double time):$/;"	f	class:GMapping::RangeReading
RangeSensor	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^class RangeSensor: public Sensor{$/;"	c	namespace:GMapping
RangeSensor	openslam_gmapping/sensor/sensor_range/rangesensor.cpp	/^RangeSensor::RangeSensor(std::string name): Sensor(name){}$/;"	f	class:GMapping::RangeSensor
RangeSensor	openslam_gmapping/sensor/sensor_range/rangesensor.cpp	/^RangeSensor::RangeSensor(std::string name, unsigned int beams_num, double res, const OrientedPoint& position, double span, double maxrange):Sensor(name),$/;"	f	class:GMapping::RangeSensor
RawOdometryRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct RawOdometryRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
Record	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct Record{$/;"	s	file:
Record	openslam_gmapping/gridfastslam/gfsreader.h	/^struct Record{$/;"	s	namespace:GMapping::GFSReader
RecordList	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct RecordList: public list<Record*>{$/;"	s	file:
RecordList	openslam_gmapping/gridfastslam/gfsreader.h	/^struct RecordList: public list<Record*>{$/;"	s	namespace:GMapping::GFSReader
ResampleEvent	openslam_gmapping/gui/gsp_thread.h	/^		struct ResampleEvent: public Event{$/;"	s	struct:GridSlamProcessorThread
ResampleRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct ResampleRecord: public Record{$/;"	s	file:
ResampleRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct ResampleRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
Right	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
SAMPLES_NUMBER	openslam_gmapping/utils/stat_test.cpp	13;"	d	file:
SCANMATCHERPROCESSOR_H	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	2;"	d
SCANMATCHER_H	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	2;"	d
SENSORLOG_H	openslam_gmapping/include/gmapping/log/sensorlog.h	2;"	d
SENSORREADING_H	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	2;"	d
SENSORREADING_H	openslam_gmapping/sensor/sensor_base/sensoreading.h	2;"	d
SENSORSTREAM_H	openslam_gmapping/log/sensorstream.h	2;"	d
SENSOR_H	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	2;"	d
SENSOR_MSGS_DISTORTION_MODELS_H	common_msgs/sensor_msgs/include/sensor_msgs/distortion_models.h	37;"	d
SENSOR_MSGS_IMAGE_ENCODINGS_H	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	37;"	d
SENSOR_MSGS_IMPL_POINT_CLOUD_ITERATOR_H	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	36;"	d
SENSOR_MSGS_POINT_CLOUD2_ITERATOR_H	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	36;"	d
SENSOR_MSGS_POINT_CLOUD_CONVERSION_H	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud_conversion.h	39;"	d
SENSOR_MSGS_POINT_FIELD_CONVERSION_H	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	47;"	d
SIGHT_INC	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	6;"	d
SMMAP_H	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	2;"	d
STAT_H	openslam_gmapping/include/gmapping/utils/stat.h	2;"	d
STRUCT_PARAM_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	34;"	d
STRUCT_PARAM_SET	openslam_gmapping/include/gmapping/utils/macro_params.h	31;"	d
STRUCT_PARAM_SET_GET	openslam_gmapping/include/gmapping/utils/macro_params.h	27;"	d
SUBDIRS	openslam_gmapping/sensor/Makefile	/^SUBDIRS=sensor_base sensor_odometry sensor_range$/;"	m
ScanMatchRecord	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^struct ScanMatchRecord: public Record{$/;"	s	file:
ScanMatchRecord	openslam_gmapping/gridfastslam/gfsreader.h	/^struct ScanMatchRecord: public Record{$/;"	s	namespace:GMapping::GFSReader
ScanMatcher	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^class ScanMatcher{$/;"	c	namespace:GMapping
ScanMatcher	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^ScanMatcher::ScanMatcher(): m_laserPose(0,0,0){$/;"	f	class:GMapping::ScanMatcher
ScanMatcher	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^ScanMatcher::ScanMatcher(): m_laserPose(0,0,0){$/;"	f	class:GMapping::ScanMatcher
ScanMatcherMap	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^typedef Map<PointAccumulator,HierarchicalArray2D<PointAccumulator> > ScanMatcherMap;$/;"	t	namespace:GMapping
ScanMatcherProcessor	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^ScanMatcherProcessor::ScanMatcherProcessor $/;"	f	class:GMapping::ScanMatcherProcessor
ScanMatcherProcessor	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^ScanMatcherProcessor::ScanMatcherProcessor(const ScanMatcherMap& m)$/;"	f	class:GMapping::ScanMatcherProcessor
ScanMatcherProcessor	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^class ScanMatcherProcessor{$/;"	c	namespace:GMapping
ScoredMove	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^struct ScoredMove{$/;"	s	namespace:GMapping	file:
ScoredMove	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^struct ScoredMove{$/;"	s	namespace:GMapping	file:
ScoredMoveList	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^typedef std::list<ScoredMove> ScoredMoveList;$/;"	t	namespace:GMapping	file:
ScoredMoveList	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^typedef std::list<ScoredMove> ScoredMoveList;$/;"	t	namespace:GMapping	file:
Sensor	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^class Sensor{$/;"	c	namespace:GMapping
Sensor	openslam_gmapping/sensor/sensor_base/sensor.cpp	/^Sensor::Sensor(const std::string& name){$/;"	f	class:GMapping::Sensor
SensorLog	openslam_gmapping/include/gmapping/log/sensorlog.h	/^class SensorLog : public std::list<SensorReading*>{$/;"	c	namespace:GMapping
SensorLog	openslam_gmapping/log/sensorlog.cpp	/^SensorLog::SensorLog(const SensorMap& sm): m_sensorMap(sm){$/;"	f	class:GMapping::SensorLog
SensorMap	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^typedef std::map<std::string, Sensor*> SensorMap;$/;"	t	namespace:GMapping
SensorReading	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^class SensorReading{$/;"	c	namespace:GMapping
SensorReading	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^class SensorReading{$/;"	c	namespace:GMapping
SensorReading	openslam_gmapping/sensor/sensor_base/sensorreading.cpp	/^SensorReading::SensorReading(const Sensor* s, double t){$/;"	f	class:GMapping::SensorReading
SensorStream	openslam_gmapping/log/sensorstream.cpp	/^SensorStream::SensorStream(const SensorMap& sensorMap) :m_sensorMap(sensorMap){}$/;"	f	class:GMapping::SensorStream
SensorStream	openslam_gmapping/log/sensorstream.h	/^class SensorStream{$/;"	c	namespace:GMapping
SetUp	geometry/tf/test/transform_twist_test.cpp	/^  virtual void SetUp() {$/;"	f	class:TransformTwistAngularTest
SetUp	geometry/tf/test/transform_twist_test.cpp	/^  virtual void SetUp() {$/;"	f	class:TransformTwistLinearTest
SetUp	geometry/tf/test/velocity_test.cpp	/^  virtual void SetUp() {$/;"	f	class:AngularVelocitySquareTest
SetUp	geometry/tf/test/velocity_test.cpp	/^  virtual void SetUp() {$/;"	f	class:LinearVelocitySquareTest
SimpleCell	openslam_gmapping/grid/map_test.cpp	/^	SimpleCell(int v=0){value=v;}$/;"	f	struct:SimpleCell
SimpleCell	openslam_gmapping/grid/map_test.cpp	/^struct SimpleCell{$/;"	s	file:
SlamGMapping	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::SlamGMapping():$/;"	f	class:SlamGMapping
SlamGMapping	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::SlamGMapping(long unsigned int seed, long unsigned int max_duration_buffer):$/;"	f	class:SlamGMapping
SlamGMapping	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::SlamGMapping(ros::NodeHandle& nh, ros::NodeHandle& pnh):$/;"	f	class:SlamGMapping
SlamGMapping	slam_gmapping/gmapping/src/slam_gmapping.h	/^class SlamGMapping$/;"	c
SlamGMappingNodelet	slam_gmapping/gmapping/src/nodelet.cpp	/^    SlamGMappingNodelet()  {}$/;"	f	class:SlamGMappingNodelet
SlamGMappingNodelet	slam_gmapping/gmapping/src/nodelet.cpp	/^class SlamGMappingNodelet : public nodelet::Nodelet$/;"	c	file:
SourceParentOfTarget	geometry/tf/src/tf.cpp	/^  SourceParentOfTarget,$/;"	e	enum:WalkEnding	file:
Stamped	geometry/tf/include/tf/transform_datatypes.h	/^  Stamped() :frame_id_ ("NO_ID_STAMPED_DEFAULT_CONSTRUCTION"){}; \/\/Default constructor used only for preallocation$/;"	f	class:tf::Stamped
Stamped	geometry/tf/include/tf/transform_datatypes.h	/^  Stamped(const T& input, const ros::Time& timestamp, const std::string & frame_id) :$/;"	f	class:tf::Stamped
Stamped	geometry/tf/include/tf/transform_datatypes.h	/^class Stamped : public T{$/;"	c	namespace:tf
StampedTransform	geometry/tf/include/tf/transform_datatypes.h	/^  StampedTransform() { };$/;"	f	class:tf::StampedTransform
StampedTransform	geometry/tf/include/tf/transform_datatypes.h	/^  StampedTransform(const tf::Transform& input, const ros::Time& timestamp, const std::string & frame_id, const std::string & child_frame_id):$/;"	f	class:tf::StampedTransform
StampedTransform	geometry/tf/include/tf/transform_datatypes.h	/^class StampedTransform : public tf::Transform$/;"	c	namespace:tf
StartParameters	openslam_gmapping/gui/qparticleviewer.h	/^		struct StartParameters{$/;"	s	class:GMapping::QParticleViewer
TEST	common_msgs/sensor_msgs/test/main.cpp	/^TEST(sensor_msgs, PointCloud2Iterator)$/;"	f
TEST	common_msgs/sensor_msgs/test/test_image_encodings.cpp	/^TEST(sensor_msgs, NumChannels)$/;"	f
TEST	common_msgs/sensor_msgs/test/test_image_encodings.cpp	/^TEST(sensor_msgs, bitDepth)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(Bullet, Slerp)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, AngularInterpolation)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, CartesianInterpolation)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, DuplicateEntries)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, Repeatability)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, RepeatabilityRandomInsertOrder)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, RepeatabilityReverseInsertOrder)$/;"	f
TEST	geometry/tf/test/cache_unittest.cpp	/^TEST(TimeCache, ZeroAtFront)$/;"	f
TEST	geometry/tf/test/quaternion.cpp	/^TEST(tf, Quaternion)$/;"	f
TEST	geometry/tf/test/testListener.cpp	/^TEST(TransformBroadcaster, multi_frame)$/;"	f
TEST	geometry/tf/test/testListener.cpp	/^TEST(TransformBroadcaster, single_frame)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, emptyFrameIDFailure)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, multipleTargetFrames)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, noTransforms)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, noTransformsSameFrame)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, outTheBackFailure)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, postTransforms)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, preexistingTransforms)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, queueSize)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, removeCallback)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, setTargetFrame)$/;"	f
TEST	geometry/tf/test/test_message_filter.cpp	/^TEST(MessageFilter, tolerance)$/;"	f
TEST	geometry/tf/test/test_transform_datatypes.cpp	/^TEST(tf, set)$/;"	f
TEST	geometry/tf/test/tf_benchmark.cpp	/^TEST(tf_benchmark, benchmarkExhaustiveSearch)$/;"	f
TEST	geometry/tf/test/tf_benchmark.cpp	/^TEST(tf_benchmark, canTransformCacheLength0)$/;"	f
TEST	geometry/tf/test/tf_benchmark.cpp	/^TEST(tf_benchmark, canTransformCacheLength10000)$/;"	f
TEST	geometry/tf/test/tf_benchmark.cpp	/^TEST(tf_benchmark, lookupTransformCacheLength10000)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, PoseStampedConversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, QuaternionConversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, QuaternionStampedConversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, StampedOperatorEqual)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, StampedOperatorEqualEqual)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, StampedTransformOperatorEqualEqual)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, TransformConversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, Vector3Conversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(data, Vector3StampedConversions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, Exceptions)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, ExtrapolationFromOneValue)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, ListOneForward)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, ListOneInverse)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, ListTwoForward)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, ListTwoInverse)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, NO_PARENT_SET)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, NoExtrapolationExceptionFromParent)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, RepeatedTimes)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformPointCartesian)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformQuaternionCartesian)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformThrougRoot)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformThroughNO_PARENT)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformTransformToOwnFrame)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformTransformsCartesian)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, TransformVectorCartesian)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, assertQuaternionMsgValid)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, assertQuaternionValid)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, canTransform)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, frameExists)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, getFrameStrings)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, getParent)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, lookupTransform)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, lookupTransform_compount)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, lookupTransform_helix_configuration)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, lookupTransform_ring45)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, setTransformNoInsertOnSelfTransform)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, setTransformNoInsertWithNan)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, setTransformNoInsertWithNoFrameID)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, setTransformNoInsertWithNoParentID)$/;"	f
TEST	geometry/tf/test/tf_unittest.cpp	/^TEST(tf, waitForTransform)$/;"	f
TEST	geometry/tf/test/tf_unittest_future.cpp	/^TEST(tf, SignFlipExtrapolate)$/;"	f
TEST	geometry/tf/test/transform_listener_unittest.cpp	/^TEST(transform_listener, resolve)$/;"	f
TEST	geometry/tf_conversions/test/test_eigen_tf.cpp	/^TEST(TFEigenConversions, eigen_tf_transform)$/;"	f
TEST	geometry/tf_conversions/test/test_eigen_tf.cpp	/^TEST(TFEigenConversions, tf_eigen_quaternion)$/;"	f
TEST	geometry/tf_conversions/test/test_eigen_tf.cpp	/^TEST(TFEigenConversions, tf_eigen_transform)$/;"	f
TEST	geometry/tf_conversions/test/test_eigen_tf.cpp	/^TEST(TFEigenConversions, tf_eigen_vector)$/;"	f
TEST	geometry/tf_conversions/test/test_kdl_tf.cpp	/^TEST(TFKDLConversions, msg_kdl_twist)$/;"	f
TEST	geometry/tf_conversions/test/test_kdl_tf.cpp	/^TEST(TFKDLConversions, tf_kdl_pose)$/;"	f
TEST	geometry/tf_conversions/test/test_kdl_tf.cpp	/^TEST(TFKDLConversions, tf_kdl_rotation)$/;"	f
TEST	geometry/tf_conversions/test/test_kdl_tf.cpp	/^TEST(TFKDLConversions, tf_kdl_transform)$/;"	f
TEST	geometry/tf_conversions/test/test_kdl_tf.cpp	/^TEST(TFKDLConversions, tf_kdl_vector)$/;"	f
TEST_F	geometry/tf/test/transform_twist_test.cpp	/^TEST_F(TransformTwistAngularTest, AngularVelocityAlone)$/;"	f
TEST_F	geometry/tf/test/transform_twist_test.cpp	/^TEST_F(TransformTwistLinearTest, LinearVelocityToThreeFrames)$/;"	f
TEST_F	geometry/tf/test/velocity_test.cpp	/^TEST_F(AngularVelocitySquareTest, AngularVelocityAlone)$/;"	f
TEST_F	geometry/tf/test/velocity_test.cpp	/^TEST_F(AngularVelocitySquareTest, AngularVelocityOffsetChildFrameInX)$/;"	f
TEST_F	geometry/tf/test/velocity_test.cpp	/^TEST_F(AngularVelocitySquareTest, AngularVelocityOffsetParentFrameInZ)$/;"	f
TEST_F	geometry/tf/test/velocity_test.cpp	/^TEST_F(LinearVelocitySquareTest, LinearVelocityToThreeFrames)$/;"	f
TEST_F	slam_gmapping/gmapping/test/rtest.cpp	/^TEST_F(MapClientTest, call_service)$/;"	f
TEST_F	slam_gmapping/gmapping/test/rtest.cpp	/^TEST_F(MapClientTest, subscribe_topic)$/;"	f
TEST_F	slam_gmapping/gmapping/test/rtest.cpp	/^TEST_F(MapClientTest, subscribe_topic_metadata)$/;"	f
TFMonitor	geometry/tf/src/tf_monitor.cpp	/^  TFMonitor(bool using_specific_chain, std::string framea  = "", std::string frameb = ""):$/;"	f	class:TFMonitor
TFMonitor	geometry/tf/src/tf_monitor.cpp	/^class TFMonitor$/;"	c	file:
TFSIMDSQRT12	geometry/tf/include/tf/LinearMath/Scalar.h	199;"	d
TFSIMD_2_PI	geometry/tf/include/tf/LinearMath/Scalar.h	194;"	d
TFSIMD_DEGS_PER_RAD	geometry/tf/include/tf/LinearMath/Scalar.h	198;"	d
TFSIMD_EPSILON	geometry/tf/include/tf/LinearMath/Scalar.h	204;"	d
TFSIMD_FORCE_INLINE	geometry/tf/include/tf/LinearMath/Scalar.h	106;"	d
TFSIMD_FORCE_INLINE	geometry/tf/include/tf/LinearMath/Scalar.h	130;"	d
TFSIMD_FORCE_INLINE	geometry/tf/include/tf/LinearMath/Scalar.h	41;"	d
TFSIMD_FORCE_INLINE	geometry/tf/include/tf/LinearMath/Scalar.h	52;"	d
TFSIMD_FORCE_INLINE	geometry/tf/include/tf/LinearMath/Scalar.h	84;"	d
TFSIMD_HALF_PI	geometry/tf/include/tf/LinearMath/Scalar.h	196;"	d
TFSIMD_INFINITY	geometry/tf/include/tf/LinearMath/Scalar.h	205;"	d
TFSIMD_PI	geometry/tf/include/tf/LinearMath/Scalar.h	195;"	d
TFSIMD_RADS_PER_DEG	geometry/tf/include/tf/LinearMath/Scalar.h	197;"	d
TF_DEBUG	geometry/tf/include/tf/LinearMath/Scalar.h	33;"	d
TF_DECLARE_ALIGNED_ALLOCATOR	geometry/tf/include/tf/LinearMath/Scalar.h	166;"	d
TF_DECLARE_HANDLE	geometry/tf/include/tf/LinearMath/Scalar.h	240;"	d
TF_EXCEPTIONS_H	geometry/tf/include/tf/exceptions.h	33;"	d
TF_HAVE_NATIVE_FSEL	geometry/tf/include/tf/LinearMath/Scalar.h	60;"	d
TF_LARGE_FLOAT	geometry/tf/include/tf/LinearMath/Scalar.h	162;"	d
TF_MATRIX3x3_H	geometry/tf/include/tf/LinearMath/Matrix3x3.h	17;"	d
TF_MESSAGEFILTER_DEBUG	geometry/tf/include/tf/message_filter.h	54;"	d
TF_MESSAGEFILTER_WARN	geometry/tf/include/tf/message_filter.h	57;"	d
TF_MESSAGE_FILTER_H	geometry/tf/include/tf/message_filter.h	33;"	d
TF_MINMAX_H	geometry/tf/include/tf/LinearMath/MinMax.h	18;"	d
TF_QUADWORD_H	geometry/tf/include/tf/LinearMath/QuadWord.h	17;"	d
TF_QUATERNION_H_	geometry/tf/include/tf/LinearMath/Quaternion.h	18;"	d
TF_SCALAR_H	geometry/tf/include/tf/LinearMath/Scalar.h	18;"	d
TF_TF_H	geometry/tf/include/tf/tf.h	33;"	d
TF_TIME_CACHE_H	geometry/tf/include/tf/time_cache.h	33;"	d
TF_TRANSFORMBROADCASTER_H	geometry/tf/include/tf/transform_broadcaster.h	34;"	d
TF_TRANSFORMLISTENER_H	geometry/tf/include/tf/transform_listener.h	33;"	d
TF_TRANSFORM_DATATYPES_H	geometry/tf/include/tf/transform_datatypes.h	33;"	d
TF_USE_VMX128	geometry/tf/include/tf/LinearMath/Scalar.h	57;"	d
TF_VECTOR3_H	geometry/tf/include/tf/LinearMath/Vector3.h	18;"	d
TNode	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^GridSlamProcessor::TNode::TNode(const OrientedPoint& p, double w, TNode* n, unsigned int c){$/;"	f	class:GMapping::GridSlamProcessor::TNode
TNode	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    struct TNode{$/;"	s	class:GMapping::GridSlamProcessor
TNodeDeque	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    typedef std::deque<GridSlamProcessor::TNode*> TNodeDeque;$/;"	t	class:GMapping::GridSlamProcessor
TNodeMultimap	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^typedef std::multimap<const GridSlamProcessor::TNode*, GridSlamProcessor::TNode*> TNodeMultimap;$/;"	t	namespace:GMapping
TNodeVector	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    typedef std::vector<GridSlamProcessor::TNode*> TNodeVector;$/;"	t	class:GMapping::GridSlamProcessor
TYPE_16SC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16SC1="16SC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16SC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16SC2="16SC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16SC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16SC3="16SC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16SC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16SC4="16SC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16UC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16UC1="16UC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16UC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16UC2="16UC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16UC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16UC3="16UC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_16UC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_16UC4="16UC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32FC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32FC1="32FC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32FC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32FC2="32FC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32FC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32FC3="32FC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32FC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32FC4="32FC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32SC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32SC1="32SC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32SC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32SC2="32SC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32SC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32SC3="32SC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_32SC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_32SC4="32SC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_64FC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_64FC1="64FC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_64FC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_64FC2="64FC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_64FC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_64FC3="64FC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_64FC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_64FC4="64FC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8SC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8SC1="8SC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8SC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8SC2="8SC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8SC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8SC3="8SC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8SC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8SC4="8SC4";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8UC1	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8UC1="8UC1";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8UC2	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8UC2="8UC2";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8UC3	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8UC3="8UC3";$/;"	m	namespace:sensor_msgs::image_encodings
TYPE_8UC4	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string TYPE_8UC4="8UC4";$/;"	m	namespace:sensor_msgs::image_encodings
TargetParentOfSource	geometry/tf/src/tf.cpp	/^  TargetParentOfSource,$/;"	e	enum:WalkEnding	file:
TearDown	geometry/tf/test/transform_twist_test.cpp	/^  virtual void TearDown() {$/;"	f	class:TransformTwistAngularTest
TearDown	geometry/tf/test/transform_twist_test.cpp	/^  virtual void TearDown() {$/;"	f	class:TransformTwistLinearTest
TearDown	geometry/tf/test/velocity_test.cpp	/^  virtual void TearDown() {$/;"	f	class:AngularVelocitySquareTest
TearDown	geometry/tf/test/velocity_test.cpp	/^  virtual void TearDown() {$/;"	f	class:LinearVelocitySquareTest
TestGmapping	slam_gmapping/gmapping/test/test_map.py	/^class TestGmapping(unittest.TestCase):$/;"	c
TestPoseMath	geometry/tf_conversions/test/posemath.py	/^class TestPoseMath(unittest.TestCase):$/;"	c
TestPython	geometry/tf/test/testPython.py	/^class TestPython(unittest.TestCase):$/;"	c
TfRemapper	geometry/tf/scripts/tf_remap	/^class TfRemapper:$/;"	c
The Scan Matching Problem	openslam_gmapping/docs/scanmatcher.tex	/^\\end{itemize}$/;"	s
TimeAndFrameIDFrameComparator	geometry/tf/src/tf.cpp	/^  TimeAndFrameIDFrameComparator(CompactFrameID id)$/;"	f	struct:TimeAndFrameIDFrameComparator
TimeAndFrameIDFrameComparator	geometry/tf/src/tf.cpp	/^struct TimeAndFrameIDFrameComparator$/;"	s	file:
TimeCache	geometry/tf/include/tf/time_cache.h	/^class TimeCache$/;"	c	namespace:tf
TimeCache	geometry/tf/src/cache.cpp	/^TimeCache::TimeCache(ros::Duration max_storage_time)$/;"	f	class:TimeCache
Timer	geometry/tf/scripts/python_benchmark.py	/^class Timer:$/;"	c
Transform	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Transform (const Transform& other)$/;"	f	class:tf::Transform
Transform	geometry/tf/include/tf/LinearMath/Transform.h	/^	Transform() {}$/;"	f	class:tf::Transform
Transform	geometry/tf/include/tf/LinearMath/Transform.h	/^	explicit TFSIMD_FORCE_INLINE Transform(const Matrix3x3& b, $/;"	f	class:tf::Transform
Transform	geometry/tf/include/tf/LinearMath/Transform.h	/^	explicit TFSIMD_FORCE_INLINE Transform(const Quaternion& q, $/;"	f	class:tf::Transform
Transform	geometry/tf/include/tf/LinearMath/Transform.h	/^class Transform {$/;"	c	namespace:tf
TransformAccum	geometry/tf/src/tf.cpp	/^  TransformAccum()$/;"	f	struct:TransformAccum
TransformAccum	geometry/tf/src/tf.cpp	/^struct TransformAccum$/;"	s	file:
TransformBroadcaster	geometry/tf/include/tf/transform_broadcaster.h	/^class TransformBroadcaster{$/;"	c	namespace:tf
TransformBroadcaster	geometry/tf/src/tf/broadcaster.py	/^class TransformBroadcaster:$/;"	c
TransformBroadcaster	geometry/tf/src/transform_broadcaster.cpp	/^TransformBroadcaster::TransformBroadcaster():$/;"	f	class:tf::TransformBroadcaster
TransformData	geometry/tf/include/tf/LinearMath/Transform.h	26;"	d
TransformDoubleData	geometry/tf/include/tf/LinearMath/Transform.h	/^struct	TransformDoubleData$/;"	s	namespace:tf
TransformException	geometry/tf/include/tf/exceptions.h	/^typedef tf2::TransformException TransformException;$/;"	t	namespace:tf
TransformFloatData	geometry/tf/include/tf/LinearMath/Transform.h	/^struct	TransformFloatData$/;"	s	namespace:tf
TransformKDLToTF	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline TransformKDLToTF(const KDL::Frame &k, tf::Transform &t)  {transformKDLToTF(k, t);};$/;"	f	namespace:tf
TransformListener	geometry/tf/include/tf/transform_listener.h	/^class TransformListener : public Transformer { \/\/subscribes to message and automatically stores incoming data$/;"	c	namespace:tf
TransformListener	geometry/tf/src/tf/listener.py	/^class TransformListener(TransformerROS):$/;"	c
TransformListener	geometry/tf/src/transform_listener.cpp	/^TransformListener::TransformListener(const ros::NodeHandle& nh, ros::Duration max_cache_time, bool spin_thread):$/;"	f	class:TransformListener
TransformListener	geometry/tf/src/transform_listener.cpp	/^TransformListener::TransformListener(ros::Duration max_cache_time, bool spin_thread):$/;"	f	class:TransformListener
TransformLists	geometry/tf/include/tf/tf.h	/^} TransformLists;$/;"	t	namespace:tf	typeref:struct:tf::__anon5
TransformSender	geometry/tf/src/static_transform_publisher.cpp	/^  TransformSender(double x, double y, double z, double qx, double qy, double qz, double qw, ros::Time time, const std::string& frame_id, const std::string& child_frame_id) :$/;"	f	class:TransformSender
TransformSender	geometry/tf/src/static_transform_publisher.cpp	/^  TransformSender(double x, double y, double z, double yaw, double pitch, double roll, ros::Time time, const std::string& frame_id, const std::string& child_frame_id)$/;"	f	class:TransformSender
TransformSender	geometry/tf/src/static_transform_publisher.cpp	/^class TransformSender$/;"	c	file:
TransformStorage	geometry/tf/include/tf/time_cache.h	/^  TransformStorage(const TransformStorage& rhs)$/;"	f	class:tf::TransformStorage
TransformStorage	geometry/tf/include/tf/time_cache.h	/^class TransformStorage$/;"	c	namespace:tf
TransformStorage	geometry/tf/src/cache.cpp	/^TransformStorage::TransformStorage()$/;"	f	class:TransformStorage
TransformStorage	geometry/tf/src/cache.cpp	/^TransformStorage::TransformStorage(const StampedTransform& data, CompactFrameID frame_id,$/;"	f	class:TransformStorage
TransformTFToKDL	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline TransformTFToKDL(const tf::Transform &t, KDL::Frame &k) {transformTFToKDL(t, k);};$/;"	f	namespace:tf
TransformTwistAngularTest	geometry/tf/test/transform_twist_test.cpp	/^  TransformTwistAngularTest() {$/;"	f	class:TransformTwistAngularTest
TransformTwistAngularTest	geometry/tf/test/transform_twist_test.cpp	/^class TransformTwistAngularTest : public ::testing::Test {$/;"	c	file:
TransformTwistLinearTest	geometry/tf/test/transform_twist_test.cpp	/^  TransformTwistLinearTest() {$/;"	f	class:TransformTwistLinearTest
TransformTwistLinearTest	geometry/tf/test/transform_twist_test.cpp	/^class TransformTwistLinearTest : public ::testing::Test {$/;"	c	file:
Transformer	geometry/tf/include/tf/tf.h	/^class Transformer$/;"	c	namespace:tf
Transformer	geometry/tf/src/tf.cpp	/^Transformer::Transformer(bool interpolating,$/;"	f	class:Transformer
Transformer	geometry/tf/src/tf/listener.py	/^class Transformer(object):$/;"	c
TransformerROS	geometry/tf/src/tf/listener.py	/^class TransformerROS(Transformer):$/;"	c
TransformerSubclass	geometry/tf/test/testPython.py	/^        class TransformerSubclass(tf.Transformer):$/;"	c	function:TestPython.test_subclass
TruePosEvent	openslam_gmapping/gui/gsp_thread.h	/^		struct TruePosEvent : public Event{$/;"	s	struct:GridSlamProcessorThread
TurnLeft	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
TurnRight	openslam_gmapping/utils/optimizer.h	/^	enum Move {Forward, Backward, Left, Right, TurnRight, TurnLeft};$/;"	e	enum:GMapping::Optimizer::Move
TwistKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^void TwistKDLToMsg(const KDL::Twist &k, geometry_msgs::Twist &m){twistKDLToMsg(k, m);};$/;"	f	namespace:tf
TwistMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^void TwistMsgToKDL(const geometry_msgs::Twist &m, KDL::Twist &k) {twistMsgToKDL(m, k);};$/;"	f	namespace:tf
UIntPair	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^typedef std::pair<uint,uint> UIntPair;$/;"	t
UIntPair	openslam_gmapping/particlefilter/pf.h	/^typedef std::pair<uint,uint> UIntPair;$/;"	t
Unknown	geometry/tf/include/tf/message_filter.h	/^  Unknown,$/;"	e	enum:tf::filter_failure_reasons::FilterFailureReason
Unknown	openslam_gmapping/grid/map_test.cpp	/^const SimpleCell& SimpleCell::Unknown(){$/;"	f	class:SimpleCell
Unknown	openslam_gmapping/scanmatcher/smmap.cpp	/^const PointAccumulator& PointAccumulator::Unknown(){$/;"	f	class:GMapping::PointAccumulator
Vector3	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3() {}$/;"	f	class:tf::Vector3
Vector3	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3(const tfScalar& x, const tfScalar& y, const tfScalar& z)$/;"	f	class:tf::Vector3
Vector3	geometry/tf/include/tf/LinearMath/Vector3.h	/^class Vector3$/;"	c	namespace:tf
Vector3Data	geometry/tf/include/tf/LinearMath/Vector3.h	26;"	d
Vector3DataName	geometry/tf/include/tf/LinearMath/Vector3.h	27;"	d
Vector3DoubleData	geometry/tf/include/tf/LinearMath/Vector3.h	/^struct	Vector3DoubleData$/;"	s	namespace:tf
Vector3FloatData	geometry/tf/include/tf/LinearMath/Vector3.h	/^struct	Vector3FloatData$/;"	s	namespace:tf
VectorKDLToTF	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline VectorKDLToTF(const KDL::Vector &k, tf::Vector3 &t) {vectorKDLToTF(k, t);};$/;"	f	namespace:tf
VectorTFToKDL	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^void inline VectorTFToKDL(const tf::Vector3 &t, KDL::Vector &k) {vectorTFToKDL(t, k);};$/;"	f	namespace:tf
WalkEnding	geometry/tf/src/tf.cpp	/^enum WalkEnding$/;"	g	file:
YUV422	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    const std::string YUV422="yuv422";$/;"	m	namespace:sensor_msgs::image_encodings
_AXES2TUPLE	geometry/tf/src/tf/transformations.py	/^_AXES2TUPLE = {$/;"	v
_DATATYPES	common_msgs/sensor_msgs/src/sensor_msgs/point_cloud2.py	/^_DATATYPES = {}$/;"	v
_EPS	geometry/tf/src/tf/transformations.py	/^_EPS = numpy.finfo(float).eps * 4.0$/;"	v
_GVALUES_H_	openslam_gmapping/include/gmapping/utils/gvalues.h	2;"	d
_ICP_H_	openslam_gmapping/include/gmapping/scanmatcher/icp.h	2;"	d
_NEXT_AXIS	geometry/tf/src/tf/transformations.py	/^_NEXT_AXIS = [1, 2, 0, 1]$/;"	v
_OPTIMIZER_H_	openslam_gmapping/utils/optimizer.h	2;"	d
_POINT_H_	openslam_gmapping/include/gmapping/utils/point.h	2;"	d
_QNAVIGATOR_WIDGET_H	openslam_gmapping/gui/qnavigatorwidget.h	2;"	d
_QPIXMAPDUMPER_H_	openslam_gmapping/gui/qpixmapdumper.h	2;"	d
_QSLAMANDNAV_WIDGET_H	openslam_gmapping/gui/qslamandnavwidget.h	2;"	d
_TUPLE2AXES	geometry/tf/src/tf/transformations.py	/^_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())$/;"	v
_USE_MATH_DEFINES	geometry/tf/src/tf_echo.cpp	34;"	d	file:
__DRAND48_DEFINED__	openslam_gmapping/include/gmapping/utils/gvalues.h	16;"	d
__FUNCDNAME__	openslam_gmapping/include/gmapping/grid/array2d.h	11;"	d
__docformat__	geometry/tf/src/tf/transformations.py	/^__docformat__ = "restructuredtext en"$/;"	v
__init__	geometry/tf/scripts/python_benchmark.py	/^    def __init__(self, func):$/;"	m	class:Timer
__init__	geometry/tf/scripts/tf_remap	/^    def __init__(self):$/;"	m	class:TfRemapper
__init__	geometry/tf/src/tf/broadcaster.py	/^    def __init__(self, queue_size=100):$/;"	m	class:TransformBroadcaster
__init__	geometry/tf/src/tf/listener.py	/^    def __init__(self, *args, **kwargs):$/;"	m	class:TransformListener
__init__	geometry/tf/src/tf/listener.py	/^    def __init__(self, interpolate=True, cache_time=None):$/;"	m	class:Transformer
__init__	geometry/tf/src/tf/transformations.py	/^    def __init__(self, initial=None):$/;"	m	class:Arcball
_get_struct_fmt	common_msgs/sensor_msgs/src/sensor_msgs/point_cloud2.py	/^def _get_struct_fmt(is_bigendian, fields, field_names=None):$/;"	f
_import_module	geometry/tf/src/tf/transformations.py	/^def _import_module(module_name, warn=True, prefix='_py_', ignore='_'):$/;"	f
_msgs	geometry/tf/src/tf/tfwtf.py	/^_msgs = []$/;"	v
_tf_handle	geometry/tf/src/tf/tfwtf.py	/^def _tf_handle(msg):$/;"	f
absolute	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::absolute() const$/;"	f	class:tf::Matrix3x3
absolute	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3 absolute() const $/;"	f	class:tf::Vector3
absolute4	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfVector4 absolute4() const $/;"	f	class:tf::tfVector4
absoluteDifference	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> absoluteDifference(const orientedpoint<T,A>& p1,const orientedpoint<T,A>& p2){$/;"	f	namespace:GMapping
absoluteSum	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> absoluteSum(const orientedpoint<T,A>& p1,const orientedpoint<T,A>& p2){$/;"	f	namespace:GMapping
absoluteSum	openslam_gmapping/include/gmapping/utils/point.h	/^point<T> absoluteSum(const orientedpoint<T,A>& p1,const point<T>& p2){$/;"	f	namespace:GMapping
acc	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	FloatPoint acc;$/;"	m	struct:GMapping::PointAccumulator
accWeight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double accWeight;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
accum	geometry/tf/src/tf.cpp	/^  void accum(bool source)$/;"	f	struct:CanTransformAccum
accum	geometry/tf/src/tf.cpp	/^  void accum(bool source)$/;"	f	struct:TransformAccum
activeBeams	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^unsigned int RangeReading::activeBeams(double density) const{$/;"	f	class:GMapping::RangeReading
add	geometry/tf/include/tf/message_filter.h	/^  void add(const MConstPtr& message)$/;"	f	class:tf::MessageFilter
add	geometry/tf/include/tf/message_filter.h	/^  void add(const MEvent& evt)$/;"	f	class:tf::MessageFilter
add	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	inline void add(const PointAccumulator& p) {acc=acc+p.acc; n+=p.n; visits+=p.visits; }$/;"	f	struct:GMapping::PointAccumulator
add	openslam_gmapping/utils/datasmoother.h	/^  void add(double x, double p) {$/;"	f	class:GMapping::DataSmoother
addDelta	geometry/tf_conversions/src/tf_kdl.cpp	/^  geometry_msgs::Pose addDelta(const geometry_msgs::Pose &pose, const geometry_msgs::Twist &twist, const double &t)$/;"	f	namespace:tf
addEdge	openslam_gmapping/grid/graphmap.cpp	/^void GraphPatchGraph::addEdge(GraphPatchGraph::Vertex* v1, GraphPatchGraph::VertexVertex* v2, $/;"	f	class:GMapping::GraphPatchGraph
addEvent	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::addEvent(GridSlamProcessorThread::Event * e){$/;"	f	class:GridSlamProcessorThread
addPointField	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline int addPointField(sensor_msgs::PointCloud2 &cloud_msg, const std::string &name, int count, int datatype,$/;"	f	namespace:__anon1
addReading	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::addReading(RangeReading& reading){$/;"	f	class:CarmenWrapper
addScan	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::addScan(const sensor_msgs::LaserScan& scan, GMapping::OrientedPoint& gmap_pose)$/;"	f	class:SlamGMapping
addTransformsChangedListener	geometry/tf/src/tf.cpp	/^boost::signals2::connection Transformer::addTransformsChangedListener(boost::function<void(void)> callback)$/;"	f	class:Transformer
address	openslam_gmapping/grid/map_test.cpp	/^	static SimpleCell* address;$/;"	m	struct:SimpleCell	file:
address	openslam_gmapping/grid/map_test.cpp	/^SimpleCell* SimpleCell::address=0;$/;"	m	class:SimpleCell	file:
adjoint	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::adjoint() const $/;"	f	class:tf::Matrix3x3
allFramesAsDot	geometry/tf/src/tf.cpp	/^std::string Transformer::allFramesAsDot(double current_time) const$/;"	f	class:Transformer
allFramesAsDot	geometry/tf/src/tf/listener.py	/^    def allFramesAsDot(self, current_time=None):$/;"	m	class:Transformer
allFramesAsString	geometry/tf/src/tf.cpp	/^std::string Transformer::allFramesAsString() const$/;"	f	class:Transformer
allFramesAsString	geometry/tf/src/tf/listener.py	/^    def allFramesAsString(self):$/;"	m	class:Transformer
allocActiveArea	openslam_gmapping/include/gmapping/grid/harray2d.h	/^void HierarchicalArray2D<Cell>::allocActiveArea(){$/;"	f	class:GMapping::HierarchicalArray2D
angle	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar angle(const Quaternion& q) const $/;"	f	class:tf::Quaternion
angle	geometry/tf/include/tf/LinearMath/Quaternion.h	/^angle(const Quaternion& q1, const Quaternion& q2) $/;"	f	namespace:tf
angle	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfScalar angle(const Vector3& v) const $/;"	f	class:tf::Vector3
angleShortestPath	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar angleShortestPath(const Quaternion& q) const $/;"	f	class:tf::Quaternion
angleShortestPath	geometry/tf/include/tf/LinearMath/Quaternion.h	/^angleShortestPath(const Quaternion& q1, const Quaternion& q2) $/;"	f	namespace:tf
angularOdometryReliability	openslam_gmapping/gui/gsp_thread.h	/^		double angularOdometryReliability;$/;"	m	struct:GridSlamProcessorThread
angularStep	openslam_gmapping/utils/optimizer.h	/^	double angularStep, linearStep;$/;"	m	struct:GMapping::OptimizerParams
angularUpdate	openslam_gmapping/gui/gsp_thread.h	/^		double angularUpdate;$/;"	m	struct:GridSlamProcessorThread
angularUpdate	openslam_gmapping/gui/qparticleviewer.h	/^			double linearUpdate, angularUpdate;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
angularUpdate_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double angularUpdate_;$/;"	m	class:SlamGMapping
angular_update_distance_	geometry/tf/src/change_notifier.cpp	/^  double angular_update_distance_;$/;"	m	class:FramePair	file:
approxGauss	openslam_gmapping/utils/datasmoother.h	/^  void approxGauss(double step, double* mean, double* sigma) {$/;"	f	class:GMapping::DataSmoother
arcball_constrain_to_axis	geometry/tf/src/tf/transformations.py	/^def arcball_constrain_to_axis(point, axis):$/;"	f
arcball_map_to_sphere	geometry/tf/src/tf/transformations.py	/^def arcball_map_to_sphere(point, center, radius):$/;"	f
arcball_nearest_axis	geometry/tf/src/tf/transformations.py	/^def arcball_nearest_axis(point, axes):$/;"	f
area	openslam_gmapping/utils/orientedboundingbox.hxx	/^double OrientedBoundingBox<NUMERIC>::area() {$/;"	f	class:OrientedBoundingBox
asMatrix	geometry/tf/src/tf/listener.py	/^    def asMatrix(self, target_frame, hdr):$/;"	m	class:TransformerROS
assertQuaternionValid	geometry/tf/include/tf/tf.h	/^inline void assertQuaternionValid(const geometry_msgs::Quaternion & q)$/;"	f	namespace:tf
assertQuaternionValid	geometry/tf/include/tf/tf.h	/^inline void assertQuaternionValid(const tf::Quaternion & q)$/;"	f	namespace:tf
assert_resolved	geometry/tf/src/tf.cpp	/^std::string assert_resolved(const std::string& prefix, const std::string& frame_id)$/;"	f
astep	openslam_gmapping/gui/gsp_thread.h	/^		double astep;$/;"	m	struct:GridSlamProcessorThread
astep	openslam_gmapping/gui/qparticleviewer.h	/^			double lstep, astep;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
astep_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double astep_;$/;"	m	class:SlamGMapping
authority_frequency_map	geometry/tf/src/tf_monitor.cpp	/^  std::map<std::string, std::vector<double> > authority_frequency_map;$/;"	m	class:TFMonitor	file:
authority_map	geometry/tf/src/tf_monitor.cpp	/^  std::map<std::string, std::vector<double> > authority_map;$/;"	m	class:TFMonitor	file:
autoptr	openslam_gmapping/include/gmapping/utils/autoptr.h	/^autoptr<X>::autoptr(X* p){$/;"	f	class:GMapping::autoptr
autoptr	openslam_gmapping/include/gmapping/utils/autoptr.h	/^autoptr<X>::autoptr(const autoptr<X>& ap){$/;"	f	class:GMapping::autoptr
autoptr	openslam_gmapping/include/gmapping/utils/autoptr.h	/^class autoptr{$/;"	c	namespace:GMapping
autoscale	openslam_gmapping/gui/qgraphpainter.h	/^		bool autoscale;$/;"	m	class:QGraphPainter
autosize	openslam_gmapping/gui/gsp_thread.h	/^		bool autosize;$/;"	m	struct:GridSlamProcessorThread
auxiliaryEvolver	openslam_gmapping/particlefilter/particlefilter.cpp	/^struct auxiliaryEvolver{$/;"	s	file:
auxiliary_evolver	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^struct auxiliary_evolver{$/;"	s
base_frame_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    std::string base_frame_;$/;"	m	class:SlamGMapping
beams	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		inline const std::vector<Beam>& beams() const {return m_beams;}$/;"	f	class:GMapping::RangeSensor
beams	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		inline std::vector<Beam>& beams() {return m_beams;}$/;"	f	class:GMapping::RangeSensor
bestMap	openslam_gmapping/gui/qparticleviewer.h	/^		ScanMatcherMap * bestMap;$/;"	m	class:GMapping::QParticleViewer
bestParticlePose	openslam_gmapping/gui/qparticleviewer.h	/^		Point bestParticlePose;$/;"	m	class:GMapping::QParticleViewer
bestidx	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	unsigned int bestidx=rl.getBestIdx();$/;"	v
bitDepth	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline int bitDepth(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
boundingBox	openslam_gmapping/gui/gsp_thread.cpp	/^OrientedPoint GridSlamProcessorThread::boundingBox(SensorLog* log, double& xmin, double& ymin, double& xmax, double& ymax) const{$/;"	f	class:GridSlamProcessorThread
boundingBox	openslam_gmapping/log/sensorlog.cpp	/^OrientedPoint SensorLog::boundingBox(double& xmin, double& ymin, double& xmax, double& ymax) const {$/;"	f	class:GMapping::SensorLog
broadcaster	geometry/tf/src/static_transform_publisher.cpp	/^  tf::TransformBroadcaster broadcaster;$/;"	m	class:TransformSender	file:
broadcaster	geometry/tf/test/testBroadcaster.cpp	/^  tf::TransformBroadcaster broadcaster;$/;"	m	class:testBroadcaster	file:
c	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	unsigned int  c=1;$/;"	v
c	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^			double s,c;		\/\/sinus and cosinus of the beam (optimization);$/;"	m	struct:GMapping::RangeSensor::Beam
callback	geometry/tf/scripts/tf_remap	/^    def callback(self, tf_msg):$/;"	m	class:TfRemapper
callback	geometry/tf/src/tf_monitor.cpp	/^  void callback(const ros::MessageEvent<tf::tfMessage const>& msg_evt)$/;"	f	class:TFMonitor
canTransform	geometry/tf/src/tf.cpp	/^bool Transformer::canTransform(const std::string& target_frame, const std::string& source_frame,$/;"	f	class:Transformer
canTransform	geometry/tf/src/tf.cpp	/^bool Transformer::canTransform(const std::string& target_frame,const ros::Time& target_time, const std::string& source_frame,$/;"	f	class:Transformer
canTransform	geometry/tf/src/tf/listener.py	/^    def canTransform(self, target_frame, source_frame, time):$/;"	m	class:Transformer
canTransformFull	geometry/tf/src/tf/listener.py	/^    def canTransformFull(self, target_frame, target_time, source_frame, source_time, fixed_frame):$/;"	m	class:Transformer
carmen2point	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^OrientedPoint CarmenWrapper::carmen2point (const carmen_point_t& p){$/;"	f	class:CarmenWrapper
carmen2reading	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^RangeReading CarmenWrapper::carmen2reading(const carmen_robot_laser_message& msg){$/;"	f	class:CarmenWrapper
cartesianForm	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^std::vector<Point> RangeReading::cartesianForm(double maxRange) const{$/;"	f	class:GMapping::RangeReading
cell	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline Cell& cell(const IntPoint& p) {return cell(p.x,p.y);}$/;"	f	class:GMapping::Array2D
cell	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline const Cell& cell(const IntPoint& p) const {return cell(p.x,p.y);}$/;"	f	class:GMapping::Array2D
cell	openslam_gmapping/include/gmapping/grid/array2d.h	/^inline Cell& Array2D<Cell,debug>::cell(int x, int y){$/;"	f	class:GMapping::Array2D
cell	openslam_gmapping/include/gmapping/grid/array2d.h	/^inline const Cell& Array2D<Cell,debug>::cell(int x, int y) const{$/;"	f	class:GMapping::Array2D
cell	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline Cell& cell(const IntPoint& p) { return cell(p.x,p.y); }$/;"	f	class:GMapping::HierarchicalArray2D
cell	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline const Cell& cell(const IntPoint& p) const { return cell(p.x,p.y); }$/;"	f	class:GMapping::HierarchicalArray2D
cell	openslam_gmapping/include/gmapping/grid/harray2d.h	/^Cell& HierarchicalArray2D<Cell>::cell(int x, int y){$/;"	f	class:GMapping::HierarchicalArray2D
cell	openslam_gmapping/include/gmapping/grid/harray2d.h	/^const Cell& HierarchicalArray2D<Cell>::cell(int x, int y) const{$/;"	f	class:GMapping::HierarchicalArray2D
cell	openslam_gmapping/include/gmapping/grid/map.h	/^		inline Cell& cell(double x, double y) {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^		inline Cell& cell(int x, int y) {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^		inline const Cell& cell(double x, double y) const {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^		inline const Cell& cell(int x, int y) const  {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^  const Cell& Map<Cell,Storage,isClass>::cell(const IntPoint& p) const {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^Cell& Map<Cell,Storage,isClass>::cell(const IntPoint& p) {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^Cell& Map<Cell,Storage,isClass>::cell(const Point& p) {$/;"	f	class:GMapping::Map
cell	openslam_gmapping/include/gmapping/grid/map.h	/^const  Cell& Map<Cell,Storage,isClass>::cell(const Point& p) const {$/;"	f	class:GMapping::Map
cellState	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline AccessibilityState cellState(const IntPoint& p) const { return cellState(p.x, p.y);}$/;"	f	class:GMapping::Array2D
cellState	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline AccessibilityState cellState(int x, int y) const { return (AccessibilityState) (isInside(x,y)?(Inside|Allocated):Outside);}$/;"	f	class:GMapping::Array2D
cellState	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline AccessibilityState cellState(const IntPoint& p) const { return cellState(p.x,p.y); }$/;"	f	class:GMapping::HierarchicalArray2D
cellState	openslam_gmapping/include/gmapping/grid/harray2d.h	/^AccessibilityState  HierarchicalArray2D<Cell>::cellState(int x, int y) const {$/;"	f	class:GMapping::HierarchicalArray2D
cells	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline Cell** cells() {return m_cells;}$/;"	f	class:GMapping::Array2D
center	openslam_gmapping/grid/graphmap.cpp	/^	OrientedPoint center;$/;"	m	struct:GMapping::GraphMapPatch	file:
centered_laser_pose_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    tf::Stamped<tf::Pose> centered_laser_pose_;$/;"	m	class:SlamGMapping
chain	geometry/tf/src/tf/listener.py	/^    def chain(self, target_frame, target_time, source_frame, source_time, fixed_frame):$/;"	m	class:Transformer
chainAsVector	geometry/tf/src/tf.cpp	/^void Transformer::chainAsVector(const std::string & target_frame, ros::Time target_time, const std::string & source_frame, ros::Time source_time, const std::string& fixed_frame, std::vector<std::string>& output) const$/;"	f	class:Transformer
chain_	geometry/tf/src/tf_monitor.cpp	/^  std::vector<std::string> chain_;$/;"	m	class:TFMonitor	file:
checkFailures	geometry/tf/include/tf/message_filter.h	/^  void checkFailures()$/;"	f	class:tf::MessageFilter
checkMapData	slam_gmapping/gmapping/test/rtest.cpp	/^    void checkMapData(const nav_msgs::OccupancyGrid& map)$/;"	f	class:MapClientTest
checkMapMetaData	slam_gmapping/gmapping/test/rtest.cpp	/^    void checkMapMetaData(const nav_msgs::MapMetaData& map_metadata)$/;"	f	class:MapClientTest
child_frame_id_	geometry/tf/include/tf/time_cache.h	/^  CompactFrameID child_frame_id_;$/;"	m	class:tf::TransformStorage
child_frame_id_	geometry/tf/include/tf/transform_datatypes.h	/^  std::string child_frame_id_; \/\/\/< The frame_id of the coordinate frame this transform defines$/;"	m	class:tf::StampedTransform
childs	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      unsigned int childs;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
clear	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline void PointCloud2Modifier::clear()$/;"	f	class:sensor_msgs::PointCloud2Modifier
clear	geometry/tf/include/tf/message_filter.h	/^  void clear()$/;"	f	class:tf::MessageFilter
clear	geometry/tf/src/tf.cpp	/^void Transformer::clear()$/;"	f	class:Transformer
clear	geometry/tf/src/tf/listener.py	/^    def clear(self):$/;"	m	class:Transformer
clear	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::clear(){$/;"	f	class:QGraphPainter
clear	openslam_gmapping/include/gmapping/grid/array2d.h	/^void Array2D<Cell,debug>::clear(){$/;"	f	class:GMapping::Array2D
clearImage	common_msgs/sensor_msgs/include/sensor_msgs/fill_image.h	/^  static inline void clearImage(Image& image)$/;"	f	namespace:sensor_msgs
clearList	geometry/tf/src/cache.cpp	/^void TimeCache::clearList()$/;"	f	class:TimeCache
clip_matrix	geometry/tf/src/tf/transformations.py	/^def clip_matrix(left, right, bottom, top, near, far, perspective=False):$/;"	f
clone	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor* GridSlamProcessor::clone() const {$/;"	f	class:GMapping::GridSlamProcessor
closestAxis	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int closestAxis() const $/;"	f	class:tf::Vector3
closestAxis4	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int closestAxis4() const $/;"	f	class:tf::tfVector4
cloud_msg_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  PointCloud2& cloud_msg_;$/;"	m	class:sensor_msgs::PointCloud2Modifier
cmd	geometry/tf/scripts/bullet_migration_sed.py	/^cmd = "find . -type f ! -name '*.svn-base' -a ! -name '*.hg' -a ! -name '*.git' -a \\( -name '*.c*' -o -name '*.h*' \\) -exec sed -i '%(rule)s' {} \\;"$/;"	v
cmp_maps	slam_gmapping/gmapping/test/test_map.py	/^  def cmp_maps(self, f0, f1):$/;"	m	class:TestGmapping
cofac	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	tfScalar cofac(int r1, int c1, int r2, int c2) const $/;"	f	class:tf::Matrix3x3
columns	openslam_gmapping/utils/dmatrix.h	/^		int columns() const { return ncols; }$/;"	f	class:GMapping::DMatrix
common	geometry/tf/test/testPython.py	/^    def common(self, t):$/;"	m	class:TestPython
compose	openslam_gmapping/utils/movement.cpp	/^void FSRMovement::compose(const FSRMovement& move2) {$/;"	f	class:GMapping::FSRMovement
composeMoves	openslam_gmapping/utils/movement.cpp	/^FSRMovement FSRMovement::composeMoves(const FSRMovement& move1, $/;"	f	class:GMapping::FSRMovement
compose_matrix	geometry/tf/src/tf/transformations.py	/^def compose_matrix(scale=None, shear=None, angles=None, translate=None,$/;"	f
computeActiveArea	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^void ScanMatcher::computeActiveArea(ScanMatcherMap& map, const OrientedPoint& p, const double* readings){$/;"	f	class:GMapping::ScanMatcher
computeActiveArea	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^void ScanMatcher::computeActiveArea(ScanMatcherMap& map, const OrientedPoint& p, const double* readings){$/;"	f	class:GMapping::ScanMatcher
computeBoundingBox	openslam_gmapping/gui/gfs2img.cpp	/^void computeBoundingBox(double& xmin, double& ymin, double& xmax, double& ymax, const LaserRecord& laser, const OrientedPoint& pose, double maxrange){$/;"	f
computeBoundingBox	openslam_gmapping/gui/gfs2img.cpp	/^void computeBoundingBox(double& xmin, double& ymin, double& xmax, double& ymax, const RecordList& rl, double maxrange){$/;"	f
computeCummuated	openslam_gmapping/utils/datasmoother.h	/^  void computeCummuated() {$/;"	f	class:GMapping::DataSmoother
computeGaussianFromSamples	openslam_gmapping/include/gmapping/utils/stat.h	/^Gaussian3 computeGaussianFromSamples(PointIterator& pointBegin, PointIterator& pointEnd){$/;"	f	namespace:GMapping
computeGaussianFromSamples	openslam_gmapping/include/gmapping/utils/stat.h	/^Gaussian3 computeGaussianFromSamples(PointIterator& pointBegin, PointIterator& pointEnd, WeightIterator& weightBegin, WeightIterator& weightEnd){$/;"	f	namespace:GMapping
computePath	openslam_gmapping/gridfastslam/gfsreader.cpp	/^RecordList RecordList::computePath(unsigned int i, RecordList::const_iterator frame) const{$/;"	f	class:GMapping::GFSReader::RecordList
computePoseEntropy	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::computePoseEntropy()$/;"	f	class:SlamGMapping
computeSensorMap	openslam_gmapping/log/carmenconfiguration.cpp	/^SensorMap CarmenConfiguration::computeSensorMap() const{$/;"	f	class:GMapping::CarmenConfiguration
concatenate_matrices	geometry/tf/src/tf/transformations.py	/^def concatenate_matrices(*matrices):$/;"	f
confirmLocalization	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool confirmLocalization;$/;"	m	class:QNavigatorWidget
connectInput	geometry/tf/include/tf/message_filter.h	/^  void connectInput(F& f)$/;"	f	class:tf::MessageFilter
considerOdometryCovariance	openslam_gmapping/gui/gsp_thread.h	/^		bool considerOdometryCovariance;$/;"	m	struct:GridSlamProcessorThread
convertPointCloud2ToPointCloud	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud_conversion.h	/^static inline bool convertPointCloud2ToPointCloud (const sensor_msgs::PointCloud2 &input, sensor_msgs::PointCloud &output)$/;"	f	namespace:sensor_msgs
convertPointCloudToPointCloud2	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud_conversion.h	/^static inline bool convertPointCloudToPointCloud2 (const sensor_msgs::PointCloud &input, sensor_msgs::PointCloud2 &output)$/;"	f	namespace:sensor_msgs
convertStringArgument	openslam_gmapping/include/gmapping/utils/macro_params.h	37;"	d
copyright	geometry/tf/conf.py	/^copyright = u'2009, Willow Garage, Inc.'$/;"	v
copyright	geometry/tf_conversions/conf.py	/^copyright = u'2010, Willow Garage, Inc.'$/;"	v
count	geometry/tf/test/testBroadcaster.cpp	/^  int count;$/;"	m	class:testBroadcaster	file:
count	openslam_gmapping/gui/qparticleviewer.h	/^		int count;$/;"	m	class:GMapping::QParticleViewer
count1	geometry/tf/test/testBroadcaster.cpp	/^  int count1;$/;"	m	class:testBroadcaster	file:
count_	geometry/tf/test/test_message_filter.cpp	/^	int count_;$/;"	m	class:Notification	file:
counter	openslam_gmapping/gui/qpixmapdumper.h	/^	int counter;$/;"	m	struct:QPixmapDumper
cov	openslam_gmapping/include/gmapping/utils/stat.h	/^	Covariance3 cov;$/;"	m	struct:GMapping::Gaussian3
covariance	openslam_gmapping/grid/graphmap.cpp	/^	Covariance3 covariance;$/;"	m	struct:GMapping::GraphMapEdge	file:
covariance	openslam_gmapping/include/gmapping/utils/stat.h	/^	EigenCovariance3 covariance;$/;"	m	struct:GMapping::Gaussian3
cramerVonMisesToGauss	openslam_gmapping/utils/datasmoother.h	/^  double cramerVonMisesToGauss(double step, double mean, double sigma) {$/;"	f	class:GMapping::DataSmoother
createEmptyException	geometry/tf/src/cache.cpp	/^void createEmptyException(std::string *error_str)$/;"	f
createExtrapolationException1	geometry/tf/src/cache.cpp	/^void createExtrapolationException1(ros::Time t0, ros::Time t1, std::string* error_str)$/;"	f
createExtrapolationException2	geometry/tf/src/cache.cpp	/^void createExtrapolationException2(ros::Time t0, ros::Time t1, std::string* error_str)$/;"	f
createExtrapolationException3	geometry/tf/src/cache.cpp	/^void createExtrapolationException3(ros::Time t0, ros::Time t1, std::string* error_str)$/;"	f
createIdentityQuaternion	geometry/tf/include/tf/transform_datatypes.h	/^static inline tf::Quaternion createIdentityQuaternion()$/;"	f	namespace:tf
createPatch	openslam_gmapping/include/gmapping/grid/harray2d.h	/^Array2D<Cell>* HierarchicalArray2D<Cell>::createPatch(const IntPoint& ) const{$/;"	f	class:GMapping::HierarchicalArray2D
createQuaternionFromRPY	geometry/tf/include/tf/transform_datatypes.h	/^static inline tf::Quaternion createQuaternionFromRPY(double roll,double pitch,double yaw){$/;"	f	namespace:tf
createQuaternionFromYaw	geometry/tf/include/tf/transform_datatypes.h	/^static inline Quaternion createQuaternionFromYaw(double yaw){$/;"	f	namespace:tf
createQuaternionMsgFromRollPitchYaw	geometry/tf/include/tf/transform_datatypes.h	/^static inline geometry_msgs::Quaternion createQuaternionMsgFromRollPitchYaw(double roll,double pitch,double yaw){$/;"	f	namespace:tf
createQuaternionMsgFromYaw	geometry/tf/include/tf/transform_datatypes.h	/^static inline geometry_msgs::Quaternion createQuaternionMsgFromYaw(double yaw){$/;"	f	namespace:tf
create_cloud	common_msgs/sensor_msgs/src/sensor_msgs/point_cloud2.py	/^def create_cloud(header, fields, points):$/;"	f
create_cloud_xyz32	common_msgs/sensor_msgs/src/sensor_msgs/point_cloud2.py	/^def create_cloud_xyz32(header, points):$/;"	f
critscore	openslam_gmapping/gui/gsp_thread.h	/^		double critscore;$/;"	m	struct:GridSlamProcessorThread
cross	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3 cross(const Vector3& v) const$/;"	f	class:tf::Vector3
cycle_detection	geometry/tf/src/tf/tfwtf.py	/^def cycle_detection(ctx):$/;"	f
cycles	openslam_gmapping/gui/qpixmapdumper.h	/^	int cycles;$/;"	m	struct:QPixmapDumper
d	common_msgs/sensor_msgs/setup.py	/^d = generate_distutils_setup($/;"	v
d	geometry/tf/setup.py	/^d = generate_distutils_setup($/;"	v
d	geometry/tf_conversions/setup.py	/^d = generate_distutils_setup($/;"	v
data	openslam_gmapping/include/gmapping/utils/autoptr.h	/^		X* data;$/;"	m	struct:GMapping::autoptr::reference
data_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  TT* data_;$/;"	m	class:sensor_msgs::impl::PointCloud2IteratorBase
data_char_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  U* data_char_;$/;"	m	class:sensor_msgs::impl::PointCloud2IteratorBase
data_end_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  TT* data_end_;$/;"	m	class:sensor_msgs::impl::PointCloud2IteratorBase
deSerialize	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE	void	Matrix3x3::deSerialize(const struct	Matrix3x3Data& dataIn)$/;"	f	class:tf::Matrix3x3
deSerialize	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE	void	Transform::deSerialize(const TransformData& dataIn)$/;"	f	class:tf::Transform
deSerialize	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	Vector3::deSerialize(const struct	Vector3Data& dataIn)$/;"	f	class:tf::Vector3
deSerializeDouble	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE	void	Matrix3x3::deSerializeDouble(const struct	Matrix3x3DoubleData& dataIn)$/;"	f	class:tf::Matrix3x3
deSerializeDouble	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE	void	Transform::deSerializeDouble(const TransformDoubleData& dataIn)$/;"	f	class:tf::Transform
deSerializeDouble	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	Vector3::deSerializeDouble(const struct	Vector3DoubleData& dataIn)$/;"	f	class:tf::Vector3
deSerializeFloat	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE	void	Matrix3x3::deSerializeFloat(const struct	Matrix3x3FloatData& dataIn)$/;"	f	class:tf::Matrix3x3
deSerializeFloat	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE	void	Transform::deSerializeFloat(const TransformFloatData& dataIn)$/;"	f	class:tf::Transform
deSerializeFloat	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	Vector3::deSerializeFloat(const struct	Vector3FloatData& dataIn)$/;"	f	class:tf::Vector3
decompose_matrix	geometry/tf/src/tf/transformations.py	/^def decompose_matrix(matrix):$/;"	f
delay_map	geometry/tf/src/tf_monitor.cpp	/^  std::map<std::string, std::vector<double> > delay_map;$/;"	m	class:TFMonitor	file:
delta	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	double delta = 0.1;$/;"	v
delta	openslam_gmapping/gui/gsp_thread.h	/^		double delta;$/;"	m	struct:GridSlamProcessorThread
delta	openslam_gmapping/gui/qparticleviewer.h	/^			double xmin, ymin, xmax, ymax, delta;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
delta_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double delta_;$/;"	m	class:SlamGMapping
deserel_to_string	geometry/tf/scripts/python_benchmark.py	/^def deserel_to_string(o):$/;"	f
dest	geometry/tf/scripts/view_frames	/^                      dest="node")$/;"	v
destroyReferences	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void RecordList::destroyReferences(){$/;"	f	class:GMapping::GFSReader::RecordList
det	openslam_gmapping/utils/dmatrix.h	/^template <class X> const X DMatrix<X>::det() const {$/;"	f	class:GMapping::DMatrix
detach	openslam_gmapping/utils/dmatrix.h	/^template <class X> void DMatrix<X>::detach() {$/;"	f	class:GMapping::DMatrix
determinant	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::determinant() const$/;"	f	class:tf::Matrix3x3
diagonalize	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void diagonalize(Matrix3x3& rot, tfScalar threshold, int maxSteps)$/;"	f	class:tf::Matrix3x3
dim	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	unsigned int dim;$/;"	m	struct:Record	file:
dim	openslam_gmapping/gridfastslam/gfsreader.h	/^	unsigned int dim;$/;"	m	struct:GMapping::GFSReader::Record
disableYReference	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::disableYReference(){$/;"	f	class:QGraphPainter
disabled_random	geometry/tf/test/testPython.py	/^    def disabled_random(self):$/;"	m	class:TestPython
disconnectFailure	geometry/tf/include/tf/message_filter.h	/^  void disconnectFailure(const message_filters::Connection& c)$/;"	f	class:tf::MessageFilter
discretization	openslam_gmapping/utils/optimizer.h	/^	double discretization;$/;"	m	struct:GMapping::OptimizerParams
distance	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE tfScalar Vector3::distance(const Vector3& v) const$/;"	f	class:tf::Vector3
distance2	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE tfScalar Vector3::distance2(const Vector3& v) const$/;"	f	class:tf::Vector3
distortion_models	common_msgs/sensor_msgs/include/sensor_msgs/distortion_models.h	/^  namespace distortion_models$/;"	n	namespace:sensor_msgs
do_reverse_range_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    bool do_reverse_range_;$/;"	m	class:SlamGMapping
dot	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar dot(const Quaternion& q) const$/;"	f	class:tf::Quaternion
dot	geometry/tf/include/tf/LinearMath/Quaternion.h	/^dot(const Quaternion& q1, const Quaternion& q2) $/;"	f	namespace:tf
dot	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfScalar dot(const Vector3& v) const$/;"	f	class:tf::Vector3
dot_graph	geometry/tf/scripts/view_frames	/^        dot_graph = listen(5.0)$/;"	v
dot_graph	geometry/tf/scripts/view_frames	/^        dot_graph = poll(options.node)$/;"	v
dot_graph	geometry/tf/scripts/view_frames	/^    dot_graph = ''$/;"	v
down	geometry/tf/src/tf/transformations.py	/^    def down(self, point):$/;"	m	class:Arcball
drag	geometry/tf/src/tf/transformations.py	/^    def drag(self, point):$/;"	m	class:Arcball
dragging	openslam_gmapping/gui/qparticleviewer.h	/^		bool dragging;$/;"	m	class:GMapping::QParticleViewer
draggingPos	openslam_gmapping/gui/qparticleviewer.h	/^		QPoint draggingPos;$/;"	m	class:GMapping::QParticleViewer
drand48	openslam_gmapping/include/gmapping/utils/gvalues.h	/^     inline double drand48() { return double(rand()) \/ RAND_MAX;}$/;"	f
drawFromFile	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::drawFromFile(){$/;"	f	class:QParticleViewer
drawFromMemory	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::drawFromMemory(){$/;"	f	class:QParticleViewer
drawFromMotion	openslam_gmapping/gridfastslam/motionmodel.cpp	/^MotionModel::drawFromMotion (const OrientedPoint& p, double linearMove, double angularMove) const{$/;"	f	class:GMapping::MotionModel
drawFromMotion	openslam_gmapping/gridfastslam/motionmodel.cpp	/^MotionModel::drawFromMotion(const OrientedPoint& p, const OrientedPoint& pnew, const OrientedPoint& pold) const{$/;"	f	class:GMapping::MotionModel
drawFromObservation	openslam_gmapping/gui/qparticleviewer.h	/^			bool drawFromObservation;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
drawMap	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::drawMap(const ScanMatcherMap& map){$/;"	f	class:QParticleViewer
drawParticleMove	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::drawParticleMove(const QParticleViewer::OrientedPointVector& oldPose, const QParticleViewer::OrientedPointVector& newPose){$/;"	f	class:QParticleViewer
drawPoints	openslam_gmapping/gui/qmappainter.h	/^void QMapPainter::drawPoints(const Iterator& begin, const Iterator& end, unsigned char r,  unsigned char g, unsigned char b){$/;"	f	class:QMapPainter
drawRobot	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool drawRobot;$/;"	m	class:QNavigatorWidget
drawRobot	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool drawRobot;$/;"	m	class:QSLAMandNavWidget
dropped_message_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t dropped_message_count_;$/;"	m	class:tf::MessageFilter
dump	openslam_gmapping/gui/qpixmapdumper.cpp	/^bool QPixmapDumper::dump(const QPixmap& pixmap){$/;"	f	class:QPixmapDumper
dumper	openslam_gmapping/gui/qnavigatorwidget.h	/^		QPixmapDumper dumper;$/;"	m	class:QNavigatorWidget
dumper	openslam_gmapping/gui/qslamandnavwidget.h	/^		QPixmapDumper dumper;$/;"	m	class:QSLAMandNavWidget
echoListener	geometry/tf/src/tf_echo.cpp	/^  echoListener()$/;"	f	class:echoListener
echoListener	geometry/tf/src/tf_echo.cpp	/^class echoListener$/;"	c	file:
eigen_decomposition	openslam_gmapping/scanmatcher/eig3.cpp	/^void eigen_decomposition(double A[n][n], double V[n][n], double d[n]) {$/;"	f
elapsed_time_within_epsilon	geometry/tf/test/testPython.py	/^        def elapsed_time_within_epsilon(t, delta, epsilon):$/;"	f	function:TestPython.test_wait_for_transform
elems	openslam_gmapping/utils/dmatrix.h	/^		X * elems;$/;"	m	class:GMapping::DMatrix
enableMotion	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool enableMotion;$/;"	m	class:QNavigatorWidget
enableMotion	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool enableMotion;$/;"	m	class:QSLAMandNavWidget
end	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^V<T> PointCloud2IteratorBase<T, TT, U, C, V>::end() const$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
endl	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	cout << endl << "best index = " <<  bestidx<< endl;$/;"	v
entropy	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^double PointAccumulator::entropy() const{$/;"	f	class:GMapping::PointAccumulator
entropy_publisher_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::Publisher entropy_publisher_;	\/\/ entropy : means unknown info.$/;"	m	class:SlamGMapping
epsilon	geometry/tf/test/quaternion.cpp	/^double epsilon = 10E-6;$/;"	v
err	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	bool err=0;$/;"	v
euclidianDist	openslam_gmapping/include/gmapping/utils/point.h	/^inline double euclidianDist(const orientedpoint<T,A>& p1, const orientedpoint<T,A>& p2){$/;"	f	namespace:GMapping
euclidianDist	openslam_gmapping/include/gmapping/utils/point.h	/^inline double euclidianDist(const orientedpoint<T,A>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
euclidianDist	openslam_gmapping/include/gmapping/utils/point.h	/^inline double euclidianDist(const point<T>& p1, const orientedpoint<T,A>& p2 ){$/;"	f	namespace:GMapping
euclidianDist	openslam_gmapping/include/gmapping/utils/point.h	/^inline double euclidianDist(const point<T>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
euler_from_matrix	geometry/tf/src/tf/transformations.py	/^def euler_from_matrix(matrix, axes='sxyz'):$/;"	f
euler_from_quaternion	geometry/tf/src/tf/transformations.py	/^def euler_from_quaternion(quaternion, axes='sxyz'):$/;"	f
euler_matrix	geometry/tf/src/tf/transformations.py	/^def euler_matrix(ai, aj, ak, axes='sxyz'):$/;"	f
eval	openslam_gmapping/include/gmapping/utils/stat.h	/^	double eval[3];$/;"	m	struct:GMapping::EigenCovariance3
eval	openslam_gmapping/utils/stat.cpp	/^double Gaussian3::eval(const OrientedPoint& p) const{$/;"	f	class:GMapping::Gaussian3
evalLogGaussian	openslam_gmapping/utils/stat.cpp	/^double evalLogGaussian(double sigmaSquare, double delta){$/;"	f	namespace:GMapping
evec	openslam_gmapping/include/gmapping/utils/stat.h	/^	double evec[3][3];$/;"	m	struct:GMapping::EigenCovariance3
eventBuffer	openslam_gmapping/gui/gsp_thread.h	/^		EventDeque eventBuffer;$/;"	m	struct:GridSlamProcessorThread
eventBufferLength	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int eventBufferLength;$/;"	m	struct:GridSlamProcessorThread
evolutionModel	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^	EvolutionModel evolutionModel;$/;"	m	struct:auxiliary_evolver
evolutionModel	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^	EvolutionModel evolutionModel;$/;"	m	struct:evolver
evolutionModel	openslam_gmapping/particlefilter/particlefilter.cpp	/^	EvolutionModel evolutionModel;$/;"	m	struct:auxiliaryEvolver	file:
evolve	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void auxiliary_evolver<Particle, Numeric, QualificationModel, EvolutionModel, LikelyhoodModel>::evolve$/;"	f	class:auxiliary_evolver
evolve	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void evolver<Particle, EvolutionModel>::evolve(std::vector<Particle>& dest, const std::vector<Particle>& src){$/;"	f	class:evolver
evolve	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void evolver<Particle, EvolutionModel>::evolve(std::vector<Particle>& particles){$/;"	f	class:evolver
evolve	openslam_gmapping/particlefilter/particlefilter.cpp	/^void auxiliaryEvolver<State, Numeric, QualificationModel, EvolutionModel, LikelyhoodModel>::evolve$/;"	f	class:auxiliaryEvolver::auxiliaryEvolver
evolve	openslam_gmapping/particlefilter/particlefilter.cpp	/^void evolver<State, Numeric, EvolutionModel>::evolve(std::vector<evolver::Particle>& dest, const std::vector<evolver::Particle>& src) const{$/;"	f	class:evolver
evolve	openslam_gmapping/particlefilter/particlefilter.cpp	/^void evolver<State, Numeric, EvolutionModel>::evolve(std::vector<evolver::Particle>& particles) const{$/;"	f	class:evolver
evolve	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	Particle evolve(const Particle& p){$/;"	f	struct:EvolutionModel
evolve	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	Particle evolve(const Particle& p){$/;"	f	struct:QualificationModel
evolve	openslam_gmapping/particlefilter/range_bearing.cpp	/^	Particle evolve(const Particle& p){$/;"	f	struct:EvolutionModel
evolver	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^struct evolver{$/;"	s
exclude_trees	geometry/tf/conf.py	/^exclude_trees = ['_build']$/;"	v
exclude_trees	geometry/tf_conversions/conf.py	/^exclude_trees = ['_build']$/;"	v
expectInvalidQuaternion	geometry/tf/test/tf_unittest.cpp	/^bool expectInvalidQuaternion(geometry_msgs::Quaternion q)$/;"	f
expectInvalidQuaternion	geometry/tf/test/tf_unittest.cpp	/^bool expectInvalidQuaternion(tf::Quaternion q)$/;"	f
expectValidQuaternion	geometry/tf/test/tf_unittest.cpp	/^bool expectValidQuaternion(geometry_msgs::Quaternion q)$/;"	f
expectValidQuaternion	geometry/tf/test/tf_unittest.cpp	/^bool expectValidQuaternion(tf::Quaternion q)$/;"	f
expected_count_	geometry/tf/test/test_message_filter.cpp	/^	int expected_count_;$/;"	m	class:Notification	file:
extensions	geometry/tf/conf.py	/^extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.pngmath']$/;"	v
extensions	geometry/tf_conversions/conf.py	/^extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.pngmath']$/;"	v
extra	geometry/tf/test/testPython.py	/^            def extra(self):$/;"	m	class:TestPython.test_subclass.TransformerSubclass
f	openslam_gmapping/utils/movement.h	/^  double f;$/;"	m	class:GMapping::FSRMovement
failed_out_the_back_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t failed_out_the_back_count_;$/;"	m	class:tf::MessageFilter
failed_transform_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t failed_transform_count_;$/;"	m	class:tf::MessageFilter
failure	geometry/tf/test/test_message_filter.cpp	/^	void failure(const geometry_msgs::PointStamped::ConstPtr& message, FilterFailureReason reason)$/;"	f	class:Notification
failure_count_	geometry/tf/test/test_message_filter.cpp	/^	int failure_count_;$/;"	m	class:Notification	file:
failure_signal_	geometry/tf/include/tf/message_filter.h	/^  FailureSignal failure_signal_;$/;"	m	class:tf::MessageFilter
failure_signal_mutex_	geometry/tf/include/tf/message_filter.h	/^  boost::mutex failure_signal_mutex_;$/;"	m	class:tf::MessageFilter
fall_back_to_wall_time_	geometry/tf/include/tf/tf.h	/^  bool fall_back_to_wall_time_;$/;"	m	class:tf::Transformer
farthest	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	TFSIMD_FORCE_INLINE Quaternion farthest( const Quaternion& qd) const $/;"	f	class:tf::Quaternion
fastslamthread	openslam_gmapping/gui/gsp_thread.cpp	/^void * GridSlamProcessorThread::fastslamthread(GridSlamProcessorThread* gpt){$/;"	f	class:GridSlamProcessorThread
feedback_msg	common_msgs/actionlib_msgs/scripts/genaction.py	/^        feedback_msg = AUTOGEN + feedback$/;"	v
filename	openslam_gmapping/gui/gsp_thread.h	/^		std::string filename;$/;"	m	struct:GridSlamProcessorThread
filename_bufsize	openslam_gmapping/gui/qpixmapdumper.cpp	18;"	d	file:
fillImage	common_msgs/sensor_msgs/include/sensor_msgs/fill_image.h	/^  static inline bool fillImage(Image& image,$/;"	f	namespace:sensor_msgs
filter_failure_reasons	geometry/tf/include/tf/message_filter.h	/^namespace filter_failure_reasons$/;"	n	namespace:tf
finalize	geometry/tf/src/tf.cpp	/^  void finalize(WalkEnding end, ros::Time _time)$/;"	f	struct:CanTransformAccum
finalize	geometry/tf/src/tf.cpp	/^  void finalize(WalkEnding end, ros::Time _time)$/;"	f	struct:TransformAccum
findClosest	geometry/tf/src/cache.cpp	/^uint8_t TimeCache::findClosest(const TransformStorage*& one, const TransformStorage*& two, ros::Time target_time, std::string* error_str)$/;"	f	class:TimeCache
first	openslam_gmapping/grid/graphmap.cpp	/^	GraphMapPatch* first, *second;$/;"	m	struct:GMapping::GraphMapEdge	file:
flag	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      mutable bool flag;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
foreach	slam_gmapping/gmapping/src/slam_gmapping.cpp	124;"	d	file:
format	openslam_gmapping/gui/qpixmapdumper.h	/^	std::string format;	$/;"	m	struct:QPixmapDumper
forwardTransforms	geometry/tf/include/tf/tf.h	/^  std::vector<TransformStorage > forwardTransforms;$/;"	m	struct:tf::__anon5
frame	openslam_gmapping/gui/qpixmapdumper.h	/^	int frame;$/;"	m	struct:QPixmapDumper
frameExists	geometry/tf/src/tf.cpp	/^bool Transformer::frameExists(const std::string& frame_id_str) const$/;"	f	class:Transformer
frameExists	geometry/tf/src/tf/listener.py	/^    def frameExists(self, frame_id):$/;"	m	class:Transformer
frameTransformation	openslam_gmapping/utils/movement.cpp	/^OrientedPoint FSRMovement::frameTransformation(const OrientedPoint& reference_pt_frame1, $/;"	f	class:GMapping::FSRMovement
frame_authority_map	geometry/tf/src/tf_monitor.cpp	/^  std::map<std::string, std::string> frame_authority_map;$/;"	m	class:TFMonitor	file:
frame_id_	geometry/tf/include/tf/time_cache.h	/^  CompactFrameID frame_id_;$/;"	m	class:tf::TransformStorage
frame_id_	geometry/tf/include/tf/transform_datatypes.h	/^  std::string frame_id_; \/\/\/< The frame_id associated this data$/;"	m	class:tf::Stamped
frame_id_	geometry/tf/include/tf/transform_datatypes.h	/^  std::string frame_id_; \/\/\/< The frame_id of the coordinate frame  in which this transform is defined$/;"	m	class:tf::StampedTransform
framea_	geometry/tf/src/tf_monitor.cpp	/^  std::string framea_, frameb_;$/;"	m	class:TFMonitor	file:
frameb_	geometry/tf/src/tf_monitor.cpp	/^  std::string framea_, frameb_;$/;"	m	class:TFMonitor	file:
fromCameraParams	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def fromCameraParams(cv, rvec, tvec):$/;"	f
fromMatrix	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def fromMatrix(m):$/;"	f
fromMsg	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def fromMsg(p):$/;"	f
fromTf	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def fromTf(tf):$/;"	f
fromTranslationRotation	geometry/tf/src/tf/listener.py	/^    def fromTranslationRotation(self, translation, rotation):$/;"	m	class:TransformerROS
full_cmd	geometry/tf/scripts/bullet_migration_sed.py	/^    full_cmd = cmd%locals()$/;"	v
furthestAxis	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int furthestAxis() const$/;"	f	class:tf::Vector3
fuzzyZero	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE bool fuzzyZero() const $/;"	f	class:tf::Vector3
g_height	slam_gmapping/gmapping/test/rtest.cpp	/^double g_res, g_width, g_height, g_min_free_ratio, g_max_free_ratio;$/;"	v
g_max_free_ratio	slam_gmapping/gmapping/test/rtest.cpp	/^double g_res, g_width, g_height, g_min_free_ratio, g_max_free_ratio;$/;"	v
g_min_free_ratio	slam_gmapping/gmapping/test/rtest.cpp	/^double g_res, g_width, g_height, g_min_free_ratio, g_max_free_ratio;$/;"	v
g_n	slam_gmapping/gmapping/test/rtest.cpp	/^ros::NodeHandle* g_n=NULL;$/;"	v
g_res	slam_gmapping/gmapping/test/rtest.cpp	/^double g_res, g_width, g_height, g_min_free_ratio, g_max_free_ratio;$/;"	v
g_width	slam_gmapping/gmapping/test/rtest.cpp	/^double g_res, g_width, g_height, g_min_free_ratio, g_max_free_ratio;$/;"	v
gather	geometry/tf/src/tf.cpp	/^  CompactFrameID gather(TimeCache* cache, ros::Time time, std::string* error_string)$/;"	f	struct:CanTransformAccum
gather	geometry/tf/src/tf.cpp	/^  CompactFrameID gather(TimeCache* cache, ros::Time time, std::string* error_string)$/;"	f	struct:TransformAccum
gauss	openslam_gmapping/utils/datasmoother.h	/^  double gauss(double x, double mean, double sigma) {$/;"	f	class:GMapping::DataSmoother
gaussianApproximation	openslam_gmapping/gridfastslam/motionmodel.cpp	/^Covariance3 MotionModel::gaussianApproximation(const OrientedPoint& pnew, const OrientedPoint& pold) const{$/;"	f	class:GMapping::MotionModel
gen_rand	geometry/tf_conversions/test/test_eigen_tf.cpp	/^double gen_rand(double min, double max)$/;"	f
gen_rand	geometry/tf_conversions/test/test_kdl_tf.cpp	/^double gen_rand(double min, double max)$/;"	f
generate	geometry/tf/scripts/view_frames	/^def generate(dot_graph):$/;"	f
generateMap	openslam_gmapping/gui/gsp_thread.h	/^		bool generateMap;$/;"	m	struct:GridSlamProcessorThread
generateRandomPointPairs	openslam_gmapping/scanmatcher/icptest.cpp	/^PointPairList generateRandomPointPairs(int size, OrientedPoint t, double noise=0.){$/;"	f
generate_rand_vectors	geometry/tf/test/tf_benchmark.cpp	/^void generate_rand_vectors(double scale, uint64_t runs, std::vector<double>& xvalues, std::vector<double>& yvalues, std::vector<double>&zvalues)$/;"	f
generate_rand_vectors	geometry/tf/test/tf_unittest.cpp	/^void generate_rand_vectors(double scale, uint64_t runs, std::vector<double>& xvalues, std::vector<double>& yvalues, std::vector<double>&zvalues)$/;"	f
generate_rand_vectors	geometry/tf/test/transform_listener_unittest.cpp	/^void generate_rand_vectors(double scale, uint64_t runs, std::vector<double>& xvalues, std::vector<double>& yvalues, std::vector<double>&zvalues)$/;"	f
get128	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE const vec_float4&	get128() const$/;"	f	class:tf::Vector3
getAcceleration	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline const OrientedPoint& getAcceleration() const {return m_acceleration;}$/;"	f	class:GMapping::OdometryReading
getActiveArea	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		const PointSet& getActiveArea() const {return m_activeArea; }$/;"	f	class:GMapping::HierarchicalArray2D
getAngle	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar getAngle() const $/;"	f	class:tf::Quaternion
getAngleShortestPath	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar getAngleShortestPath() const $/;"	f	class:tf::Quaternion
getAutoscale	openslam_gmapping/gui/qgraphpainter.cpp	/^bool QGraphPainter::getAutoscale() const {$/;"	f	class:QGraphPainter
getAxis	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Vector3 getAxis() const$/;"	f	class:tf::Quaternion
getBasis	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Matrix3x3&       getBasis()          { return m_basis; }$/;"	f	class:tf::Transform
getBasis	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE const Matrix3x3& getBasis()    const { return m_basis; }$/;"	f	class:tf::Transform
getBestIdx	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	unsigned int getBestIdx() const {$/;"	f	struct:RecordList
getBestIdx	openslam_gmapping/gridfastslam/gfsreader.cpp	/^unsigned int RecordList::getBestIdx() const {$/;"	f	class:GMapping::GFSReader::RecordList
getBestParticleIndex	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  int GridSlamProcessor::getBestParticleIndex() const{$/;"	f	class:GMapping::GridSlamProcessor
getCacheLength	geometry/tf/include/tf/tf.h	/^  ros::Duration getCacheLength() { return tf2_buffer_.getCacheLength();}$/;"	f	class:tf::Transformer
getCenter	openslam_gmapping/include/gmapping/grid/map.h	/^		inline Point getCenter() const {return m_center;}	$/;"	f	class:GMapping::Map
getColumn	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE Vector3 getColumn(int i) const$/;"	f	class:tf::Matrix3x3
getData	geometry/tf/src/cache.cpp	/^bool TimeCache::getData(ros::Time time, TransformStorage & data_out, std::string* error_str) \/\/returns false if data not available$/;"	f	class:TimeCache
getDelta	openslam_gmapping/include/gmapping/grid/map.h	/^		inline double getDelta() const { return m_delta;}$/;"	f	class:GMapping::Map
getEulerYPR	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void getEulerYPR(tfScalar& yaw, tfScalar& pitch, tfScalar& roll, unsigned int solution_number = 1) const$/;"	f	class:tf::Matrix3x3
getEulerZYX	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	__attribute__((deprecated)) void getEulerZYX(tfScalar& yaw, tfScalar& pitch, tfScalar& roll, unsigned int solution_number = 1) const$/;"	f	class:tf::Matrix3x3
getEvents	openslam_gmapping/gui/gsp_thread.cpp	/^GridSlamProcessorThread::EventDeque GridSlamProcessorThread::getEvents(){$/;"	f	class:GridSlamProcessorThread
getFramePairs	geometry/tf/src/change_notifier.cpp	/^bool getFramePairs(const ros::NodeHandle& local_node, std::vector<FramePair>& frame_pairs, double default_translational_update_distance, double default_angular_update_distance)$/;"	f
getFrameStrings	geometry/tf/src/tf.cpp	/^void Transformer::getFrameStrings(std::vector<std::string> & vec) const$/;"	f	class:Transformer
getFrameStrings	geometry/tf/src/tf/listener.py	/^    def getFrameStrings(self):$/;"	m	class:Transformer
getFrames	geometry/tf/include/tf/transform_listener.h	/^  bool getFrames(tf::FrameGraph::Request&, tf::FrameGraph::Response& res)$/;"	f	class:tf::TransformListener
getHypotheses	openslam_gmapping/gui/gsp_thread.cpp	/^std::vector<OrientedPoint> GridSlamProcessorThread::getHypotheses(){$/;"	f	class:GridSlamProcessorThread
getIdentity	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	static const Matrix3x3&	getIdentity()$/;"	f	class:tf::Matrix3x3
getIdentity	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	static const Quaternion&	getIdentity()$/;"	f	class:tf::Quaternion
getIdentity	geometry/tf/include/tf/LinearMath/Transform.h	/^	static const Transform&	getIdentity()$/;"	f	class:tf::Transform
getIndexes	openslam_gmapping/gui/gsp_thread.cpp	/^std::vector<unsigned int> GridSlamProcessorThread::getIndexes(){$/;"	f	class:GridSlamProcessorThread
getIndexes	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    inline const std::vector<unsigned int>& getIndexes() const{return m_indexes; }$/;"	f	class:GMapping::GridSlamProcessor
getLatestCommonTime	geometry/tf/src/tf.cpp	/^int Transformer::getLatestCommonTime(const std::string &source_frame, const std::string &target_frame, ros::Time& time, std::string* error_string) const$/;"	f	class:Transformer
getLatestCommonTime	geometry/tf/src/tf/listener.py	/^    def getLatestCommonTime(self, source_frame, dest_frame):$/;"	m	class:Transformer
getLatestTimeAndParent	geometry/tf/src/cache.cpp	/^P_TimeAndFrameID TimeCache::getLatestTimeAndParent()$/;"	f	class:TimeCache
getLatestTimestamp	geometry/tf/src/cache.cpp	/^ros::Time TimeCache::getLatestTimestamp()$/;"	f	class:TimeCache
getListLength	geometry/tf/src/cache.cpp	/^unsigned int TimeCache::getListLength()$/;"	f	class:TimeCache
getLogWeight	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	double getLogWeight(unsigned int i) const{$/;"	f	struct:RecordList
getLogWeight	openslam_gmapping/gridfastslam/gfsreader.cpp	/^double RecordList::getLogWeight(unsigned int i) const{$/;"	f	class:GMapping::GFSReader::RecordList
getLogWeight	openslam_gmapping/gridfastslam/gfsreader.cpp	/^double RecordList::getLogWeight(unsigned int i, RecordList::const_iterator frame) const{$/;"	f	class:GMapping::GFSReader::RecordList
getMap	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		inline const ScanMatcherMap& getMap() const {return m_map;}$/;"	f	class:GMapping::ScanMatcherProcessor
getMapResolution	openslam_gmapping/include/gmapping/grid/map.h	/^		inline double getMapResolution() const { return m_delta;}$/;"	f	class:GMapping::Map
getMapSizeX	openslam_gmapping/include/gmapping/grid/map.h	/^		inline int getMapSizeX() const {return m_mapSizeX;}$/;"	f	class:GMapping::Map
getMapSizeY	openslam_gmapping/include/gmapping/grid/map.h	/^		inline int getMapSizeY() const {return m_mapSizeY;}$/;"	f	class:GMapping::Map
getName	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^		inline std::string getName() const {return m_name;}$/;"	f	class:GMapping::Sensor
getObjectType	geometry/tf/include/tf/LinearMath/Scalar.h	/^	inline int getObjectType() const$/;"	f	struct:tfTypedObject
getOdomPose	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::getOdomPose(GMapping::OrientedPoint& gmap_pose, const ros::Time& t)$/;"	f	class:SlamGMapping
getOldestTimestamp	geometry/tf/src/cache.cpp	/^ros::Time TimeCache::getOldestTimestamp()$/;"	f	class:TimeCache
getOpenGLMatrix	geometry/tf/include/tf/LinearMath/Transform.h	/^	void getOpenGLMatrix(tfScalar *m) const $/;"	f	class:tf::Transform
getOpenGLSubMatrix	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void getOpenGLSubMatrix(tfScalar *m) const $/;"	f	class:tf::Matrix3x3
getOrigin	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Vector3&         getOrigin()         { return m_origin; }$/;"	f	class:tf::Transform
getOrigin	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE const Vector3&   getOrigin()   const { return m_origin; }$/;"	f	class:tf::Transform
getParent	geometry/tf/src/cache.cpp	/^CompactFrameID TimeCache::getParent(ros::Time time, std::string* error_str)$/;"	f	class:TimeCache
getParent	geometry/tf/src/tf.cpp	/^bool Transformer::getParent(const std::string& frame_id, ros::Time time, std::string& parent) const$/;"	f	class:Transformer
getParticles	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    inline const ParticleVector& getParticles() const {return m_particles; }$/;"	f	class:GMapping::GridSlamProcessor
getPatchMagnitude	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline int getPatchMagnitude() const{return 0;}$/;"	f	class:GMapping::Array2D
getPatchMagnitude	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline int getPatchMagnitude() const {return m_patchMagnitude;}$/;"	f	class:GMapping::HierarchicalArray2D
getPatchSize	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline int getPatchSize() const{return 0;}$/;"	f	class:GMapping::Array2D
getPatchSize	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline int getPatchSize() const {return m_patchMagnitude;}$/;"	f	class:GMapping::HierarchicalArray2D
getPointCloud2FieldIndex	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud_conversion.h	/^static inline int getPointCloud2FieldIndex (const sensor_msgs::PointCloud2 &cloud, const std::string &field_name)$/;"	f	namespace:sensor_msgs
getPose	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline const OrientedPoint& getPose() const {return m_pose;}$/;"	f	class:GMapping::OdometryReading
getPose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	/^		inline const OrientedPoint& getPose() const {return m_pose;}$/;"	f	class:GMapping::RangeReading
getPose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		inline OrientedPoint getPose() const {return m_pose;}$/;"	f	class:GMapping::RangeSensor
getPose	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^OrientedPoint ScanMatcherProcessor::getPose() const{$/;"	f	class:GMapping::ScanMatcherProcessor
getPrefixParam	geometry/tf/include/tf/transform_listener.h	/^inline std::string getPrefixParam(ros::NodeHandle & nh) {$/;"	f	namespace:tf
getQueueSize	geometry/tf/include/tf/message_filter.h	/^  virtual uint32_t getQueueSize()$/;"	f	class:tf::MessageFilter
getRPY	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void getRPY(tfScalar& roll, tfScalar& pitch, tfScalar& yaw, unsigned int solution_number = 1) const$/;"	f	class:tf::Matrix3x3
getReading	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::getReading(RangeReading& reading){$/;"	f	class:CarmenWrapper
getResolution	openslam_gmapping/include/gmapping/grid/map.h	/^		inline double getResolution() const { return m_delta;}$/;"	f	class:GMapping::Map
getRotation	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void getRotation(Quaternion& q) const$/;"	f	class:tf::Matrix3x3
getRotation	geometry/tf/include/tf/LinearMath/Transform.h	/^	Quaternion getRotation() const { $/;"	f	class:tf::Transform
getRow	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE const Vector3& getRow(int i) const$/;"	f	class:tf::Matrix3x3
getSensor	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^		inline const Sensor* getSensor() const {return m_sensor;}$/;"	f	class:GMapping::SensorReading
getSensor	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^		inline const Sensor* getSensor() const {return m_sensor;}$/;"	f	class:GMapping::SensorReading
getSensorMap	openslam_gmapping/log/sensorstream.h	/^		inline const SensorMap& getSensorMap() const {return m_sensorMap; }$/;"	f	class:GMapping::SensorStream
getSize	openslam_gmapping/include/gmapping/grid/map.h	/^		inline void getSize(double & xmin, double& ymin, double& xmax, double& ymax) const {$/;"	f	class:GMapping::Map
getSkewSymmetricMatrix	geometry/tf/include/tf/LinearMath/Vector3.h	/^		void	getSkewSymmetricMatrix(Vector3* v0,Vector3* v1,Vector3* v2) const$/;"	f	class:tf::Vector3
getSpeed	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline const OrientedPoint& getSpeed() const {return m_speed;}$/;"	f	class:GMapping::OdometryReading
getTFPrefix	geometry/tf/include/tf/tf.h	/^  std::string getTFPrefix() const { return tf_prefix_;};$/;"	f	class:tf::Transformer
getTFPrefix	geometry/tf/src/tf/listener.py	/^    def getTFPrefix(self):$/;"	m	class:Transformer
getTargetFramesString	geometry/tf/include/tf/message_filter.h	/^  std::string getTargetFramesString()$/;"	f	class:tf::MessageFilter
getTime	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^		inline double getTime() const {return m_time;}$/;"	f	class:GMapping::SensorReading
getTime	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^		inline double getTime() const {return m_time;}$/;"	f	class:GMapping::SensorReading
getTrajectories	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^GridSlamProcessor::TNodeVector GridSlamProcessor::getTrajectories() const{$/;"	f	class:GMapping::GridSlamProcessor
getTruePos	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^OrientedPoint CarmenWrapper::getTruePos(){$/;"	f	class:CarmenWrapper
getW	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	TFSIMD_FORCE_INLINE const tfScalar& getW() const { return m_floats[3]; }$/;"	f	class:tf::Quaternion
getW	geometry/tf/include/tf/LinearMath/Vector3.h	/^	tfScalar	getW() const { return m_floats[3];}$/;"	f	class:tf::tfVector4
getWorldSizeX	openslam_gmapping/include/gmapping/grid/map.h	/^		inline double getWorldSizeX() const {return m_worldSizeX;}$/;"	f	class:GMapping::Map
getWorldSizeY	openslam_gmapping/include/gmapping/grid/map.h	/^		inline double getWorldSizeY() const {return m_worldSizeY;}$/;"	f	class:GMapping::Map
getX	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& getX() const { return m_floats[0]; }$/;"	f	class:tf::Vector3
getXSize	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline int getXSize() const {return m_xsize;}$/;"	f	class:GMapping::Array2D
getY	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& getY() const { return m_floats[1]; }$/;"	f	class:tf::Vector3
getYSize	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline int getYSize() const {return m_ysize;}$/;"	f	class:GMapping::Array2D
getYaw	geometry/tf/include/tf/transform_datatypes.h	/^static inline double getYaw(const Quaternion& bt_q){$/;"	f	namespace:tf
getYaw	geometry/tf/include/tf/transform_datatypes.h	/^static inline double getYaw(const geometry_msgs::Quaternion& msg_q){$/;"	f	namespace:tf
getZ	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& getZ() const { return m_floats[2]; }$/;"	f	class:tf::Vector3
getconstrain	geometry/tf/src/tf/transformations.py	/^    def getconstrain(self):$/;"	m	class:Arcball
gfs_thread	openslam_gmapping/gui/gsp_thread.h	/^		pthread_t gfs_thread;$/;"	m	struct:GridSlamProcessorThread
gfs_thread	openslam_gmapping/gui/qparticleviewer.h	/^		GridSlamProcessorThread* gfs_thread;$/;"	m	class:GMapping::QParticleViewer
gnuplotDumpData	openslam_gmapping/utils/datasmoother.h	/^  void gnuplotDumpData(FILE* fp) {$/;"	f	class:GMapping::DataSmoother
gnuplotDumpSmoothedData	openslam_gmapping/utils/datasmoother.h	/^  void gnuplotDumpSmoothedData(FILE* fp, double step) {$/;"	f	class:GMapping::DataSmoother
goHome	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool goHome;$/;"	m	class:QNavigatorWidget
goHome	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool goHome;$/;"	m	class:QSLAMandNavWidget
goal_msg	common_msgs/actionlib_msgs/scripts/genaction.py	/^        goal_msg = AUTOGEN + goal$/;"	v
got_first_scan_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    bool got_first_scan_;$/;"	m	class:SlamGMapping
got_map_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    bool got_map_;$/;"	m	class:SlamGMapping
got_map_	slam_gmapping/gmapping/test/rtest.cpp	/^    bool got_map_;$/;"	m	class:MapClientTest	file:
got_map_metadata_	slam_gmapping/gmapping/test/rtest.cpp	/^    bool got_map_metadata_;$/;"	m	class:MapClientTest	file:
gpainter	openslam_gmapping/gui/gfs_simplegui.cpp	/^  QGraphPainter* gpainter;$/;"	m	class:GFSMainWindow	file:
gradientDescent	openslam_gmapping/utils/optimizer.h	/^OrientedPoint Optimizer<Likelihood, Map>::gradientDescent(const RangeReading& oldReading, const RangeReading& newReading){$/;"	f	class:GMapping::Optimizer
gradientDescent	openslam_gmapping/utils/optimizer.h	/^OrientedPoint Optimizer<Likelihood, Map>::gradientDescent(const RangeReading& reading, const OrientedPoint& pose, OLocalMap& lmap){$/;"	f	class:GMapping::Optimizer
gridLine	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^void GridLineTraversal::gridLine( IntPoint start, IntPoint end, GridLineTraversalLine *line ) {$/;"	f	class:GMapping::GridLineTraversal
gridLineCore	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^void GridLineTraversal::gridLineCore( IntPoint start, IntPoint end, GridLineTraversalLine *line )$/;"	f	class:GMapping::GridLineTraversal
grow	openslam_gmapping/include/gmapping/grid/map.h	/^void Map<Cell,Storage,isClass>::grow(double xmin, double ymin, double xmax, double ymax){$/;"	f	class:GMapping::Map
gsp_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    GMapping::GridSlamProcessor* gsp_;$/;"	m	class:SlamGMapping
gsp_laser_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    GMapping::RangeSensor* gsp_laser_;$/;"	m	class:SlamGMapping
gsp_laser_beam_count_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    unsigned int gsp_laser_beam_count_;$/;"	m	class:SlamGMapping
gsp_odom_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    GMapping::OdometrySensor* gsp_odom_;$/;"	m	class:SlamGMapping
gsp_thread	openslam_gmapping/gui/gfs_simplegui.cpp	/^  GridSlamProcessorThread* gsp_thread;$/;"	m	class:GFSMainWindow	file:
gweight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double gweight;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
gweight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double gweight;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
hasAlpha	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline bool hasAlpha(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
help	openslam_gmapping/gui/gfs_simplegui.cpp	/^  QLabel* help;$/;"	m	class:GFSMainWindow	file:
hist_mutex	openslam_gmapping/gui/gsp_thread.h	/^		pthread_mutex_t hp_mutex, ind_mutex, hist_mutex;$/;"	m	struct:GridSlamProcessorThread
history	openslam_gmapping/gui/qparticleviewer.h	/^		GridSlamProcessorThread::EventDeque history;$/;"	m	class:GMapping::QParticleViewer
hp_mutex	openslam_gmapping/gui/gsp_thread.h	/^		pthread_mutex_t hp_mutex, ind_mutex, hist_mutex;$/;"	m	struct:GridSlamProcessorThread
html_static_path	geometry/tf/conf.py	/^html_static_path = ['_static']$/;"	v
html_static_path	geometry/tf_conversions/conf.py	/^html_static_path = ['_static']$/;"	v
html_theme	geometry/tf/conf.py	/^html_theme = 'default'$/;"	v
html_theme	geometry/tf_conversions/conf.py	/^html_theme = 'default'$/;"	v
htmlhelp_basename	geometry/tf/conf.py	/^htmlhelp_basename = 'tfdoc'$/;"	v
htmlhelp_basename	geometry/tf_conversions/conf.py	/^htmlhelp_basename = 'tfdoc'$/;"	v
hypot2	openslam_gmapping/scanmatcher/eig3.cpp	/^static double hypot2(double x, double y) {$/;"	f	file:
hypotheses	openslam_gmapping/gui/gsp_thread.h	/^			std::vector<OrientedPoint> hypotheses;$/;"	m	struct:GridSlamProcessorThread::ParticleMoveEvent
hypotheses	openslam_gmapping/gui/gsp_thread.h	/^		std::vector<OrientedPoint> hypotheses;$/;"	m	struct:GridSlamProcessorThread
icpNonlinearStep	openslam_gmapping/include/gmapping/scanmatcher/icp.h	/^double icpNonlinearStep(OrientedPoint & retval, const PointPairContainer& container){$/;"	f	namespace:GMapping
icpOptimize	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^double ScanMatcher::icpOptimize(OrientedPoint& pnew, const ScanMatcherMap& map, const OrientedPoint& init, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
icpStep	openslam_gmapping/include/gmapping/scanmatcher/icp.h	/^double icpStep(OrientedPoint & retval, const PointPairContainer& container){$/;"	f	namespace:GMapping
icpStep	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^inline double ScanMatcher::icpStep(OrientedPoint & pret, const ScanMatcherMap& map, const OrientedPoint& p, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
id	geometry/tf/src/tf.cpp	/^  CompactFrameID id;$/;"	m	struct:TimeAndFrameIDFrameComparator	file:
identity_matrix	geometry/tf/src/tf/transformations.py	/^def identity_matrix():$/;"	f
image_encodings	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^  namespace image_encodings$/;"	n	namespace:sensor_msgs
impl	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^namespace impl$/;"	n	namespace:sensor_msgs
impl	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^namespace impl$/;"	n	namespace:sensor_msgs
incomingMessage	geometry/tf/include/tf/message_filter.h	/^  void incomingMessage(const ros::MessageEvent<M const>& evt)$/;"	f	class:tf::MessageFilter
incoming_message_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t incoming_message_count_;$/;"	m	class:tf::MessageFilter
ind_mutex	openslam_gmapping/gui/gsp_thread.h	/^		pthread_mutex_t hp_mutex, ind_mutex, hist_mutex;$/;"	m	struct:GridSlamProcessorThread
index	openslam_gmapping/gui/gsp_thread.h	/^			unsigned int index;$/;"	m	struct:GridSlamProcessorThread::MapEvent
indexes	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	vector<unsigned int> indexes;$/;"	m	struct:ResampleRecord	file:
indexes	openslam_gmapping/gridfastslam/gfsreader.h	/^	vector<unsigned int> indexes;$/;"	m	struct:GMapping::GFSReader::ResampleRecord
indexes	openslam_gmapping/gui/gsp_thread.h	/^			std::vector<unsigned int> indexes;$/;"	m	struct:GridSlamProcessorThread::ResampleEvent
indexes	openslam_gmapping/gui/gsp_thread.h	/^		std::vector<unsigned int> indexes;$/;"	m	struct:GridSlamProcessorThread
infoStream	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  std::ostream& GridSlamProcessor::infoStream(){$/;"	f	class:GMapping::GridSlamProcessor
init	geometry/tf/include/tf/message_filter.h	/^  void init()$/;"	f	class:tf::MessageFilter
init	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::init(unsigned int size, double xmin, double ymin, double xmax, double ymax, double delta, OrientedPoint initialPose){$/;"	f	class:GMapping::GridSlamProcessor
init	openslam_gmapping/gui/gsp_thread.cpp	/^int GridSlamProcessorThread::init(int argc, const char * const * argv){$/;"	f	class:GridSlamProcessorThread
init	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^void ScanMatcherProcessor::init(){$/;"	f	class:GMapping::ScanMatcherProcessor
init	openslam_gmapping/utils/datasmoother.h	/^  void init(double parzenWindow) {$/;"	f	class:GMapping::DataSmoother
init	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^void SlamGMapping::init()$/;"	f	class:SlamGMapping
initMapper	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::initMapper(const sensor_msgs::LaserScan& scan)$/;"	f	class:SlamGMapping
initialPose	openslam_gmapping/gui/qparticleviewer.h	/^			OrientedPoint initialPose;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
initializeIPC	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::initializeIPC(const char* name) {$/;"	f	class:CarmenWrapper
input	openslam_gmapping/gui/gsp_thread.h	/^		InputSensorStream* input;$/;"	m	struct:GridSlamProcessorThread
inputStream	openslam_gmapping/gui/qparticleviewer.h	/^		ifstream inputStream;$/;"	m	class:GMapping::QParticleViewer
insertData	geometry/tf/src/cache.cpp	/^bool TimeCache::insertData(const TransformStorage& new_data)$/;"	f	class:TimeCache
integral	openslam_gmapping/utils/datasmoother.h	/^  double integral(double step, double xTo) {$/;"	f	class:GMapping::DataSmoother
integrate	openslam_gmapping/utils/datasmoother.h	/^  void integrate(double step) {$/;"	f	class:GMapping::DataSmoother
integrateScanSequence	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^void GridSlamProcessor::integrateScanSequence(GridSlamProcessor::TNode* node){$/;"	f	class:GMapping::GridSlamProcessor
interpolate	geometry/tf/src/cache.cpp	/^void TimeCache::interpolate(const TransformStorage& one, const TransformStorage& two, ros::Time time, TransformStorage& output)$/;"	f	class:TimeCache
interpolate	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> interpolate(const point<T>& p1,  const F& t1, const point<T>& p2, const F& t2, const F& t3){$/;"	f	namespace:GMapping
interpolate	openslam_gmapping/include/gmapping/utils/point.h	/^interpolate(const orientedpoint<T,A>& p1,  const F& t1, const orientedpoint<T,A>& p2, const F& t2, const F& t3){$/;"	f	namespace:GMapping
intersphinx_mapping	geometry/tf/conf.py	/^intersphinx_mapping = {$/;"	v
intersphinx_mapping	geometry/tf_conversions/conf.py	/^intersphinx_mapping = {$/;"	v
inv	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::inv() const {$/;"	f	class:GMapping::DMatrix
invXform	geometry/tf/include/tf/LinearMath/Transform.h	/^Transform::invXform(const Vector3& inVec) const$/;"	f	class:tf::Transform
invalidateActiveArea	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^void ScanMatcher::invalidateActiveArea(){$/;"	f	class:GMapping::ScanMatcher
invalidateActiveArea	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^void ScanMatcher::invalidateActiveArea(){$/;"	f	class:GMapping::ScanMatcher
inverse	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::inverse() const$/;"	f	class:tf::Matrix3x3
inverse	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion inverse() const$/;"	f	class:tf::Quaternion
inverse	geometry/tf/include/tf/LinearMath/Quaternion.h	/^inverse(const Quaternion& q) $/;"	f	namespace:tf
inverse	geometry/tf/include/tf/LinearMath/Transform.h	/^	Transform inverse() const$/;"	f	class:tf::Transform
inverseTimes	geometry/tf/include/tf/LinearMath/Transform.h	/^Transform::inverseTimes(const Transform& t) const  $/;"	f	class:tf::Transform
inverseTransforms	geometry/tf/include/tf/tf.h	/^  std::vector<TransformStorage > inverseTransforms;$/;"	m	struct:tf::__anon5
inverse_matrix	geometry/tf/src/tf/transformations.py	/^def inverse_matrix(matrix):$/;"	f
invert	openslam_gmapping/utils/movement.cpp	/^void FSRMovement::invert() {$/;"	f	class:GMapping::FSRMovement
invertMove	openslam_gmapping/utils/movement.cpp	/^FSRMovement FSRMovement::invertMove(const FSRMovement& move1) {$/;"	f	class:GMapping::FSRMovement
isAllocated	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline bool isAllocated(const IntPoint& p) const { return isAllocated(p.x,p.y);}$/;"	f	class:GMapping::HierarchicalArray2D
isAllocated	openslam_gmapping/include/gmapping/grid/harray2d.h	/^bool HierarchicalArray2D<Cell>::isAllocated(int x, int y) const{$/;"	f	class:GMapping::HierarchicalArray2D
isBayer	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline bool isBayer(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
isColor	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline bool isColor(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
isIdeal	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometrysensor.h	/^		inline bool isIdeal() const { return m_ideal; }$/;"	f	class:GMapping::OdometrySensor
isInside	openslam_gmapping/include/gmapping/grid/array2d.h	/^		inline bool isInside(const IntPoint& p) const { return isInside(p.x, p.y);}$/;"	f	class:GMapping::Array2D
isInside	openslam_gmapping/include/gmapping/grid/array2d.h	/^inline bool Array2D<Cell,debug>::isInside(int x, int y) const{$/;"	f	class:GMapping::Array2D
isInside	openslam_gmapping/include/gmapping/grid/map.h	/^		inline bool isInside(const IntPoint& p) const {$/;"	f	class:GMapping::Map
isInside	openslam_gmapping/include/gmapping/grid/map.h	/^		inline bool isInside(const Point& p) const {$/;"	f	class:GMapping::Map
isInside	openslam_gmapping/include/gmapping/grid/map.h	/^		inline bool isInside(double x, double y) const {$/;"	f	class:GMapping::Map
isInside	openslam_gmapping/include/gmapping/grid/map.h	/^		inline bool isInside(int x, int y) const {$/;"	f	class:GMapping::Map
isMono	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline bool isMono(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
isRunning	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::isRunning(){$/;"	f	class:CarmenWrapper
isRunning	openslam_gmapping/gui/gsp_thread.h	/^		inline bool isRunning() const {return running;}$/;"	f	struct:GridSlamProcessorThread
isStopped	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::isStopped(){$/;"	f	class:CarmenWrapper
isUsingDedicatedThread	geometry/tf/include/tf/tf.h	/^  bool isUsingDedicatedThread() { return tf2_buffer_.isUsingDedicatedThread();};$/;"	f	class:tf::Transformer
isZero	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE bool isZero() const $/;"	f	class:tf::Vector3
is_bigendian_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  bool is_bigendian_;$/;"	m	class:sensor_msgs::impl::PointCloud2IteratorBase
is_same_transform	geometry/tf/src/tf/transformations.py	/^def is_same_transform(matrix0, matrix1):$/;"	f
is_tf_active	geometry/tf/src/tf/tfwtf.py	/^def is_tf_active():$/;"	f
isnan	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.hxx	4;"	d
isnan	openslam_gmapping/include/gmapping/utils/gvalues.h	24;"	d
iterations	geometry/tf/scripts/python_benchmark.py	/^iterations = 10000$/;"	v
iterations	openslam_gmapping/gui/gsp_thread.h	/^		int iterations;$/;"	m	struct:GridSlamProcessorThread
iterations	openslam_gmapping/gui/qparticleviewer.h	/^			unsigned int iterations;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
iterations	openslam_gmapping/utils/optimizer.h	/^	int iterations;$/;"	m	struct:GMapping::OptimizerParams
iterations_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int iterations_;$/;"	m	class:SlamGMapping
kernelSize	openslam_gmapping/gui/gsp_thread.h	/^		int kernelSize;$/;"	m	struct:GridSlamProcessorThread
kernelSize_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int kernelSize_;$/;"	m	class:SlamGMapping
keyPressEvent	openslam_gmapping/gui/qnavigatorwidget.cpp	/^void QNavigatorWidget::keyPressEvent ( QKeyEvent * e ){$/;"	f	class:QNavigatorWidget
keyPressEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::keyPressEvent ( QKeyEvent* e ){$/;"	f	class:QParticleViewer
keyPressEvent	openslam_gmapping/gui/qslamandnavwidget.cpp	/^void QSLAMandNavWidget::keyPressEvent ( QKeyEvent * e ){$/;"	f	class:QSLAMandNavWidget
kldToGauss	openslam_gmapping/utils/datasmoother.h	/^  double kldToGauss(double step, double mean, double sigma) {$/;"	f	class:GMapping::DataSmoother
ksize	openslam_gmapping/gui/qparticleviewer.h	/^			unsigned int ksize;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
lasamplerange	openslam_gmapping/gui/gsp_thread.h	/^		double llsamplerange, lasamplerange;$/;"	m	struct:GridSlamProcessorThread
lasamplerange_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double lasamplerange_;$/;"	m	class:SlamGMapping
lasamplestep	openslam_gmapping/gui/gsp_thread.h	/^		double llsamplestep, lasamplestep;$/;"	m	struct:GridSlamProcessorThread
lasamplestep_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double lasamplestep_;$/;"	m	class:SlamGMapping
laserAngles	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		inline const double* laserAngles() const { return m_laserAngles; }$/;"	f	class:GMapping::ScanMatcher
laserBeams	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		inline unsigned int laserBeams() const { return m_laserBeams; }$/;"	f	class:GMapping::ScanMatcher
laserCallback	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::laserCallback(const sensor_msgs::LaserScan::ConstPtr& scan)$/;"	f	class:SlamGMapping
laser_angles_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    std::vector<double> laser_angles_;$/;"	m	class:SlamGMapping
laser_count_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int laser_count_;$/;"	m	class:SlamGMapping
laser_frame_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    std::string laser_frame_;$/;"	m	class:SlamGMapping
last_out_the_back_frame_	geometry/tf/include/tf/message_filter.h	/^  std::string last_out_the_back_frame_;$/;"	m	class:tf::MessageFilter
last_out_the_back_stamp_	geometry/tf/include/tf/message_filter.h	/^  ros::Time last_out_the_back_stamp_;$/;"	m	class:tf::MessageFilter
last_sent_pose_	geometry/tf/src/change_notifier.cpp	/^  tf::Stamped<tf::Pose> last_sent_pose_;$/;"	m	class:FramePair	file:
last_update_time_	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    double last_update_time_;$/;"	m	class:GMapping::GridSlamProcessor
latex_documents	geometry/tf/conf.py	/^latex_documents = [$/;"	v
latex_documents	geometry/tf_conversions/conf.py	/^latex_documents = [$/;"	v
layout	openslam_gmapping/gui/gfs_simplegui.cpp	/^  QVBoxLayout* layout;$/;"	m	class:GFSMainWindow	file:
length	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar length() const$/;"	f	class:tf::Quaternion
length	geometry/tf/include/tf/LinearMath/Quaternion.h	/^length(const Quaternion& q) $/;"	f	namespace:tf
length	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfScalar length() const$/;"	f	class:tf::Vector3
length2	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	tfScalar length2() const$/;"	f	class:tf::Quaternion
length2	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfScalar length2() const$/;"	f	class:tf::Vector3
lerp	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3 lerp(const Vector3& v, const tfScalar& t) const $/;"	f	class:tf::Vector3
lerp	geometry/tf/include/tf/LinearMath/Vector3.h	/^lerp(const Vector3& v1, const Vector3& v2, const tfScalar& t)$/;"	f	namespace:tf
lgain	openslam_gmapping/gui/qparticleviewer.h	/^			double lsigma, lgain;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
likelihood	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^	double likelihood;$/;"	m	struct:GMapping::ScoredMove	file:
likelihood	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^double ScanMatcher::likelihood$/;"	f	class:GMapping::ScanMatcher
likelihood	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^	double likelihood;$/;"	m	struct:GMapping::ScoredMove	file:
likelihood	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^double ScanMatcher::likelihood$/;"	f	class:GMapping::ScanMatcher
likelihood	openslam_gmapping/utils/optimizer.h	/^	Likelihood likelihood;$/;"	m	struct:GMapping::Optimizer
likelihoodAndScore	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^inline unsigned int ScanMatcher::likelihoodAndScore(double& s, double& l, const ScanMatcherMap& map, const OrientedPoint& p, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
likelyhood	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	double likelyhood(const Particle& p) const{$/;"	f	struct:LikelyhoodModel
likelyhood	openslam_gmapping/particlefilter/range_bearing.cpp	/^	double likelyhood(const Particle& p) const{$/;"	f	struct:LikelyhoodModel
likelyhoodModel	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^	LikelyhoodModel likelyhoodModel;$/;"	m	struct:auxiliary_evolver
likelyhoodModel	openslam_gmapping/particlefilter/particlefilter.cpp	/^	LikelyhoodModel likelyhoodModel;$/;"	m	struct:auxiliaryEvolver	file:
linearOdometryReliability	openslam_gmapping/gui/gsp_thread.h	/^		double linearOdometryReliability;$/;"	m	struct:GridSlamProcessorThread
linearStep	openslam_gmapping/utils/optimizer.h	/^	double angularStep, linearStep;$/;"	m	struct:GMapping::OptimizerParams
linearUpdate	openslam_gmapping/gui/gsp_thread.h	/^		double linearUpdate;$/;"	m	struct:GridSlamProcessorThread
linearUpdate	openslam_gmapping/gui/qparticleviewer.h	/^			double linearUpdate, angularUpdate;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
linearUpdate_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double linearUpdate_;$/;"	m	class:SlamGMapping
listen	geometry/tf/scripts/view_frames	/^def listen(duration):$/;"	f
ll	openslam_gmapping/utils/orientedboundingbox.h	/^  Point ll;$/;"	m	class:GMapping::OrientedBoundingBox
llsamplerange	openslam_gmapping/gui/gsp_thread.h	/^		double llsamplerange, lasamplerange;$/;"	m	struct:GridSlamProcessorThread
llsamplerange_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double llsamplerange_;$/;"	m	class:SlamGMapping
llsamplestep	openslam_gmapping/gui/gsp_thread.h	/^		double llsamplestep, lasamplestep;$/;"	m	struct:GridSlamProcessorThread
llsamplestep_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double llsamplestep_;$/;"	m	class:SlamGMapping
lmap	openslam_gmapping/utils/optimizer.h	/^	Map lmap;$/;"	m	struct:GMapping::Optimizer
load	openslam_gmapping/log/carmenconfiguration.cpp	/^istream& CarmenConfiguration::load(istream& is){$/;"	f	class:GMapping::CarmenConfiguration
load	openslam_gmapping/log/sensorlog.cpp	/^istream& SensorLog::load(istream& is){$/;"	f	class:GMapping::SensorLog
loadFile	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::loadFile(const char * fn){$/;"	f	class:QParticleViewer
loadFiles	openslam_gmapping/gui/gsp_thread.cpp	/^int GridSlamProcessorThread::loadFiles(const char * fn){$/;"	f	class:GridSlamProcessorThread
lock	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::lock(){$/;"	f	class:CarmenWrapper
lookupTransform	geometry/tf/src/tf.cpp	/^void Transformer::lookupTransform(const std::string& target_frame, const std::string& source_frame,$/;"	f	class:Transformer
lookupTransform	geometry/tf/src/tf.cpp	/^void Transformer::lookupTransform(const std::string& target_frame,const ros::Time& target_time, const std::string& source_frame,$/;"	f	class:Transformer
lookupTransform	geometry/tf/src/tf/listener.py	/^    def lookupTransform(self, target_frame, source_frame, time):$/;"	m	class:Transformer
lookupTransformFull	geometry/tf/src/tf/listener.py	/^    def lookupTransformFull(self, target_frame, target_time, source_frame, source_time, fixed_frame):$/;"	m	class:Transformer
lookupTwist	geometry/tf/src/tf.cpp	/^void Transformer::lookupTwist(const std::string& tracking_frame, const std::string& observation_frame, const std::string& reference_frame,$/;"	f	class:Transformer
lookupTwist	geometry/tf/src/tf.cpp	/^void Transformer::lookupTwist(const std::string& tracking_frame, const std::string& observation_frame,$/;"	f	class:Transformer
lookupTwist	geometry/tf/src/tf/listener.py	/^    def lookupTwist(self, tracking_frame, observation_frame, time, averaging_interval):$/;"	m	class:Transformer
lookupTwistFull	geometry/tf/src/tf/listener.py	/^    def lookupTwistFull(self, tracking_frame, observation_frame, reference_frame, ref_point, reference_point_frame, time, averaging_interval):$/;"	m	class:Transformer
lps	geometry/tf/test/python_debug_test.py	/^    lps = tf.PoseStamped()$/;"	v
lr	openslam_gmapping/utils/orientedboundingbox.h	/^  Point lr;  $/;"	m	class:GMapping::OrientedBoundingBox
lsigma	openslam_gmapping/gui/gsp_thread.h	/^		double lsigma;$/;"	m	struct:GridSlamProcessorThread
lsigma	openslam_gmapping/gui/qparticleviewer.h	/^			double lsigma, lgain;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
lsigma_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double lsigma_;$/;"	m	class:SlamGMapping
lskip	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int lskip;$/;"	m	struct:GridSlamProcessorThread
lskip	openslam_gmapping/gui/qparticleviewer.h	/^			unsigned int lskip;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
lskip_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int lskip_;$/;"	m	class:SlamGMapping
lstep	openslam_gmapping/gui/gsp_thread.h	/^		double lstep;$/;"	m	struct:GridSlamProcessorThread
lstep	openslam_gmapping/gui/qparticleviewer.h	/^			double lstep, astep;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
lstep_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double lstep_;$/;"	m	class:SlamGMapping
m2	geometry/tf/scripts/python_benchmark.py	/^    m2 = t()$/;"	v	class:Timer
m2	geometry/tf/scripts/python_benchmark.py	/^    m2 = tfMessage()$/;"	v
m_acceleration	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		OrientedPoint m_acceleration;$/;"	m	class:GMapping::OdometryReading
m_activeArea	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		PointSet m_activeArea;$/;"	m	class:GMapping::HierarchicalArray2D
m_activeAreaComputed	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		bool m_activeAreaComputed;$/;"	m	class:GMapping::ScanMatcher
m_angularDistance	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    double m_linearDistance, m_angularDistance;$/;"	m	class:GMapping::GridSlamProcessor
m_argc	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int m_argc;$/;"	m	struct:GridSlamProcessorThread
m_argv	openslam_gmapping/gui/gsp_thread.h	/^		const char* const * m_argv;$/;"	m	struct:GridSlamProcessorThread
m_basis	geometry/tf/include/tf/LinearMath/Transform.h	/^	Matrix3x3 m_basis;$/;"	m	class:tf::Transform
m_basis	geometry/tf/include/tf/LinearMath/Transform.h	/^	Matrix3x3DoubleData	m_basis;$/;"	m	struct:tf::TransformDoubleData
m_basis	geometry/tf/include/tf/LinearMath/Transform.h	/^	Matrix3x3FloatData	m_basis;$/;"	m	struct:tf::TransformFloatData
m_beams	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    unsigned int m_beams;$/;"	m	class:GMapping::GridSlamProcessor
m_beams	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		std::vector<Beam> m_beams;$/;"	m	class:GMapping::RangeSensor
m_beams	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		unsigned int m_beams;$/;"	m	class:GMapping::ScanMatcherProcessor
m_cells	openslam_gmapping/include/gmapping/grid/array2d.h	/^		Cell ** m_cells;$/;"	m	class:GMapping::Array2D
m_center	openslam_gmapping/include/gmapping/grid/map.h	/^		Point m_center;$/;"	m	class:GMapping::Map
m_computeCovariance	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		bool m_computeCovariance;$/;"	m	class:GMapping::ScanMatcherProcessor
m_count	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    int  m_count, m_readingCount;$/;"	m	class:GMapping::GridSlamProcessor
m_count	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		int  m_count;$/;"	m	class:GMapping::ScanMatcherProcessor
m_critScore	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		double m_regScore, m_critScore;$/;"	m	class:GMapping::ScanMatcherProcessor
m_cummulated	openslam_gmapping/utils/datasmoother.h	/^  std::vector<double> m_cummulated;$/;"	m	class:GMapping::DataSmoother
m_cursor	openslam_gmapping/log/sensorstream.h	/^		SensorLog::const_iterator m_cursor;$/;"	m	class:GMapping::LogSensorStream
m_data	openslam_gmapping/utils/datasmoother.h	/^  Data m_data;$/;"	m	class:GMapping::DataSmoother
m_delta	openslam_gmapping/include/gmapping/grid/map.h	/^		double m_worldSizeX, m_worldSizeY, m_delta;$/;"	m	class:GMapping::Map
m_dequeSem	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^sem_t CarmenWrapper::m_dequeSem;  $/;"	m	class:CarmenWrapper	file:
m_dequeSem	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static sem_t m_dequeSem;$/;"	m	class:GMapping::CarmenWrapper
m_distanceThresholdCheck	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^const double m_distanceThresholdCheck = 20;$/;"	m	namespace:GMapping	file:
m_el	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Vector3 m_el[3];$/;"	m	class:tf::Matrix3x3
m_el	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Vector3DoubleData m_el[3];$/;"	m	struct:tf::Matrix3x3DoubleData
m_el	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Vector3FloatData m_el[3];$/;"	m	struct:tf::Matrix3x3FloatData
m_first	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		bool m_first;$/;"	m	class:GMapping::ScanMatcherProcessor
m_floats	geometry/tf/include/tf/LinearMath/Vector3.h	/^		tfScalar	m_floats[4];$/;"	m	class:tf::Vector3
m_floats	geometry/tf/include/tf/LinearMath/Vector3.h	/^	double	m_floats[4];$/;"	m	struct:tf::Vector3DoubleData
m_floats	geometry/tf/include/tf/LinearMath/Vector3.h	/^	float	m_floats[4];$/;"	m	struct:tf::Vector3FloatData
m_from	openslam_gmapping/utils/datasmoother.h	/^  double m_from;$/;"	m	class:GMapping::DataSmoother
m_frontLaser	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^RangeSensor* CarmenWrapper::m_frontLaser=0;$/;"	m	class:CarmenWrapper	file:
m_frontLaser	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static RangeSensor* m_frontLaser, *m_rearLaser;$/;"	m	class:GMapping::CarmenWrapper
m_ideal	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometrysensor.h	/^		bool m_ideal;	$/;"	m	class:GMapping::OdometrySensor
m_indexes	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    std::vector<unsigned int> m_indexes;$/;"	m	class:GMapping::GridSlamProcessor
m_infoStream	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    std::ostream& m_infoStream;$/;"	m	class:GMapping::GridSlamProcessor
m_inputStream	openslam_gmapping/log/sensorstream.h	/^		std::istream& m_inputStream;$/;"	m	class:GMapping::InputSensorStream
m_int	openslam_gmapping/utils/datasmoother.h	/^  double m_int;$/;"	m	class:GMapping::DataSmoother
m_laserAngles	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		double       m_laserAngles[LASER_MAXBEAMS];$/;"	m	class:GMapping::ScanMatcher
m_laserBeams	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		unsigned int m_laserBeams;$/;"	m	class:GMapping::ScanMatcher
m_lastPartPose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    OrientedPoint m_lastPartPose;$/;"	m	class:GMapping::GridSlamProcessor
m_lastStep	openslam_gmapping/utils/datasmoother.h	/^  double m_lastStep;$/;"	m	class:GMapping::DataSmoother
m_linePoints	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		IntPoint* m_linePoints;$/;"	m	class:GMapping::ScanMatcher
m_linearDistance	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    double m_linearDistance, m_angularDistance;$/;"	m	class:GMapping::GridSlamProcessor
m_lock	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^pthread_mutex_t CarmenWrapper::m_lock;  $/;"	m	class:CarmenWrapper	file:
m_lock	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static pthread_mutex_t m_mutex, m_lock;  $/;"	m	class:GMapping::CarmenWrapper
m_log	openslam_gmapping/log/sensorstream.h	/^		const SensorLog* m_log;$/;"	m	class:GMapping::LogSensorStream
m_map	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		ScanMatcherMap m_map;$/;"	m	class:GMapping::ScanMatcherProcessor
m_mapSizeX	openslam_gmapping/include/gmapping/grid/map.h	/^		int m_mapSizeX, m_mapSizeY;$/;"	m	class:GMapping::Map
m_mapSizeY	openslam_gmapping/include/gmapping/grid/map.h	/^		int m_mapSizeX, m_mapSizeY;$/;"	m	class:GMapping::Map
m_matcher	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    ScanMatcher m_matcher;$/;"	m	class:GMapping::GridSlamProcessor
m_matcher	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		ScanMatcher m_matcher;$/;"	m	class:GMapping::ScanMatcherProcessor
m_maxMove	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		double m_maxMove;$/;"	m	class:GMapping::ScanMatcherProcessor
m_motionModel	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    MotionModel m_motionModel;$/;"	m	class:GMapping::GridSlamProcessor
m_mutex	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^pthread_mutex_t CarmenWrapper::m_mutex;  $/;"	m	class:CarmenWrapper	file:
m_mutex	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static pthread_mutex_t m_mutex, m_lock;  $/;"	m	class:GMapping::CarmenWrapper
m_name	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^		std::string m_name;$/;"	m	class:GMapping::Sensor
m_newPose	openslam_gmapping/gui/qparticleviewer.h	/^		QParticleViewer::OrientedPointVector m_oldPose, m_newPose;$/;"	m	class:GMapping::QParticleViewer
m_objectType	geometry/tf/include/tf/LinearMath/Scalar.h	/^	int	m_objectType;$/;"	m	struct:tfTypedObject
m_odoPose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    OrientedPoint m_odoPose;$/;"	m	class:GMapping::GridSlamProcessor
m_odoPose	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		OrientedPoint m_odoPose;$/;"	m	class:GMapping::ScanMatcherProcessor
m_oldPose	openslam_gmapping/gui/qparticleviewer.h	/^		QParticleViewer::OrientedPointVector m_oldPose, m_newPose;$/;"	m	class:GMapping::QParticleViewer
m_origin	geometry/tf/include/tf/LinearMath/Transform.h	/^	Vector3   m_origin;$/;"	m	class:tf::Transform
m_origin	geometry/tf/include/tf/LinearMath/Transform.h	/^	Vector3DoubleData	m_origin;$/;"	m	struct:tf::TransformDoubleData
m_origin	geometry/tf/include/tf/LinearMath/Transform.h	/^	Vector3FloatData	m_origin;$/;"	m	struct:tf::TransformFloatData
m_outputStream	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    std::ofstream m_outputStream;$/;"	m	class:GMapping::GridSlamProcessor
m_particleSize	openslam_gmapping/gui/qparticleviewer.h	/^		unsigned int m_particleSize;$/;"	m	class:GMapping::QParticleViewer
m_particles	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    ParticleVector m_particles;$/;"	m	class:GMapping::GridSlamProcessor
m_parzenWindow	openslam_gmapping/utils/datasmoother.h	/^  double m_parzenWindow;$/;"	m	class:GMapping::DataSmoother
m_patchMagnitude	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		int m_patchMagnitude;$/;"	m	class:GMapping::HierarchicalArray2D
m_patchSize	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		int m_patchSize;$/;"	m	class:GMapping::HierarchicalArray2D
m_pixmap	openslam_gmapping/gui/qgraphpainter.h	/^		QPixmap * m_pixmap;$/;"	m	class:QGraphPainter
m_pixmap	openslam_gmapping/gui/qmappainter.h	/^		QPixmap * m_pixmap;$/;"	m	class:QMapPainter
m_pixmap	openslam_gmapping/gui/qparticleviewer.h	/^		QPixmap* m_pixmap;$/;"	m	class:GMapping::QParticleViewer
m_points	openslam_gmapping/grid/graphmap.cpp	/^	PointList m_points;$/;"	m	struct:GMapping::GraphMapPatch	file:
m_pose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    OrientedPoint m_pose;$/;"	m	class:GMapping::GridSlamProcessor
m_pose	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		OrientedPoint m_pose;$/;"	m	class:GMapping::OdometryReading
m_pose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	/^		OrientedPoint m_pose;$/;"	m	class:GMapping::RangeReading
m_pose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		OrientedPoint m_pose;$/;"	m	class:GMapping::RangeSensor
m_pose	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		OrientedPoint m_pose;$/;"	m	class:GMapping::ScanMatcherProcessor
m_rangeDeque	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^deque<RangeReading> CarmenWrapper::m_rangeDeque;$/;"	m	class:CarmenWrapper	file:
m_rangeDeque	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static std::deque<RangeReading> m_rangeDeque;$/;"	m	class:GMapping::CarmenWrapper
m_readingCount	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    int  m_count, m_readingCount;$/;"	m	class:GMapping::GridSlamProcessor
m_readingThread	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^pthread_t CarmenWrapper::m_readingThread;$/;"	m	class:CarmenWrapper	file:
m_readingThread	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static pthread_t m_readingThread;$/;"	m	class:GMapping::CarmenWrapper
m_reading_function	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void * CarmenWrapper::m_reading_function(void*){$/;"	f	class:CarmenWrapper
m_rearLaser	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^RangeSensor* CarmenWrapper::m_rearLaser=0;$/;"	m	class:CarmenWrapper	file:
m_rearLaser	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static RangeSensor* m_frontLaser, *m_rearLaser;$/;"	m	class:GMapping::CarmenWrapper
m_reference	openslam_gmapping/include/gmapping/utils/autoptr.h	/^		reference * m_reference;$/;"	m	class:GMapping::autoptr
m_refresh	openslam_gmapping/gui/qparticleviewer.h	/^		bool m_refresh;$/;"	m	class:GMapping::QParticleViewer
m_regScore	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		double m_regScore, m_critScore;$/;"	m	class:GMapping::ScanMatcherProcessor
m_sensor	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^		const Sensor* m_sensor;$/;"	m	class:GMapping::SensorReading
m_sensor	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^		const Sensor* m_sensor;$/;"	m	class:GMapping::SensorReading
m_sensorMap	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static SensorMap m_sensorMap;$/;"	m	class:GMapping::CarmenWrapper
m_sensorMap	openslam_gmapping/include/gmapping/log/sensorlog.h	/^		const SensorMap& m_sensorMap;$/;"	m	class:GMapping::SensorLog
m_sensorMap	openslam_gmapping/log/sensorstream.h	/^		const SensorMap& m_sensorMap;$/;"	m	class:GMapping::SensorStream
m_sensorMap	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		SensorMap m_sensorMap;$/;"	m	class:GMapping::ScanMatcherProcessor
m_sizeX2	openslam_gmapping/include/gmapping/grid/map.h	/^		int m_sizeX2, m_sizeY2;$/;"	m	class:GMapping::Map
m_sizeY2	openslam_gmapping/include/gmapping/grid/map.h	/^		int m_sizeX2, m_sizeY2;$/;"	m	class:GMapping::Map
m_speed	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		OrientedPoint m_speed;$/;"	m	class:GMapping::OdometryReading
m_storage	openslam_gmapping/include/gmapping/grid/map.h	/^		Storage m_storage;$/;"	m	class:GMapping::Map
m_threadRunning	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::m_threadRunning=false;$/;"	m	class:CarmenWrapper	file:
m_threadRunning	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static bool m_threadRunning;$/;"	m	class:GMapping::CarmenWrapper
m_time	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^		double m_time;$/;"	m	class:GMapping::SensorReading
m_time	openslam_gmapping/sensor/sensor_base/sensoreading.h	/^		double m_time;$/;"	m	class:GMapping::SensorReading
m_to	openslam_gmapping/utils/datasmoother.h	/^  double m_to;$/;"	m	class:GMapping::DataSmoother
m_truepos	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^OrientedPoint CarmenWrapper::m_truepos;$/;"	m	class:CarmenWrapper	file:
m_truepos	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static OrientedPoint m_truepos;$/;"	m	class:GMapping::CarmenWrapper
m_unknown	openslam_gmapping/include/gmapping/grid/map.h	/^	static const Cell m_unknown;$/;"	m	class:GMapping::Map
m_unknown	openslam_gmapping/include/gmapping/grid/map.h	/^  const Cell  Map<Cell,Storage,isClass>::m_unknown = Cell(-1);$/;"	m	class:GMapping::Map
m_useYReference	openslam_gmapping/gui/qgraphpainter.h	/^		bool m_useYReference;$/;"	m	class:QGraphPainter
m_weights	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    std::vector<double> m_weights;$/;"	m	class:GMapping::GridSlamProcessor
m_worldSizeX	openslam_gmapping/include/gmapping/grid/map.h	/^		double m_worldSizeX, m_worldSizeY, m_delta;$/;"	m	class:GMapping::Map
m_worldSizeY	openslam_gmapping/include/gmapping/grid/map.h	/^		double m_worldSizeX, m_worldSizeY, m_delta;$/;"	m	class:GMapping::Map
m_xsize	openslam_gmapping/include/gmapping/grid/array2d.h	/^		int m_xsize, m_ysize;$/;"	m	class:GMapping::Array2D
m_ysize	openslam_gmapping/include/gmapping/grid/array2d.h	/^		int m_xsize, m_ysize;$/;"	m	class:GMapping::Array2D
main	common_msgs/actionlib_msgs/scripts/genaction.py	/^def main():$/;"	f
main	common_msgs/sensor_msgs/test/main.cpp	/^int main(int argc, char** argv)$/;"	f
main	common_msgs/sensor_msgs/test/test_image_encodings.cpp	/^int main(int argc, char** argv)$/;"	f
main	geometry/tf/src/change_notifier.cpp	/^int main(int argc, char** argv)$/;"	f
main	geometry/tf/src/empty_listener.cpp	/^int main(int argc, char** argv)$/;"	f
main	geometry/tf/src/static_transform_publisher.cpp	/^int main(int argc, char ** argv)$/;"	f
main	geometry/tf/src/tf_echo.cpp	/^int main(int argc, char ** argv)$/;"	f
main	geometry/tf/src/tf_monitor.cpp	/^int main(int argc, char ** argv)$/;"	f
main	geometry/tf/test/cache_unittest.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/operator_overload.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/quaternion.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/speed_test.cpp	/^int main(int argc, char** argv)$/;"	f
main	geometry/tf/test/testBroadcaster.cpp	/^int main(int argc, char ** argv)$/;"	f
main	geometry/tf/test/testListener.cpp	/^int main(int argc, char ** argv)$/;"	f
main	geometry/tf/test/test_message_filter.cpp	/^int main(int argc, char** argv)$/;"	f
main	geometry/tf/test/test_transform_datatypes.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/tf_benchmark.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/tf_unittest.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/tf_unittest_future.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/transform_listener_unittest.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/transform_twist_test.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf/test/velocity_test.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf_conversions/test/test_eigen_tf.cpp	/^int main(int argc, char **argv){$/;"	f
main	geometry/tf_conversions/test/test_kdl_tf.cpp	/^int main(int argc, char **argv){$/;"	f
main	openslam_gmapping/gfs-carmen/gfs-carmen.cpp	/^int main(int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/grid/map_test.cpp	/^int main (int argc, char ** argv){$/;"	f
main	openslam_gmapping/gridfastslam/gfs2log.cpp	/^int main (int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/gridfastslam/gfs2neff.cpp	/^int main(int argc, char**argv){$/;"	f
main	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^int main (int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/gridfastslam/gfs2stat.cpp	/^int main(int argc, char ** argv){$/;"	f
main	openslam_gmapping/gui/gfs2img.cpp	/^int main(int argc, char** argv){$/;"	f
main	openslam_gmapping/gui/gfs_logplayer.cpp	/^int  main (int argc, char ** argv){$/;"	f
main	openslam_gmapping/gui/gfs_nogui.cpp	/^int  main (int argc, char ** argv){$/;"	f
main	openslam_gmapping/gui/gfs_simplegui.cpp	/^int  main (int argc, char ** argv){$/;"	f
main	openslam_gmapping/log/log_plot.cpp	/^int main(int argc, char ** argv){$/;"	f
main	openslam_gmapping/log/log_test.cpp	/^int main(int argc, char ** argv){$/;"	f
main	openslam_gmapping/log/rdk2carmen.cpp	/^int main(int argc, char ** argv){$/;"	f
main	openslam_gmapping/log/scanstudio2carmen.cpp	/^int  main (int argc, char** argv){$/;"	f
main	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^int main (unsigned int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/particlefilter/range_bearing.cpp	/^int main (unsigned int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/scanmatcher/icptest.cpp	/^int main(int argc, const char ** argv){$/;"	f
main	openslam_gmapping/scanmatcher/lumiles.h	/^int main(int argc, conat char ** argv){$/;"	f	namespace:GMapping
main	openslam_gmapping/scanmatcher/scanmatch_test.cpp	/^int main(int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/utils/autoptr_test.cpp	/^int main(int argc, const char * const * argv){$/;"	f
main	openslam_gmapping/utils/stat_test.cpp	/^int main(int argc, char**  argv){$/;"	f
main	slam_gmapping/gmapping/src/main.cpp	/^main(int argc, char** argv)$/;"	f
main	slam_gmapping/gmapping/src/replay.cpp	/^main(int argc, char** argv)$/;"	f
main	slam_gmapping/gmapping/test/rtest.cpp	/^int main(int argc, char **argv)$/;"	f
map	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      ScanMatcherMap map;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
map2pic	openslam_gmapping/gui/qparticleviewer.h	/^		inline IntPoint map2pic(const Point& p)$/;"	f	class:GMapping::QParticleViewer
map2world	openslam_gmapping/include/gmapping/grid/map.h	/^		inline Point map2world(int x, int y) const $/;"	f	class:GMapping::Map
map2world	openslam_gmapping/include/gmapping/grid/map.h	/^Point Map<Cell,Storage,isClass>::map2world(const IntPoint& p) const{$/;"	f	class:GMapping::Map
mapCallback	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::mapCallback(nav_msgs::GetMap::Request  &req,$/;"	f	class:SlamGMapping
mapCallback	slam_gmapping/gmapping/test/rtest.cpp	/^    void mapCallback(const boost::shared_ptr<nav_msgs::OccupancyGrid const>& map)$/;"	f	class:MapClientTest
mapEntropy	openslam_gmapping/gridfastslam/gfsreader.h	/^	double mapEntropy;$/;"	m	struct:GMapping::GFSReader::EntropyRecord
mapMetaDataCallback	slam_gmapping/gmapping/test/rtest.cpp	/^    void mapMetaDataCallback(const boost::shared_ptr<nav_msgs::MapMetaData const>& map_metadata)$/;"	f	class:MapClientTest
mapTimer	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int mapTimer;$/;"	m	struct:GridSlamProcessorThread
mapUpdateTime	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int mapUpdateTime;$/;"	m	struct:GridSlamProcessorThread
map_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    nav_msgs::GetMap::Response map_;$/;"	m	class:SlamGMapping
map_	slam_gmapping/gmapping/test/rtest.cpp	/^    boost::shared_ptr<nav_msgs::OccupancyGrid const> map_;$/;"	m	class:MapClientTest	file:
map_frame_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    std::string map_frame_;$/;"	m	class:SlamGMapping
map_lock_	geometry/tf/src/tf_monitor.cpp	/^  boost::mutex map_lock_;$/;"	m	class:TFMonitor	file:
map_metadata_	slam_gmapping/gmapping/test/rtest.cpp	/^    boost::shared_ptr<nav_msgs::MapMetaData const> map_metadata_;$/;"	m	class:MapClientTest	file:
map_mutex_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    boost::mutex map_mutex_;$/;"	m	class:SlamGMapping
map_to_odom_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    tf::Transform map_to_odom_;$/;"	m	class:SlamGMapping
map_to_odom_mutex_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    boost::mutex map_to_odom_mutex_;$/;"	m	class:SlamGMapping
map_update_interval_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::Duration map_update_interval_;$/;"	m	class:SlamGMapping
mapscale	openslam_gmapping/gui/qparticleviewer.h	/^		double mapscale;$/;"	m	class:GMapping::QParticleViewer
master_doc	geometry/tf/conf.py	/^master_doc = 'index'$/;"	v
master_doc	geometry/tf_conversions/conf.py	/^master_doc = 'index'$/;"	v
matcher	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		inline ScanMatcher& matcher() {return m_matcher;}$/;"	f	class:GMapping::ScanMatcherProcessor
matchingParameters	openslam_gmapping/gui/qparticleviewer.h	/^		MatchingParameters matchingParameters;$/;"	m	class:GMapping::QParticleViewer
matrix	geometry/tf/src/tf/transformations.py	/^    def matrix(self):$/;"	m	class:Arcball
matrixEigenToMsg	geometry/eigen_conversions/include/eigen_conversions/eigen_msg.h	/^void matrixEigenToMsg(const Eigen::MatrixBase<Derived> &e, std_msgs::Float64MultiArray &m)$/;"	f	namespace:tf
matrixEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void matrixEigenToTF(const Eigen::Matrix3d &e, tf::Matrix3x3 &t)$/;"	f	namespace:tf
matrixTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void matrixTFToEigen(const tf::Matrix3x3 &t, Eigen::Matrix3d &e)$/;"	f	namespace:tf
max	openslam_gmapping/gui/gfs2img.cpp	/^inline double max(double a, double b){$/;"	f
max	openslam_gmapping/gui/qgraphpainter.h	/^		double min, max, reference;$/;"	m	class:QGraphPainter
max	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> max(const point<T>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
maxAxis	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int maxAxis() const $/;"	f	class:tf::Vector3
maxAxis4	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE int maxAxis4() const$/;"	f	class:tf::tfVector4
maxMove	openslam_gmapping/gui/gsp_thread.h	/^		double maxMove;$/;"	m	struct:GridSlamProcessorThread
maxRange	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^			double maxRange;	\/\/maximum range of the sensor$/;"	m	struct:GMapping::RangeSensor::Beam
maxRange	openslam_gmapping/utils/optimizer.h	/^	double maxRange;$/;"	m	struct:GMapping::OptimizerParams
maxRange_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double maxRange_;$/;"	m	class:SlamGMapping
maxRateTimerCallback	geometry/tf/include/tf/message_filter.h	/^  void maxRateTimerCallback(const ros::TimerEvent&)$/;"	f	class:tf::MessageFilter
maxUrange	openslam_gmapping/gui/gsp_thread.h	/^		double maxUrange;$/;"	m	struct:GridSlamProcessorThread
maxUrange_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double maxUrange_;$/;"	m	class:SlamGMapping
max_rate_	geometry/tf/include/tf/message_filter.h	/^  ros::Duration max_rate_;$/;"	m	class:tf::MessageFilter
max_rate_timer_	geometry/tf/include/tf/message_filter.h	/^  ros::Timer max_rate_timer_;$/;"	m	class:tf::MessageFilter
max_storage_time_	geometry/tf/include/tf/time_cache.h	/^  ros::Duration max_storage_time_;$/;"	m	class:tf::TimeCache
maxrange	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	double maxrange = 0;$/;"	v
maxrange	openslam_gmapping/gui/gsp_thread.h	/^		double maxrange;$/;"	m	struct:GridSlamProcessorThread
maxrange	openslam_gmapping/gui/qparticleviewer.h	/^			double maxrange, urange;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
maxrange_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double maxrange_;$/;"	m	class:SlamGMapping
mean	geometry/tf/scripts/python_benchmark.py	/^    def mean(self, iterations = 1000000):$/;"	m	class:Timer
mean	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	inline Point mean() const {return 1.\/n*Point(acc.x, acc.y);}$/;"	f	struct:GMapping::PointAccumulator
mean	openslam_gmapping/include/gmapping/utils/stat.h	/^	OrientedPoint mean;$/;"	m	struct:GMapping::Gaussian3
message_	geometry/tf/src/tf_monitor.cpp	/^  tf::tfMessage message_;$/;"	m	class:TFMonitor	file:
message_connection_	geometry/tf/include/tf/message_filter.h	/^  message_filters::Connection message_connection_;$/;"	m	class:tf::MessageFilter
message_count_	geometry/tf/include/tf/message_filter.h	/^  uint32_t message_count_; \/\/\/< The number of messages in the list.  Used because messages_.size() has linear cost$/;"	m	class:tf::MessageFilter
messages_	geometry/tf/include/tf/message_filter.h	/^  L_Event messages_; \/\/\/< The message list$/;"	m	class:tf::MessageFilter
messages_mutex_	geometry/tf/include/tf/message_filter.h	/^  boost::mutex messages_mutex_; \/\/\/< The mutex used for locking message list operations$/;"	m	class:tf::MessageFilter
min	openslam_gmapping/gui/gfs2img.cpp	/^inline double min(double a, double b){$/;"	f
min	openslam_gmapping/gui/qgraphpainter.h	/^		double min, max, reference;$/;"	m	class:QGraphPainter
min	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> min(const point<T>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
minAxis	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int minAxis() const$/;"	f	class:tf::Vector3
minAxis4	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE int minAxis4() const$/;"	f	class:tf::tfVector4
minimum_score_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double minimum_score_;$/;"	m	class:SlamGMapping
mkm	geometry/tf/scripts/python_benchmark.py	/^def mkm():$/;"	f
mouseMoveEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::mouseMoveEvent ( QMouseEvent *event ){$/;"	f	class:QParticleViewer
mousePressEvent	openslam_gmapping/gui/qnavigatorwidget.cpp	/^void QNavigatorWidget::mousePressEvent ( QMouseEvent * e ){$/;"	f	class:QNavigatorWidget
mousePressEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::mousePressEvent ( QMouseEvent *event ){$/;"	f	class:QParticleViewer
mousePressEvent	openslam_gmapping/gui/qslamandnavwidget.cpp	/^void QSLAMandNavWidget::mousePressEvent ( QMouseEvent * e ){$/;"	f	class:QSLAMandNavWidget
mouseReleaseEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::mouseReleaseEvent ( QMouseEvent *event ){$/;"	f	class:QParticleViewer
move	openslam_gmapping/utils/movement.cpp	/^OrientedPoint FSRMovement::move(const OrientedPoint& pt) const {$/;"	f	class:GMapping::FSRMovement
moveBetweenPoints	openslam_gmapping/utils/movement.cpp	/^FSRMovement FSRMovement::moveBetweenPoints(const OrientedPoint& pt1, $/;"	f	class:GMapping::FSRMovement
movePoint	openslam_gmapping/utils/movement.cpp	/^OrientedPoint FSRMovement::movePoint(const OrientedPoint& pt, const FSRMovement& move1) {$/;"	f	class:GMapping::FSRMovement
mrows	openslam_gmapping/utils/dmatrix.h	/^		X ** mrows;$/;"	m	class:GMapping::DMatrix
mstr	geometry/tf/scripts/python_benchmark.py	/^mstr = deserel_to_string(tm)$/;"	v
mult	geometry/tf/include/tf/LinearMath/Transform.h	/^		TFSIMD_FORCE_INLINE void mult(const Transform& t1, const Transform& t2) {$/;"	f	class:tf::Transform
multiple_authority	geometry/tf/src/tf/tfwtf.py	/^def multiple_authority(ctx):$/;"	f
mytime	geometry/tf/test/method_test.py	/^    mytime = rospy.Time(10,20)$/;"	v
mytime	geometry/tf/test/python_debug_test.py	/^    mytime = rospy.Time(10,20)$/;"	v
n	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	int n, visits;$/;"	m	struct:GMapping::PointAccumulator
n	openslam_gmapping/scanmatcher/eig3.cpp	11;"	d	file:
namespaced_rules	geometry/tf/scripts/bullet_migration_sed.py	/^namespaced_rules = [ $/;"	v
navigator_go_handler	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper:: navigator_go_handler(MSG_INSTANCE msgRef, BYTE_ARRAY callData, void*) {$/;"	f	class:CarmenWrapper
navigator_stop_handler	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper:: navigator_stop_handler(MSG_INSTANCE msgRef, BYTE_ARRAY callData, void*) {$/;"	f	class:CarmenWrapper
ncols	openslam_gmapping/utils/dmatrix.h	/^		int nrows,ncols;$/;"	m	class:GMapping::DMatrix
nearest	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	TFSIMD_FORCE_INLINE Quaternion nearest( const Quaternion& qd) const $/;"	f	class:tf::Quaternion
neff	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	double neff;$/;"	m	struct:NeffRecord	file:
neff	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	bool neff=0;$/;"	v
neff	openslam_gmapping/gridfastslam/gfsreader.h	/^	double neff;$/;"	m	struct:GMapping::GFSReader::NeffRecord
neff	openslam_gmapping/gui/gsp_thread.h	/^			double neff;$/;"	m	struct:GridSlamProcessorThread::ParticleMoveEvent
neff	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^Numeric uniform_resampler<Particle,Numeric>::neff(const std::vector<Particle> & particles) const{$/;"	f	class:uniform_resampler
neff	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^double neff(const Iterator& begin, const Iterator& end){$/;"	f
neff	openslam_gmapping/particlefilter/pf.h	/^double neff(const Iterator& begin, const Iterator& end){$/;"	f
newFormat	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^		bool newFormat;$/;"	m	class:GMapping::RangeSensor
new_messages_	geometry/tf/include/tf/message_filter.h	/^  bool new_messages_; \/\/\/< Used to skip waiting on new_data_ if new messages have come in while calling back$/;"	m	class:tf::MessageFilter
new_transforms_	geometry/tf/include/tf/message_filter.h	/^  volatile bool new_transforms_; \/\/\/< Used to skip waiting on new_data_ if new transforms have come in while calling back or transforming data$/;"	m	class:tf::MessageFilter
next	geometry/tf/src/tf/transformations.py	/^    def next(self, acceleration=0.0):$/;"	m	class:Arcball
next_failure_warning_	geometry/tf/include/tf/message_filter.h	/^  ros::Time next_failure_warning_;$/;"	m	class:tf::MessageFilter
nh_	geometry/tf/include/tf/message_filter.h	/^  ros::NodeHandle nh_; \/\/\/< The node used to subscribe to the topic$/;"	m	class:tf::MessageFilter
no_msgs	geometry/tf/src/tf/tfwtf.py	/^def no_msgs(ctx):$/;"	f
node	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      TNode* node; $/;"	m	struct:GMapping::GridSlamProcessor::Particle
node_	geometry/tf/include/tf/transform_listener.h	/^  ros::NodeHandle node_;$/;"	m	class:tf::TransformListener
node_	geometry/tf/src/static_transform_publisher.cpp	/^  ros::NodeHandle node_;$/;"	m	class:TransformSender	file:
node_	geometry/tf/src/tf_monitor.cpp	/^  ros::NodeHandle node_;$/;"	m	class:TFMonitor	file:
node_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::NodeHandle node_;$/;"	m	class:SlamGMapping
normalize	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion& normalize() $/;"	f	class:tf::Quaternion
normalize	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& normalize() $/;"	f	class:tf::Vector3
normalize	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.hxx	/^inline void GridSlamProcessor::normalize(){$/;"	f	class:GridSlamProcessor
normalize	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void normalize(const Iterator& begin, const Iterator& end){$/;"	f
normalize	openslam_gmapping/include/gmapping/utils/point.h	/^void orientedpoint<T,A>::normalize() {$/;"	f	class:GMapping::orientedpoint
normalize	openslam_gmapping/utils/movement.cpp	/^void FSRMovement::normalize()$/;"	f	class:GMapping::FSRMovement
normalizeWeights	openslam_gmapping/particlefilter/pf.h	/^void normalizeWeights(WeightVector& weights, unsigned int size, double minWeight){$/;"	f
normalized	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion normalized() const $/;"	f	class:tf::Quaternion
normalized	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE Vector3 Vector3::normalized() const$/;"	f	class:tf::Vector3
not_normalized	geometry/tf/src/tf/tfwtf.py	/^def not_normalized(ctx):$/;"	f
notify	geometry/tf/test/test_message_filter.cpp	/^	void notify(const geometry_msgs::PointStamped::ConstPtr& message)$/;"	f	class:Notification
now	geometry/tf/include/tf/tf.h	/^  ros::Time now() const { $/;"	f	class:tf::Transformer
nrows	openslam_gmapping/utils/dmatrix.h	/^		int nrows,ncols;$/;"	m	class:GMapping::DMatrix
nullLikelihood	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^		static const double nullLikelihood;$/;"	m	class:GMapping::ScanMatcher
nullLikelihood	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^const double ScanMatcher::nullLikelihood=-.5;$/;"	m	class:GMapping::ScanMatcher	file:
nullLikelihood	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^const double ScanMatcher::nullLikelihood=-1.;$/;"	m	class:GMapping::ScanMatcher	file:
numChannels	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^    static inline int numChannels(const std::string& encoding)$/;"	f	namespace:sensor_msgs::image_encodings
num_points	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^  int     num_points;$/;"	m	struct:GMapping::__anon6
observations	openslam_gmapping/particlefilter/range_bearing.cpp	/^	std::vector<double> observations;$/;"	m	struct:LikelyhoodModel	file:
observerVector	openslam_gmapping/particlefilter/range_bearing.cpp	/^	std::vector<Point> observerVector;$/;"	m	struct:LikelyhoodModel	file:
occ_thresh_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double occ_thresh_; \/\/ occupancy threshhold$/;"	m	class:SlamGMapping
odom_frame_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    std::string odom_frame_;$/;"	m	class:SlamGMapping
ogain	openslam_gmapping/gui/gsp_thread.h	/^		double ogain;$/;"	m	struct:GridSlamProcessorThread
ogain_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double ogain_;$/;"	m	class:SlamGMapping
ok	geometry/tf/src/tf.cpp	/^bool Transformer::ok() const { return true; }$/;"	f	class:Transformer
ok	geometry/tf/src/transform_listener.cpp	/^bool TransformListener::ok() const { return ros::ok(); }$/;"	f	class:TransformListener
onInit	slam_gmapping/gmapping/src/nodelet.cpp	/^    virtual void onInit()$/;"	f	class:SlamGMappingNodelet
onLine	openslam_gmapping/gui/gsp_thread.h	/^		bool onLine;$/;"	m	struct:GridSlamProcessorThread
onOdometryUpdate	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::onOdometryUpdate(){}$/;"	f	class:GMapping::GridSlamProcessor
onOdometryUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::onOdometryUpdate(){$/;"	f	class:GridSlamProcessorThread
onResampleUpdate	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::onResampleUpdate(){}$/;"	f	class:GMapping::GridSlamProcessor
onResampleUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::onResampleUpdate(){$/;"	f	class:GridSlamProcessorThread
onScanmatchUpdate	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::onScanmatchUpdate(){}$/;"	f	class:GMapping::GridSlamProcessor
onScanmatchUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::onScanmatchUpdate(){$/;"	f	class:GridSlamProcessorThread
operator !=	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^bool PointCloud2IteratorBase<T, TT, U, C, V>::operator !=(const V<T>& iter) const$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator !=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE	bool	operator!=(const Vector3& other) const$/;"	f	class:tf::Vector3
operator ()	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Vector3 operator()(const Vector3& x) const$/;"	f	class:tf::Transform
operator ()	geometry/tf/src/tf.cpp	/^  bool operator()(const P_TimeAndFrameID& rhs) const$/;"	f	struct:TimeAndFrameIDFrameComparator
operator ()	openslam_gmapping/include/gmapping/utils/point.h	/^	bool operator ()(const point<T>& a, const point<T>& b) const {$/;"	f	struct:GMapping::pointcomparator
operator ()	openslam_gmapping/include/gmapping/utils/point.h	/^	bool operator ()(const point<T>& a, const point<T>& b) const {$/;"	f	struct:GMapping::pointradialcomparator
operator *	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^TT& PointCloud2IteratorBase<T, TT, U, C, V>::operator *() const$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator *	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^operator*(const Matrix3x3& m, const Vector3& v) $/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^operator*(const Matrix3x3& m1, const Matrix3x3& m2)$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^operator*(const Vector3& v, const Matrix3x3& m)$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	operator*(const tfScalar& s) const$/;"	f	class:tf::Quaternion
operator *	geometry/tf/include/tf/LinearMath/Quaternion.h	/^operator*(const Quaternion& q, const Vector3& w)$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Quaternion.h	/^operator*(const Quaternion& q1, const Quaternion& q2) {$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Quaternion.h	/^operator*(const Vector3& w, const Quaternion& q)$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Quaternion operator*(const Quaternion& q) const$/;"	f	class:tf::Transform
operator *	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Vector3 operator*(const Vector3& x) const$/;"	f	class:tf::Transform
operator *	geometry/tf/include/tf/LinearMath/Transform.h	/^Transform::operator*(const Transform& t) const$/;"	f	class:tf::Transform
operator *	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator*(const Vector3& v, const tfScalar& s)$/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator*(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
operator *	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator*(const tfScalar& s, const Vector3& v)$/;"	f	namespace:tf
operator *	openslam_gmapping/include/gmapping/utils/autoptr.h	/^X& autoptr<X>::operator*(){$/;"	f	class:GMapping::autoptr
operator *	openslam_gmapping/include/gmapping/utils/autoptr.h	/^const X& autoptr<X>::operator*() const{$/;"	f	class:GMapping::autoptr
operator *	openslam_gmapping/include/gmapping/utils/point.h	/^inline T operator * (const point<T>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
operator *	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> operator * (const T& v, const point<T>& p){$/;"	f	namespace:GMapping
operator *	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> operator * (const point<T>& p, const T& v){$/;"	f	namespace:GMapping
operator *	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> operator * (const T& v, const orientedpoint<T,A>& p){$/;"	f	namespace:GMapping
operator *	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> operator * (const orientedpoint<T,A>& p, const T& v){$/;"	f	namespace:GMapping
operator *	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::operator*(const DMatrix<X>& m) const {$/;"	f	class:GMapping::DMatrix
operator *	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::operator*(const X& e) const {$/;"	f	class:GMapping::DMatrix
operator *=	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::operator*=(const Matrix3x3& m)$/;"	f	class:tf::Matrix3x3
operator *=	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion& operator*=(const Quaternion& q)$/;"	f	class:tf::Quaternion
operator *=	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion& operator*=(const tfScalar& s)$/;"	f	class:tf::Quaternion
operator *=	geometry/tf/include/tf/LinearMath/Transform.h	/^	Transform& operator*=(const Transform& t) $/;"	f	class:tf::Transform
operator *=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& operator*=(const Vector3& v)$/;"	f	class:tf::Vector3
operator *=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& operator*=(const tfScalar& s)$/;"	f	class:tf::Vector3
operator +	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^V<T> PointCloud2IteratorBase<T, TT, U, C, V>::operator +(int i)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator +	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	operator+(const Quaternion& q2) const$/;"	f	class:tf::Quaternion
operator +	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator+(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
operator +	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> operator+(const point<T>& p1, const point<T>& p2){$/;"	f	namespace:GMapping
operator +	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> operator+(const orientedpoint<T,A>& p1, const orientedpoint<T,A>& p2){$/;"	f	namespace:GMapping
operator +	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::operator+(const DMatrix<X>& m) const {$/;"	f	class:GMapping::DMatrix
operator ++	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^V<T>& PointCloud2IteratorBase<T, TT, U, C, V>::operator ++()$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator +=	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^V<T>& PointCloud2IteratorBase<T, TT, U, C, V>::operator +=(int i)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator +=	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	TFSIMD_FORCE_INLINE	Quaternion& operator+=(const Quaternion& q)$/;"	f	class:tf::Quaternion
operator +=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& operator+=(const Vector3& v)$/;"	f	class:tf::Vector3
operator -	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	TFSIMD_FORCE_INLINE Quaternion operator-() const$/;"	f	class:tf::Quaternion
operator -	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	operator-(const Quaternion& q2) const$/;"	f	class:tf::Quaternion
operator -	geometry/tf/include/tf/LinearMath/Quaternion.h	/^operator-(const Quaternion& q)$/;"	f	namespace:tf
operator -	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator-(const Vector3& v)$/;"	f	namespace:tf
operator -	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator-(const Vector3& v1, const Vector3& v2)$/;"	f	namespace:tf
operator -	openslam_gmapping/include/gmapping/utils/point.h	/^inline point<T> operator - (const point<T> & p1, const point<T> & p2){$/;"	f	namespace:GMapping
operator -	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A> operator - (const orientedpoint<T,A> & p1, const orientedpoint<T,A> & p2){$/;"	f	namespace:GMapping
operator -	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::operator-(const DMatrix<X>& m) const {$/;"	f	class:GMapping::DMatrix
operator -=	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion& operator-=(const Quaternion& q) $/;"	f	class:tf::Quaternion
operator -=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& operator-=(const Vector3& v) $/;"	f	class:tf::Vector3
operator /	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion operator\/(const tfScalar& s) const$/;"	f	class:tf::Quaternion
operator /	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator\/(const Vector3& v, const tfScalar& s)$/;"	f	namespace:tf
operator /	geometry/tf/include/tf/LinearMath/Vector3.h	/^operator\/(const Vector3& v1, const Vector3& v2)$/;"	f	namespace:tf
operator /=	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion& operator\/=(const tfScalar& s) $/;"	f	class:tf::Quaternion
operator /=	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE Vector3& operator\/=(const tfScalar& s) $/;"	f	class:tf::Vector3
operator <	geometry/tf/include/tf/time_cache.h	/^  bool operator< (const TransformStorage &b) const$/;"	f	class:tf::TransformStorage
operator <<	openslam_gmapping/utils/dmatrix.h	/^template <class X> std::ostream& operator<<(std::ostream& os, const DMatrix<X> &m) {$/;"	f	namespace:GMapping
operator =	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^V<T>& PointCloud2IteratorBase<T, TT, U, C, V>::operator =(const V<T> &iter)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator =	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE Matrix3x3& operator=(const Matrix3x3& other)$/;"	f	class:tf::Matrix3x3
operator =	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE Transform& operator=(const Transform& other)$/;"	f	class:tf::Transform
operator =	geometry/tf/include/tf/time_cache.h	/^  TransformStorage& operator=(const TransformStorage& rhs)$/;"	f	class:tf::TransformStorage
operator =	openslam_gmapping/include/gmapping/grid/array2d.h	/^Array2D<Cell,debug> & Array2D<Cell,debug>::operator=(const Array2D<Cell,debug> & g){$/;"	f	class:GMapping::Array2D
operator =	openslam_gmapping/include/gmapping/grid/harray2d.h	/^HierarchicalArray2D<Cell>& HierarchicalArray2D<Cell>::operator=(const HierarchicalArray2D& hg){$/;"	f	class:GMapping::HierarchicalArray2D
operator =	openslam_gmapping/include/gmapping/utils/autoptr.h	/^autoptr<X>& autoptr<X>::operator=(const autoptr<X>& ap){$/;"	f	class:GMapping::autoptr
operator =	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X>& DMatrix<X>::operator=(const DMatrix& m) {$/;"	f	class:GMapping::DMatrix
operator ==	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE bool operator==(const Matrix3x3& m1, const Matrix3x3& m2)$/;"	f	namespace:tf
operator ==	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE bool operator==(const Transform& t1, const Transform& t2)$/;"	f	namespace:tf
operator ==	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE	bool	operator==(const Vector3& other) const$/;"	f	class:tf::Vector3
operator ==	geometry/tf/include/tf/transform_datatypes.h	/^bool operator==(const Stamped<T> &a, const Stamped<T> &b) {$/;"	f	namespace:tf
operator ==	geometry/tf/include/tf/transform_datatypes.h	/^static inline bool operator==(const StampedTransform &a, const StampedTransform &b) {$/;"	f	namespace:tf
operator >>	openslam_gmapping/log/sensorstream.cpp	/^SensorStream& InputSensorStream::operator >>(const SensorReading*& reading){$/;"	f	class:GMapping::InputSensorStream
operator >>	openslam_gmapping/log/sensorstream.cpp	/^SensorStream& LogSensorStream::operator >>(const SensorReading*& rd){$/;"	f	class:GMapping::LogSensorStream
operator OrientedPoint	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      inline operator OrientedPoint() const {return pose;}$/;"	f	struct:GMapping::GridSlamProcessor::Particle
operator []	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^TT& PointCloud2IteratorBase<T, TT, U, C, V>::operator [](size_t i) const$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
operator []	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE Vector3&  operator[](int i)$/;"	f	class:tf::Matrix3x3
operator []	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE const Vector3& operator[](int i) const$/;"	f	class:tf::Matrix3x3
operator []	openslam_gmapping/utils/dmatrix.h	/^		X * operator[](int i) {$/;"	f	class:GMapping::DMatrix
operator []	openslam_gmapping/utils/dmatrix.h	/^		const X * operator[](int i) const { return mrows[i]; }$/;"	f	class:GMapping::DMatrix
operator bool	openslam_gmapping/log/sensorstream.cpp	/^InputSensorStream::operator bool() const{$/;"	f	class:GMapping::InputSensorStream
operator bool	openslam_gmapping/log/sensorstream.cpp	/^LogSensorStream::operator bool() const{$/;"	f	class:GMapping::LogSensorStream
operator const tfScalar *	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE	operator const tfScalar *() const { return &m_floats[0]; }$/;"	f	class:tf::Vector3
operator double	openslam_gmapping/grid/graphmap.cpp	/^	inline operator double() const{$/;"	f	struct:GMapping::GraphMapEdge
operator double	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      inline operator double() const {return weight;}$/;"	f	struct:GMapping::GridSlamProcessor::Particle
operator double	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	inline operator double() const { return visits?(double)n*SIGHT_INC\/(double)visits:-1; }$/;"	f	struct:GMapping::PointAccumulator
operator double	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	inline operator double() const {return w;}$/;"	f	struct:Particle
operator double	openslam_gmapping/particlefilter/range_bearing.cpp	/^	operator double() const {return w; }$/;"	f	struct:Particle
operator int	openslam_gmapping/include/gmapping/utils/autoptr.h	/^autoptr<X>::operator int() const{$/;"	f	class:GMapping::autoptr
operator tfScalar *	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE	operator       tfScalar *()       { return &m_floats[0]; }$/;"	f	class:tf::Vector3
optimize	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^double ScanMatcher::optimize(OrientedPoint& _mean, ScanMatcher::CovarianceMatrix& _cov, const ScanMatcherMap& map, const OrientedPoint& init, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
optimize	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^double ScanMatcher::optimize(OrientedPoint& pnew, const ScanMatcherMap& map, const OrientedPoint& init, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
optimize	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^double ScanMatcher::optimize(OrientedPoint& _mean, ScanMatcher::CovarianceMatrix& _cov, const ScanMatcherMap& map, const OrientedPoint& init, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
optimize	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^double ScanMatcher::optimize(OrientedPoint& pnew, const ScanMatcherMap& map, const OrientedPoint& init, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
orientedpoint	openslam_gmapping/include/gmapping/utils/point.h	/^	inline orientedpoint(T x, T y, A _theta): point<T>(x,y), theta(_theta){}$/;"	f	struct:GMapping::orientedpoint
orientedpoint	openslam_gmapping/include/gmapping/utils/point.h	/^  inline orientedpoint() : point<T>(0,0), theta(0) {};$/;"	f	struct:GMapping::orientedpoint
orientedpoint	openslam_gmapping/include/gmapping/utils/point.h	/^orientedpoint<T,A>::orientedpoint(const point<T>& p){$/;"	f	class:GMapping::orientedpoint
orientedpoint	openslam_gmapping/include/gmapping/utils/point.h	/^struct orientedpoint: public point<T>{$/;"	s	namespace:GMapping
origin	openslam_gmapping/include/gmapping/utils/point.h	/^	point<T> origin;$/;"	m	struct:GMapping::pointradialcomparator
orthogonalization_matrix	geometry/tf/src/tf/transformations.py	/^def orthogonalization_matrix(lengths, angles):$/;"	f
other_transform	geometry/tf/test/method_test.py	/^    other_transform = bullet.Transform()$/;"	v
outFileName	openslam_gmapping/gui/qparticleviewer.h	/^			const char * outFileName;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
outfilename	openslam_gmapping/gui/gsp_thread.h	/^		std::string outfilename;$/;"	m	struct:GridSlamProcessorThread
output	geometry/tf/test/python_debug_test.py	/^    output = lps.stamp$/;"	v
output	geometry/tf/test/python_debug_test.py	/^    output = pointstamped.stamp$/;"	v
outputFrameInfo	geometry/tf/src/tf_monitor.cpp	/^  std::string outputFrameInfo(const std::map<std::string, std::vector<double> >::iterator& it, const std::string& frame_authority)$/;"	f	class:TFMonitor
outputStream	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  std::ofstream& GridSlamProcessor::outputStream(){$/;"	f	class:GMapping::GridSlamProcessor
outputStream	openslam_gmapping/gui/qparticleviewer.h	/^		ofstream outputStream;$/;"	m	class:GMapping::QParticleViewer
p	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	double p;$/;"	m	struct:Particle	file:
p	openslam_gmapping/particlefilter/range_bearing.cpp	/^	Point p;$/;"	m	struct:Particle	file:
package_dir	common_msgs/sensor_msgs/setup.py	/^    package_dir={'': 'src'}$/;"	v
package_dir	geometry/tf/setup.py	/^    package_dir={'': 'src'},$/;"	v
package_dir	geometry/tf_conversions/setup.py	/^    package_dir={'': 'src'},$/;"	v
packages	common_msgs/sensor_msgs/setup.py	/^    packages=['sensor_msgs'],$/;"	v
packages	geometry/tf/setup.py	/^    packages=['tf'],$/;"	v
packages	geometry/tf_conversions/setup.py	/^    packages=['tf_conversions'],$/;"	v
paintEvent	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::paintEvent ( QPaintEvent * ){$/;"	f	class:QGraphPainter
paintEvent	openslam_gmapping/gui/qmappainter.cpp	/^void QMapPainter::paintEvent ( QPaintEvent * ){$/;"	f	class:QMapPainter
paintEvent	openslam_gmapping/gui/qnavigatorwidget.cpp	/^void QNavigatorWidget::paintEvent ( QPaintEvent * ){$/;"	f	class:QNavigatorWidget
paintEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::paintEvent ( QPaintEvent *paintevent ){$/;"	f	class:QParticleViewer
paintEvent	openslam_gmapping/gui/qslamandnavwidget.cpp	/^void QSLAMandNavWidget::paintEvent ( QPaintEvent * ){$/;"	f	class:QSLAMandNavWidget
params	openslam_gmapping/utils/optimizer.h	/^	OptimizerParams params;$/;"	m	struct:GMapping::Optimizer
parent	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      TNode* parent;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
parseDouble	openslam_gmapping/include/gmapping/utils/commandline.h	44;"	d
parseDoubleSilent	openslam_gmapping/include/gmapping/utils/commandline.h	99;"	d
parseFlag	openslam_gmapping/include/gmapping/utils/commandline.h	28;"	d
parseFlagSilent	openslam_gmapping/include/gmapping/utils/commandline.h	85;"	d
parseInt	openslam_gmapping/include/gmapping/utils/commandline.h	52;"	d
parseIntSilent	openslam_gmapping/include/gmapping/utils/commandline.h	106;"	d
parseOdometry	openslam_gmapping/log/sensorlog.cpp	/^OdometryReading* SensorLog::parseOdometry(istream& is, const OdometrySensor* osen) const{$/;"	f	class:GMapping::SensorLog
parseOdometry	openslam_gmapping/log/sensorstream.cpp	/^OdometryReading* SensorStream::parseOdometry(std::istream& is, const OdometrySensor* osen ){$/;"	f	class:GMapping::SensorStream
parseRange	openslam_gmapping/log/sensorlog.cpp	/^RangeReading* SensorLog::parseRange(istream& is, const RangeSensor* rs) const{$/;"	f	class:GMapping::SensorLog
parseRange	openslam_gmapping/log/sensorstream.cpp	/^RangeReading* SensorStream::parseRange(std::istream& is, const RangeSensor* rs){$/;"	f	class:GMapping::SensorStream
parseReading	openslam_gmapping/log/sensorstream.cpp	/^SensorReading* SensorStream::parseReading(std::istream& is, const SensorMap& smap){$/;"	f	class:GMapping::SensorStream
parseString	openslam_gmapping/include/gmapping/utils/commandline.h	35;"	d
parseStringSilent	openslam_gmapping/include/gmapping/utils/commandline.h	91;"	d
parse_action_spec	common_msgs/actionlib_msgs/scripts/genaction.py	/^def parse_action_spec(text, package_context = ''):$/;"	f
parser	geometry/tf/scripts/view_frames	/^    parser = OptionParser(usage="usage: %prog [options]", prog='viewFrames.py')$/;"	v
part	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	bool part=0;$/;"	v
particles	openslam_gmapping/gui/gsp_thread.h	/^		int particles;$/;"	m	struct:GridSlamProcessorThread
particles	openslam_gmapping/gui/qparticleviewer.h	/^			unsigned int particles;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
particles_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int particles_;$/;"	m	class:SlamGMapping
patchIndexes	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		inline IntPoint patchIndexes(const IntPoint& p) const { return patchIndexes(p.x,p.y);}$/;"	f	class:GMapping::HierarchicalArray2D
patchIndexes	openslam_gmapping/include/gmapping/grid/harray2d.h	/^IntPoint HierarchicalArray2D<Cell>::patchIndexes(int x, int y) const{$/;"	f	class:GMapping::HierarchicalArray2D
period_	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    double period_;$/;"	m	class:GMapping::GridSlamProcessor
pf_ran_gaussian	openslam_gmapping/utils/stat.cpp	/^double pf_ran_gaussian(double sigma)$/;"	f	namespace:GMapping
pic2map	openslam_gmapping/gui/qparticleviewer.h	/^		inline Point pic2map(const IntPoint& p) $/;"	f	class:GMapping::QParticleViewer
place	geometry/tf/src/tf/transformations.py	/^    def place(self, center, radius):$/;"	m	class:Arcball
plainStream	openslam_gmapping/gui/gsp_thread.h	/^		std::ifstream plainStream;$/;"	m	struct:GridSlamProcessorThread
pmap	openslam_gmapping/gui/gsp_thread.h	/^			ScanMatcherMap* pmap;$/;"	m	struct:GridSlamProcessorThread::MapEvent
po	geometry/tf/test/python_debug_test.py	/^    po = tf.PointStamped()$/;"	v
po	geometry/tf/test/python_debug_test.py	/^    po = tf.PoseStamped()$/;"	v
po	geometry/tf/test/python_debug_test.py	/^    po = tf.QuaternionStamped()$/;"	v
po	geometry/tf/test/python_debug_test.py	/^    po = tf.VectorStamped()$/;"	v
po2	geometry/tf/test/python_debug_test.py	/^    po2 = []$/;"	v
po2	geometry/tf/test/python_debug_test.py	/^    po2 = tfl.transform_pose("\/map", po)$/;"	v
po2_copy	geometry/tf/test/python_debug_test.py	/^    po2_copy = []    $/;"	v
po2_copy	geometry/tf/test/python_debug_test.py	/^    po2_copy = tf.PoseStamped(po2)$/;"	v
po2_copy2	geometry/tf/test/python_debug_test.py	/^    po2_copy2 = tf.PoseStamped(po2)$/;"	v
po3	geometry/tf/test/python_debug_test.py	/^    po3 = tfl.transform_point("\/map", po)$/;"	v
po4	geometry/tf/test/python_debug_test.py	/^    po4 = tfl.transform_vector("\/map", po)$/;"	v
po5	geometry/tf/test/python_debug_test.py	/^    po5 = tfl.transform_quaternion("\/map", po)$/;"	v
point	openslam_gmapping/include/gmapping/utils/point.h	/^	inline point():x(0),y(0) {}$/;"	f	struct:GMapping::point
point	openslam_gmapping/include/gmapping/utils/point.h	/^	inline point(T _x, T _y):x(_x),y(_y){}$/;"	f	struct:GMapping::point
point	openslam_gmapping/include/gmapping/utils/point.h	/^struct point{$/;"	s	namespace:GMapping
point2carmen	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^carmen_point_t CarmenWrapper::point2carmen (const OrientedPoint& p){$/;"	f	class:CarmenWrapper
pointEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void pointEigenToMsg(const Eigen::Vector3d &e, geometry_msgs::Point &m)$/;"	f	namespace:tf
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::FLOAT32> { typedef float    type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::FLOAT64> { typedef double   type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT16>   { typedef int16_t  type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT32>   { typedef int32_t  type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT8>    { typedef int8_t   type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT16>  { typedef uint16_t type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT32>  { typedef uint32_t type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT8>   { typedef uint8_t  type; };$/;"	s	namespace:sensor_msgs
pointFieldTypeAsType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<int> struct pointFieldTypeAsType {};$/;"	s	namespace:sensor_msgs
pointKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void pointKDLToMsg(const KDL::Vector &k, geometry_msgs::Point &m)$/;"	f	namespace:tf
pointMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void pointMsgToEigen(const geometry_msgs::Point &m, Eigen::Vector3d &e)$/;"	f	namespace:tf
pointMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void pointMsgToKDL(const geometry_msgs::Point &m, KDL::Vector &k)$/;"	f	namespace:tf
pointMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void pointMsgToTF(const geometry_msgs::Point& msg_v, Point& bt_v) {bt_v = Vector3(msg_v.x, msg_v.y, msg_v.z);};$/;"	f	namespace:tf
pointStampedMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void pointStampedMsgToTF(const geometry_msgs::PointStamped & msg, Stamped<Point>& bt)$/;"	f	namespace:tf
pointStampedTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void pointStampedTFToMsg(const Stamped<Point>& bt, geometry_msgs::PointStamped & msg)$/;"	f	namespace:tf
pointTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void pointTFToMsg(const Point& bt_v, geometry_msgs::Point& msg_v) {msg_v.x = bt_v.x(); msg_v.y = bt_v.y(); msg_v.z = bt_v.z();};$/;"	f	namespace:tf
point_step_	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^  int point_step_;$/;"	m	class:sensor_msgs::impl::PointCloud2IteratorBase
pointcomparator	openslam_gmapping/include/gmapping/utils/point.h	/^struct pointcomparator{$/;"	s	namespace:GMapping
pointradialcomparator	openslam_gmapping/include/gmapping/utils/point.h	/^struct pointradialcomparator{$/;"	s	namespace:GMapping
points	openslam_gmapping/scanmatcher/gridlinetraversal.h	/^  IntPoint*  points;$/;"	m	struct:GMapping::__anon6
pointstamped	geometry/tf/test/python_debug_test.py	/^    pointstamped = tf.PointStamped()$/;"	v
poll	geometry/tf/scripts/view_frames	/^def poll(node_name):$/;"	f
pose	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	OrientedPoint pose;$/;"	m	struct:LaserRecord	file:
pose	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	OrientedPoint pose;$/;"	m	struct:PoseRecord	file:
pose	openslam_gmapping/gridfastslam/gfsreader.h	/^	OrientedPoint pose;$/;"	m	struct:GMapping::GFSReader::LaserRecord
pose	openslam_gmapping/gridfastslam/gfsreader.h	/^	OrientedPoint pose;$/;"	m	struct:GMapping::GFSReader::PoseRecord
pose	openslam_gmapping/gridfastslam/gfsreader.h	/^	OrientedPoint pose;$/;"	m	struct:GMapping::GFSReader::RawOdometryRecord
pose	openslam_gmapping/gui/gsp_thread.h	/^			OrientedPoint pose;$/;"	m	struct:GridSlamProcessorThread::MapEvent
pose	openslam_gmapping/gui/gsp_thread.h	/^			OrientedPoint pose;$/;"	m	struct:GridSlamProcessorThread::TruePosEvent
pose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      OrientedPoint pose; $/;"	m	struct:GMapping::GridSlamProcessor::TNode
pose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      OrientedPoint pose;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
pose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^			OrientedPoint pose;	\/\/pose relative to the center of the sensor$/;"	m	struct:GMapping::RangeSensor::Beam
pose	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^	OrientedPoint pose;$/;"	m	struct:GMapping::ScoredMove	file:
pose	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^	OrientedPoint pose;$/;"	m	struct:GMapping::ScoredMove	file:
poseEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void poseEigenToMsg(const Eigen::Affine3d &e, geometry_msgs::Pose &m)$/;"	f	namespace:tf
poseEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void poseEigenToMsg(const Eigen::Isometry3d &e, geometry_msgs::Pose &m)$/;"	f	namespace:tf
poseEigenToMsgImpl	geometry/eigen_conversions/src/eigen_msg.cpp	/^  void poseEigenToMsgImpl(const T &e, geometry_msgs::Pose &m)$/;"	f	namespace:tf::__anon2
poseEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void poseEigenToTF(const Eigen::Affine3d &e, tf::Pose &t)$/;"	f	namespace:tf
poseEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void poseEigenToTF(const Eigen::Isometry3d &e, tf::Pose &t)$/;"	f	namespace:tf
poseEntropy	openslam_gmapping/gridfastslam/gfsreader.h	/^	double poseEntropy;$/;"	m	struct:GMapping::GFSReader::EntropyRecord
poseKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void poseKDLToMsg(const KDL::Frame &k, geometry_msgs::Pose &m)$/;"	f	namespace:tf
poseKDLToTF	geometry/tf_conversions/src/tf_kdl.cpp	/^  void poseKDLToTF(const KDL::Frame& k, tf::Pose& t)$/;"	f	namespace:tf
poseMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void poseMsgToEigen(const geometry_msgs::Pose &m, Eigen::Affine3d &e)$/;"	f	namespace:tf
poseMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void poseMsgToEigen(const geometry_msgs::Pose &m, Eigen::Isometry3d &e)$/;"	f	namespace:tf
poseMsgToEigenImpl	geometry/eigen_conversions/src/eigen_msg.cpp	/^  void poseMsgToEigenImpl(const geometry_msgs::Pose &m, T &e)$/;"	f	namespace:tf::__anon2
poseMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void poseMsgToKDL(const geometry_msgs::Pose &m, KDL::Frame &k)$/;"	f	namespace:tf
poseMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void poseMsgToTF(const geometry_msgs::Pose& msg, Pose& bt)$/;"	f	namespace:tf
poseStampedMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void poseStampedMsgToTF(const geometry_msgs::PoseStamped & msg, Stamped<Pose>& bt)$/;"	f	namespace:tf
poseStampedTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void poseStampedTFToMsg(const Stamped<Pose>& bt, geometry_msgs::PoseStamped & msg)$/;"	f	namespace:tf
poseTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void poseTFToEigen(const tf::Pose &t, Eigen::Affine3d &e)$/;"	f	namespace:tf
poseTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void poseTFToEigen(const tf::Pose &t, Eigen::Isometry3d &e)$/;"	f	namespace:tf
poseTFToKDL	geometry/tf_conversions/src/tf_kdl.cpp	/^  void poseTFToKDL(const tf::Pose& t, KDL::Frame& k)$/;"	f	namespace:tf
poseTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void poseTFToMsg(const Pose& bt, geometry_msgs::Pose& msg)$/;"	f	namespace:tf
pose_in_	geometry/tf/src/change_notifier.cpp	/^  tf::Stamped<tf::Pose> pose_in_;$/;"	m	class:FramePair	file:
pose_only	geometry/tf/test/python_debug_test.py	/^    pose_only = []$/;"	v
pose_only	geometry/tf/test/python_debug_test.py	/^    pose_only = bullet.Transform(transform_stamped.transform)$/;"	v
pose_out_	geometry/tf/src/change_notifier.cpp	/^  tf::Stamped<tf::Pose> pose_out_;$/;"	m	class:FramePair	file:
poses	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	vector<OrientedPoint> poses;$/;"	m	struct:OdometryRecord	file:
poses	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	vector<OrientedPoint> poses;$/;"	m	struct:ScanMatchRecord	file:
poses	openslam_gmapping/gridfastslam/gfsreader.h	/^	vector<OrientedPoint> poses;$/;"	m	struct:GMapping::GFSReader::OdometryRecord
poses	openslam_gmapping/gridfastslam/gfsreader.h	/^	vector<OrientedPoint> poses;$/;"	m	struct:GMapping::GFSReader::ScanMatchRecord
prefix	openslam_gmapping/gui/qpixmapdumper.h	/^	std::string prefix;$/;"	m	struct:QPixmapDumper
previousIndex	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      int previousIndex;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
previousPose	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      OrientedPoint previousPose;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
printHelp	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool printHelp;$/;"	m	class:QSLAMandNavWidget
printLastParticles	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void RecordList::printLastParticles(ostream& os) const {$/;"	f	class:GMapping::GFSReader::RecordList
printParam	openslam_gmapping/gui/gsp_thread.cpp	340;"	d	file:
printParam	openslam_gmapping/gui/gsp_thread.cpp	392;"	d	file:
printParticles	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^ostream& printParticles(ostream& os, const vector<Particle>& p)$/;"	f
printParticles	openslam_gmapping/particlefilter/range_bearing.cpp	/^ostream& printParticles(ostream& os, const vector<Particle>& p)$/;"	f
printPath	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	void printPath(ostream& os, unsigned int i, bool err=false) const{$/;"	f	struct:RecordList
printPath	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void RecordList::printPath(ostream& os, unsigned int i, bool err, bool rawodom) const{$/;"	f	class:GMapping::GFSReader::RecordList
printmemusage	openslam_gmapping/utils/printmemusage.cpp	/^void printmemusage(){$/;"	f	namespace:GMapping
printpgm	openslam_gmapping/utils/printpgm.h	/^ostream& printpgm(ostream& os, int xsize, int ysize, const double * const * matrix){$/;"	f
private_nh_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::NodeHandle private_nh_;$/;"	m	class:SlamGMapping
processScan	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  bool GridSlamProcessor::processScan(const RangeReading & reading, int adaptParticles){$/;"	f	class:GMapping::GridSlamProcessor
processScan	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^void ScanMatcherProcessor::processScan(const RangeReading & reading){$/;"	f	class:GMapping::ScanMatcherProcessor
processTruePos	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::processTruePos(const OdometryReading& o){$/;"	f	class:GMapping::GridSlamProcessor
process_callback	geometry/tf/src/tf_monitor.cpp	/^  void process_callback(const tf::tfMessage& message, const std::string & authority, bool is_static)$/;"	f	class:TFMonitor
project	geometry/tf/conf.py	/^project = u'tf'$/;"	v
project	geometry/tf_conversions/conf.py	/^project = u'tf_conversions'$/;"	v
projection_from_matrix	geometry/tf/src/tf/transformations.py	/^def projection_from_matrix(matrix, pseudo=False):$/;"	f
projection_matrix	geometry/tf/src/tf/transformations.py	/^def projection_matrix(point, normal, direction=None,$/;"	f
propagateWeight	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^double propagateWeight(GridSlamProcessor::TNode* n, double weight){$/;"	f	namespace:GMapping
propagateWeights	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^double GridSlamProcessor::propagateWeights(){$/;"	f	class:GMapping::GridSlamProcessor
pruneList	geometry/tf/src/cache.cpp	/^void TimeCache::pruneList()$/;"	f	class:TimeCache
publishLoop	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^void SlamGMapping::publishLoop(double transform_publish_period){$/;"	f	class:SlamGMapping
publishTransform	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^void SlamGMapping::publishTransform()$/;"	f	class:SlamGMapping
publish_globalpos	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::publish_globalpos(carmen_localize_summary_p summary)$/;"	f	class:CarmenWrapper
publish_particles	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::publish_particles(carmen_localize_particle_filter_p filter, $/;"	f	class:CarmenWrapper
push_back_1	geometry/tf/test/tf_unittest.cpp	/^void push_back_1(std::vector<std::string>& children, std::vector<std::string>& parents,$/;"	f
push_back_i	geometry/tf/test/tf_unittest.cpp	/^void push_back_i(std::vector<std::string>& children, std::vector<std::string>& parents,$/;"	f
push_back_v	geometry/tf/test/tf_unittest.cpp	/^void push_back_v(std::vector<std::string>& children, std::vector<std::string>& parents,$/;"	f
push_back_y	geometry/tf/test/tf_unittest.cpp	/^void push_back_y(std::vector<std::string>& children, std::vector<std::string>& parents,$/;"	f
pviewer	openslam_gmapping/gui/gfs_simplegui.cpp	/^  QParticleViewer* pviewer;$/;"	m	class:GFSMainWindow	file:
pygments_style	geometry/tf/conf.py	/^pygments_style = 'sphinx'$/;"	v
pygments_style	geometry/tf_conversions/conf.py	/^pygments_style = 'sphinx'$/;"	v
qualificationModel	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^	QualificationModel qualificationModel;$/;"	m	struct:auxiliary_evolver
qualificationModel	openslam_gmapping/particlefilter/particlefilter.cpp	/^	QualificationModel qualificationModel;$/;"	m	struct:auxiliaryEvolver	file:
quat	geometry/tf/test/method_test.py	/^    quat = bullet.Quaternion(math.pi\/2,0,0)$/;"	v
quat	geometry/tf/test/python_debug_test.py	/^    quat = bullet.Quaternion(math.pi\/2,0,0)$/;"	v
quatRotate	geometry/tf/include/tf/LinearMath/Quaternion.h	/^quatRotate(const Quaternion& rotation, const Vector3& v) $/;"	f	namespace:tf
quaternionEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void quaternionEigenToKDL(const Eigen::Quaterniond &e, KDL::Rotation &k)$/;"	f	namespace:tf
quaternionEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void quaternionEigenToMsg(const Eigen::Quaterniond &e, geometry_msgs::Quaternion &m)$/;"	f	namespace:tf
quaternionEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void quaternionEigenToTF(const Eigen::Quaterniond& e, tf::Quaternion& t)$/;"	f	namespace:tf
quaternionKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void quaternionKDLToEigen(const KDL::Rotation &k, Eigen::Quaterniond &e)$/;"	f	namespace:tf
quaternionKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void quaternionKDLToMsg(const KDL::Rotation &k, geometry_msgs::Quaternion &m)$/;"	f	namespace:tf
quaternionKDLToTF	geometry/tf_conversions/src/tf_kdl.cpp	/^  void quaternionKDLToTF(const KDL::Rotation &k, tf::Quaternion &t)$/;"	f	namespace:tf
quaternionMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void quaternionMsgToEigen(const geometry_msgs::Quaternion &m, Eigen::Quaterniond &e)$/;"	f	namespace:tf
quaternionMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void quaternionMsgToKDL(const geometry_msgs::Quaternion &m, KDL::Rotation &k)$/;"	f	namespace:tf
quaternionMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void quaternionMsgToTF(const geometry_msgs::Quaternion& msg, Quaternion& bt) $/;"	f	namespace:tf
quaternionStampedMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void quaternionStampedMsgToTF(const geometry_msgs::QuaternionStamped & msg, Stamped<Quaternion>& bt)$/;"	f	namespace:tf
quaternionStampedTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void quaternionStampedTFToMsg(const Stamped<Quaternion>& bt, geometry_msgs::QuaternionStamped & msg)$/;"	f	namespace:tf
quaternionTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void quaternionTFToEigen(const tf::Quaternion& t, Eigen::Quaterniond& e)$/;"	f	namespace:tf
quaternionTFToKDL	geometry/tf_conversions/src/tf_kdl.cpp	/^  void quaternionTFToKDL(const tf::Quaternion& t, KDL::Rotation& k)$/;"	f	namespace:tf
quaternionTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void quaternionTFToMsg(const Quaternion& bt, geometry_msgs::Quaternion& msg) $/;"	f	namespace:tf
quaternion_about_axis	geometry/tf/src/tf/transformations.py	/^def quaternion_about_axis(angle, axis):$/;"	f
quaternion_conjugate	geometry/tf/src/tf/transformations.py	/^def quaternion_conjugate(quaternion):$/;"	f
quaternion_from_euler	geometry/tf/src/tf/transformations.py	/^def quaternion_from_euler(ai, aj, ak, axes='sxyz'):$/;"	f
quaternion_from_matrix	geometry/tf/src/tf/transformations.py	/^def quaternion_from_matrix(matrix):$/;"	f
quaternion_inverse	geometry/tf/src/tf/transformations.py	/^def quaternion_inverse(quaternion):$/;"	f
quaternion_matrix	geometry/tf/src/tf/transformations.py	/^def quaternion_matrix(quaternion):$/;"	f
quaternion_multiply	geometry/tf/src/tf/transformations.py	/^def quaternion_multiply(quaternion1, quaternion0):$/;"	f
quaternion_slerp	geometry/tf/src/tf/transformations.py	/^def quaternion_slerp(quat0, quat1, fraction, spin=0, shortestpath=True):$/;"	f
queueLength	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^int CarmenWrapper::queueLength(){$/;"	f	class:CarmenWrapper
queue_size_	geometry/tf/include/tf/message_filter.h	/^  uint32_t queue_size_; \/\/\/< The maximum number of messages we queue up$/;"	m	class:tf::MessageFilter
r	openslam_gmapping/utils/movement.h	/^  double r;$/;"	m	class:GMapping::FSRMovement
random_quaternion	geometry/tf/src/tf/transformations.py	/^def random_quaternion(rand=None):$/;"	f
random_rotation_matrix	geometry/tf/src/tf/transformations.py	/^def random_rotation_matrix(rand=None):$/;"	f
random_vector	geometry/tf/src/tf/transformations.py	/^def random_vector(size):$/;"	f
randseed	openslam_gmapping/gui/gsp_thread.h	/^		unsigned int randseed;$/;"	m	struct:GridSlamProcessorThread
rawView	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^unsigned int RangeReading::rawView(double* v, double density) const{$/;"	f	class:GMapping::RangeReading
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	istream& read(istream& is){$/;"	f	struct:RecordList
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void read(istream& is){$/;"	f	struct:CommentRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void read(istream& is){$/;"	f	struct:LaserRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void read(istream& is){$/;"	f	struct:OdometryRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void read(istream& is){$/;"	f	struct:ResampleRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void read(istream& is){$/;"	f	struct:ScanMatchRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	void read(istream& is){$/;"	f	struct:NeffRecord
read	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	void read(istream& is){$/;"	f	struct:PoseRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^istream& RecordList::read(istream& is){$/;"	f	class:GMapping::GFSReader::RecordList
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void CommentRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::CommentRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void EntropyRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::EntropyRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void LaserRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::LaserRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void NeffRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::NeffRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void OdometryRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::OdometryRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void PoseRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::PoseRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void RawOdometryRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::RawOdometryRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void ResampleRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::ResampleRecord
read	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void ScanMatchRecord::read(istream& is){$/;"	f	class:GMapping::GFSReader::ScanMatchRecord
readFromStdin	openslam_gmapping/gui/gsp_thread.h	/^		bool readFromStdin;$/;"	m	struct:GridSlamProcessorThread
readPointCloud2BufferValue	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^    inline T readPointCloud2BufferValue(const unsigned char* data_ptr){$/;"	f	namespace:sensor_msgs
readPointCloud2BufferValue	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^    inline T readPointCloud2BufferValue(const unsigned char* data_ptr, const unsigned char datatype){$/;"	f	namespace:sensor_msgs
read_points	common_msgs/sensor_msgs/src/sensor_msgs/point_cloud2.py	/^def read_points(cloud, field_names=None, skip_nans=False, uvs=[]):$/;"	f
reading	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      const RangeReading* reading;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
reading2carmen	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^carmen_robot_laser_message CarmenWrapper::reading2carmen(const RangeReading& reading){$/;"	f	class:CarmenWrapper
readings	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	vector<double> readings;$/;"	m	struct:LaserRecord	file:
readings	openslam_gmapping/gridfastslam/gfsreader.h	/^	vector<double> readings;$/;"	m	struct:GMapping::GFSReader::LaserRecord
reference	openslam_gmapping/gui/qgraphpainter.h	/^		double min, max, reference;$/;"	m	class:QGraphPainter
reference	openslam_gmapping/include/gmapping/utils/autoptr.h	/^	struct reference{$/;"	s	class:GMapping::autoptr
reflection_from_matrix	geometry/tf/src/tf/transformations.py	/^def reflection_from_matrix(matrix):$/;"	f
reflection_matrix	geometry/tf/src/tf/transformations.py	/^def reflection_matrix(point, normal):$/;"	f
refreshParameters	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::refreshParameters(){$/;"	f	class:QParticleViewer
registerFailureCallback	geometry/tf/include/tf/message_filter.h	/^  message_filters::Connection registerFailureCallback(const FailureCallback& callback)$/;"	f	class:tf::MessageFilter
registerLocalizationMessages	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^int CarmenWrapper::registerLocalizationMessages(){$/;"	f	class:CarmenWrapper
registerScan	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^double ScanMatcher::registerScan(ScanMatcherMap& map, const OrientedPoint& p, const double* readings){$/;"	f	class:GMapping::ScanMatcher
registerScan	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^void ScanMatcher::registerScan(ScanMatcherMap& map, const OrientedPoint& p, const double* readings){$/;"	f	class:GMapping::ScanMatcher
regscore	openslam_gmapping/gui/gsp_thread.h	/^		double regscore;$/;"	m	struct:GridSlamProcessorThread
release	geometry/tf/conf.py	/^release = '0.1.0'$/;"	v
release	geometry/tf_conversions/conf.py	/^release = '0.1.0'$/;"	v
remap	geometry/tf/include/tf/tf.h	/^__attribute__((deprecated)) static inline std::string remap(const std::string& prefix, const std::string& frame_name) { return tf::resolve(prefix, frame_name);} ;$/;"	f	namespace:tf
remap	geometry/tf/src/transform_listener.cpp	/^std::string tf::remap(const std::string& frame_id)$/;"	f	class:tf
remap_tf	geometry/tf/scripts/tf_remap	/^def remap_tf():$/;"	f
removeTransformsChangedListener	geometry/tf/src/tf.cpp	/^void Transformer::removeTransformsChangedListener(boost::signals2::connection c)$/;"	f	class:Transformer
reparenting	geometry/tf/src/tf/tfwtf.py	/^def reparenting(ctx):$/;"	f
repeatIndexes	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void repeatIndexes(Vector& dest, const std::vector<int>& indexes, const Vector& particles){$/;"	f
repeatIndexes	openslam_gmapping/particlefilter/pf.h	/^void repeatIndexes(Vector& dest, const std::vector<int>& indexes, const Vector& particles){$/;"	f
repeatIndexes	openslam_gmapping/particlefilter/pf.h	/^void repeatIndexes(Vector& dest, const std::vector<int>& indexes2, const Vector& particles, const std::vector<int>& indexes){$/;"	f
repositionRobot	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool repositionRobot;$/;"	m	class:QNavigatorWidget
requires	geometry/tf/setup.py	/^    requires=['genmsg', 'genpy', 'roslib', 'rospkg', 'geometry_msgs', 'sensor_msgs', 'std_msgs'],$/;"	v
requires	geometry/tf_conversions/setup.py	/^    requires=['geometry_msgs', 'rospy', 'tf']$/;"	v
resample	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.hxx	/^inline bool GridSlamProcessor::resample(const double* plainReading, int adaptSize, const RangeReading* reading){$/;"	f	class:GridSlamProcessor
resample	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^std::vector<Particle> uniform_resampler<Particle,Numeric>::resample$/;"	f	class:uniform_resampler
resample	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void resample(std::vector<int>& indexes, const WeightVector& weights, unsigned int nparticles=0){$/;"	f
resample	openslam_gmapping/particlefilter/particlefilter.cpp	/^std::vector<unsigned int> sistematicResampler<State,Numeric>::resample(const vector<Particle>& particles) const{$/;"	f	class:sistematicResampler
resample	openslam_gmapping/particlefilter/pf.h	/^void resample(std::vector<int>& indexes, const WeightVector& weights, unsigned int nparticles=0){$/;"	f
resampleIndexes	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^std::vector<unsigned int> uniform_resampler<Particle, Numeric>:: resampleIndexes(const std::vector<Particle>& particles, int nparticles) const{$/;"	f	class:uniform_resampler
resampleThreshold	openslam_gmapping/gui/gsp_thread.h	/^		double resampleThreshold;$/;"	m	struct:GridSlamProcessorThread
resampleThreshold	openslam_gmapping/gui/qparticleviewer.h	/^			double resampleThreshold;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
resampleThreshold_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double resampleThreshold_;$/;"	m	class:SlamGMapping
resampler	openslam_gmapping/particlefilter/particlefilter.cpp	/^	indexResampler<Numeric> resampler;$/;"	m	struct:auxiliaryEvolver	file:
reserve	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline void PointCloud2Modifier::reserve(size_t size)$/;"	f	class:sensor_msgs::PointCloud2Modifier
reset	openslam_gmapping/gui/qpixmapdumper.cpp	/^void QPixmapDumper::reset(){$/;"	f	class:QPixmapDumper
resetTree	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^void GridSlamProcessor::resetTree(){$/;"	f	class:GMapping::GridSlamProcessor
resize	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline void PointCloud2Modifier::resize(size_t size)$/;"	f	class:sensor_msgs::PointCloud2Modifier
resize	openslam_gmapping/include/gmapping/grid/array2d.h	/^void Array2D<Cell,debug>::resize(int xmin, int ymin, int xmax, int ymax){$/;"	f	class:GMapping::Array2D
resize	openslam_gmapping/include/gmapping/grid/harray2d.h	/^void HierarchicalArray2D<Cell>::resize(int xmin, int ymin, int xmax, int ymax){$/;"	f	class:GMapping::HierarchicalArray2D
resize	openslam_gmapping/include/gmapping/grid/map.h	/^void Map<Cell,Storage,isClass>::resize(double xmin, double ymin, double xmax, double ymax){$/;"	f	class:GMapping::Map
resizeEvent	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::resizeEvent(QResizeEvent * sizeev){$/;"	f	class:QGraphPainter
resizeEvent	openslam_gmapping/gui/qmappainter.cpp	/^void QMapPainter::resizeEvent(QResizeEvent * sizeev){$/;"	f	class:QMapPainter
resizeEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::resizeEvent(QResizeEvent * sizeev){$/;"	f	class:QParticleViewer
resolve	geometry/tf/include/tf/transform_listener.h	/^  std::string resolve(const std::string& frame_name)$/;"	f	class:tf::TransformListener
resolve	geometry/tf/src/tf.cpp	/^std::string tf::resolve(const std::string& prefix, const std::string& frame_name)$/;"	f	class:tf
result_msg	common_msgs/actionlib_msgs/scripts/genaction.py	/^        result_msg = AUTOGEN + result$/;"	v
result_quat	geometry/tf/src/tf.cpp	/^  tf::Quaternion result_quat;$/;"	m	struct:TransformAccum	file:
result_vec	geometry/tf/src/tf.cpp	/^  tf::Vector3 result_vec;$/;"	m	struct:TransformAccum	file:
ret_code	geometry/tf/scripts/bullet_migration_sed.py	/^    ret_code = subprocess.call(full_cmd, shell=True)$/;"	v
rewind	openslam_gmapping/log/sensorstream.cpp	/^bool InputSensorStream::rewind(){$/;"	f	class:GMapping::InputSensorStream
rewind	openslam_gmapping/log/sensorstream.cpp	/^bool LogSensorStream::rewind(){$/;"	f	class:GMapping::LogSensorStream
rl	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	RecordList rl;$/;"	v
rle	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void rle(OutputIterator& out, const Iterator & begin, const Iterator & end){$/;"	f
rle	openslam_gmapping/particlefilter/pf.h	/^void rle(OutputIterator& out, const Iterator & begin, const Iterator & end){$/;"	f
robotHeading	openslam_gmapping/gui/qnavigatorwidget.h	/^		double robotHeading;$/;"	m	class:QNavigatorWidget
robotHeading	openslam_gmapping/gui/qslamandnavwidget.h	/^		double robotHeading;$/;"	m	class:QSLAMandNavWidget
robotPose	openslam_gmapping/gui/qnavigatorwidget.h	/^		GMapping::IntPoint robotPose;$/;"	m	class:QNavigatorWidget
robotPose	openslam_gmapping/gui/qslamandnavwidget.h	/^		GMapping::IntPoint robotPose;$/;"	m	class:QSLAMandNavWidget
robot_frontlaser_handler	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::robot_frontlaser_handler(carmen_robot_laser_message* frontlaser) {$/;"	f	class:CarmenWrapper
robot_rearlaser_handler	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::robot_rearlaser_handler(carmen_robot_laser_message* rearlaser) {$/;"	f	class:CarmenWrapper
rostime_delta	geometry/tf/src/tf/tfwtf.py	/^def rostime_delta(ctx):$/;"	f
roswtf_plugin_online	geometry/tf/src/tf/tfwtf.py	/^def roswtf_plugin_online(ctx):$/;"	f
rotate	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE Vector3 Vector3::rotate( const Vector3& wAxis, const tfScalar angle ) const$/;"	f	class:tf::Vector3
rotate	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	double rotate = 0;$/;"	v
rotate	openslam_gmapping/include/gmapping/utils/point.h	/^	inline orientedpoint<T,A> rotate(A alpha){$/;"	f	struct:GMapping::orientedpoint
rotation_	geometry/tf/include/tf/time_cache.h	/^  tf::Quaternion rotation_;$/;"	m	class:tf::TransformStorage
rotation_from_matrix	geometry/tf/src/tf/transformations.py	/^def rotation_from_matrix(matrix):$/;"	f
rotation_matrix	geometry/tf/src/tf/transformations.py	/^def rotation_matrix(angle, direction, point=None):$/;"	f
round	openslam_gmapping/include/gmapping/utils/gvalues.h	22;"	d
rows	openslam_gmapping/utils/dmatrix.h	/^		int rows() const { return nrows; }$/;"	f	class:GMapping::DMatrix
rules	geometry/tf/scripts/bullet_migration_sed.py	/^rules = ['s|LinearMath\/bt|tf\/LinearMath\/|g',  # include path$/;"	v
running	openslam_gmapping/gui/gsp_thread.h	/^		bool running;$/;"	m	struct:GridSlamProcessorThread
s	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^			double s,c;		\/\/sinus and cosinus of the beam (optimization);$/;"	m	struct:GMapping::RangeSensor::Beam
s	openslam_gmapping/utils/movement.h	/^  double s;$/;"	m	class:GMapping::FSRMovement
sample	openslam_gmapping/utils/datasmoother.h	/^  double sample() {$/;"	f	class:GMapping::DataSmoother
sampleGaussian	openslam_gmapping/utils/stat.cpp	/^double sampleGaussian(double sigma, unsigned int S) {$/;"	f	namespace:GMapping
sampleMultiple	openslam_gmapping/utils/datasmoother.h	/^  void sampleMultiple(std::vector<double>& samples, int num) {$/;"	f	class:GMapping::DataSmoother
sampleNumeric	openslam_gmapping/utils/datasmoother.h	/^  double sampleNumeric(double step) {$/;"	f	class:GMapping::DataSmoother
sampleSize	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	mutable int sampleSize;$/;"	m	struct:RecordList	file:
sampleSize	openslam_gmapping/gridfastslam/gfsreader.h	/^	mutable int sampleSize;$/;"	m	struct:GMapping::GFSReader::RecordList
saveGoalPoints	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool saveGoalPoints;$/;"	m	class:QSLAMandNavWidget
scale_from_matrix	geometry/tf/src/tf/transformations.py	/^def scale_from_matrix(matrix):$/;"	f
scale_matrix	geometry/tf/src/tf/transformations.py	/^def scale_matrix(factor, origin=None, direction=None):$/;"	f
scaled	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	Matrix3x3 scaled(const Vector3& s) const$/;"	f	class:tf::Matrix3x3
scanMatch	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.hxx	/^inline void GridSlamProcessor::scanMatch(const double* plainReading){$/;"	f	class:GridSlamProcessor
scan_filter_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    tf::MessageFilter<sensor_msgs::LaserScan>* scan_filter_;$/;"	m	class:SlamGMapping
scan_filter_sub_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    message_filters::Subscriber<sensor_msgs::LaserScan>* scan_filter_sub_;$/;"	m	class:SlamGMapping
scanmatched	openslam_gmapping/gui/gsp_thread.h	/^			bool scanmatched;$/;"	m	struct:GridSlamProcessorThread::ParticleMoveEvent
score	openslam_gmapping/include/gmapping/scanmatcher/scanmatcher.h	/^inline double ScanMatcher::score(const ScanMatcherMap& map, const OrientedPoint& p, const double* readings) const{$/;"	f	class:GMapping::ScanMatcher
score	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^	double score;$/;"	m	struct:GMapping::ScoredMove	file:
score	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^	double score;$/;"	m	struct:GMapping::ScoredMove	file:
scripts	geometry/tf/setup.py	/^    scripts=['scripts\/groovy_compatibility\/tf_remap',$/;"	v
scrit	openslam_gmapping/gui/qparticleviewer.h	/^			double ssigma, sreg, scrit;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
second	openslam_gmapping/grid/graphmap.cpp	/^	GraphMapPatch* first, *second;$/;"	m	struct:GMapping::GraphMapEdge	file:
seed_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    unsigned long int seed_;$/;"	m	class:SlamGMapping
seed_rand	geometry/tf/test/cache_unittest.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/operator_overload.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/quaternion.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/tf_benchmark.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/tf_unittest.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/tf_unittest_future.cpp	/^void seed_rand()$/;"	f
seed_rand	geometry/tf/test/transform_listener_unittest.cpp	/^void seed_rand()$/;"	f
send	geometry/tf/src/static_transform_publisher.cpp	/^  void send (ros::Time time) {$/;"	f	class:TransformSender
sendTransform	geometry/tf/src/tf/broadcaster.py	/^    def sendTransform(self, translation, rotation, time, child, parent):$/;"	m	class:TransformBroadcaster
sendTransform	geometry/tf/src/transform_broadcaster.cpp	/^void TransformBroadcaster::sendTransform(const StampedTransform & transform)$/;"	f	class:tf::TransformBroadcaster
sendTransform	geometry/tf/src/transform_broadcaster.cpp	/^void TransformBroadcaster::sendTransform(const geometry_msgs::TransformStamped & msgtf)$/;"	f	class:tf::TransformBroadcaster
sendTransform	geometry/tf/src/transform_broadcaster.cpp	/^void TransformBroadcaster::sendTransform(const std::vector<StampedTransform> & transforms)$/;"	f	class:tf::TransformBroadcaster
sendTransform	geometry/tf/src/transform_broadcaster.cpp	/^void TransformBroadcaster::sendTransform(const std::vector<geometry_msgs::TransformStamped> & msgtf)$/;"	f	class:tf::TransformBroadcaster
sendTransformMessage	geometry/tf/src/tf/broadcaster.py	/^    def sendTransformMessage(self, transform):$/;"	m	class:TransformBroadcaster
sensorMap	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^const SensorMap& CarmenWrapper::sensorMap(){$/;"	f	class:CarmenWrapper
sensorMap	openslam_gmapping/gui/gsp_thread.h	/^		SensorMap sensorMap;$/;"	m	struct:GridSlamProcessorThread
sensorMapComputed	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::sensorMapComputed(){$/;"	f	class:CarmenWrapper
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/distortion_models.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/fill_image.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/image_encodings.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud2_iterator.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/point_cloud_conversion.h	/^namespace sensor_msgs$/;"	n
sensor_msgs	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^namespace sensor_msgs{$/;"	n
serialize	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE	void	Matrix3x3::serialize(struct	Matrix3x3Data& dataOut) const$/;"	f	class:tf::Matrix3x3
serialize	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE	void	Transform::serialize(TransformData& dataOut) const$/;"	f	class:tf::Transform
serialize	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE	void	Vector3::serialize(struct	Vector3Data& dataOut) const$/;"	f	class:tf::Vector3
serializeDouble	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE	void	Vector3::serializeDouble(struct	Vector3DoubleData& dataOut) const$/;"	f	class:tf::Vector3
serializeFloat	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^TFSIMD_FORCE_INLINE	void	Matrix3x3::serializeFloat(struct	Matrix3x3FloatData& dataOut) const$/;"	f	class:tf::Matrix3x3
serializeFloat	geometry/tf/include/tf/LinearMath/Transform.h	/^TFSIMD_FORCE_INLINE	void	Transform::serializeFloat(TransformFloatData& dataOut) const$/;"	f	class:tf::Transform
serializeFloat	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE	void	Vector3::serializeFloat(struct	Vector3FloatData& dataOut) const$/;"	f	class:tf::Vector3
setAcceleration	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline void setAcceleration(const OrientedPoint& acceleration) {m_acceleration=acceleration;}$/;"	f	class:GMapping::OdometryReading
setActiveArea	openslam_gmapping/include/gmapping/grid/harray2d.h	/^void HierarchicalArray2D<Cell>::setActiveArea(const typename HierarchicalArray2D<Cell>::PointSet& aa, bool patchCoords){$/;"	f	class:GMapping::HierarchicalArray2D
setAutoscale	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::setAutoscale(bool a) {$/;"	f	class:QGraphPainter
setBasis	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE void setBasis(const Matrix3x3& basis)$/;"	f	class:tf::Transform
setData	geometry/tf/include/tf/transform_datatypes.h	/^  void setData(const T& input){*static_cast<T*>(this) = input;};$/;"	f	class:tf::Stamped
setData	geometry/tf/include/tf/transform_datatypes.h	/^  void setData(const tf::Transform& input){*static_cast<tf::Transform*>(this) = input;};$/;"	f	class:tf::StampedTransform
setEuler	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	void setEuler(const tfScalar& yaw, const tfScalar& pitch, const tfScalar& roll)$/;"	f	class:tf::Quaternion
setEulerYPR	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setEulerYPR(tfScalar eulerZ, tfScalar eulerY,tfScalar eulerX)  { $/;"	f	class:tf::Matrix3x3
setEulerZYX	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setEulerZYX(const tfScalar& yaw, const tfScalar& pitch, const tfScalar& roll) __attribute__((deprecated))$/;"	f	class:tf::Matrix3x3
setEulerZYX	geometry/tf/include/tf/LinearMath/Quaternion.h	/^  void setEulerZYX(const tfScalar& yaw, const tfScalar& pitch, const tfScalar& roll) __attribute__((deprecated))$/;"	f	class:tf::Quaternion
setEventBufferSize	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::setEventBufferSize(unsigned int length){$/;"	f	class:GridSlamProcessorThread
setExtrapolationLimit	geometry/tf/src/tf.cpp	/^void Transformer::setExtrapolationLimit(const ros::Duration& distance)$/;"	f	class:Transformer
setFromOpenGLMatrix	geometry/tf/include/tf/LinearMath/Transform.h	/^	void setFromOpenGLMatrix(const tfScalar *m)$/;"	f	class:tf::Transform
setFromOpenGLSubMatrix	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setFromOpenGLSubMatrix(const tfScalar *m)$/;"	f	class:tf::Matrix3x3
setGSP	openslam_gmapping/gui/qparticleviewer.h	/^		inline void setGSP( GridSlamProcessorThread* thread){gfs_thread=thread;}$/;"	f	class:GMapping::QParticleViewer
setIdentity	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setIdentity()$/;"	f	class:tf::Matrix3x3
setIdentity	geometry/tf/include/tf/LinearMath/Transform.h	/^	void setIdentity()$/;"	f	class:tf::Transform
setInterpolate3	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE void setInterpolate3(const Vector3& v0, const Vector3& v1, tfScalar rt)$/;"	f	class:tf::Vector3
setLaserParameters	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^void ScanMatcher::setLaserParameters$/;"	f	class:GMapping::ScanMatcher
setLaserParameters	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^	void ScanMatcher::setLaserParameters$/;"	f	class:GMapping::ScanMatcher
setMapUpdateTime	openslam_gmapping/gui/gsp_thread.h	/^		inline void setMapUpdateTime(unsigned int ut) {mapUpdateTime=ut;}$/;"	f	struct:GridSlamProcessorThread
setMatchingParameters	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::setMatchingParameters (double urange, double range, double sigma, int kernsize, double lopt, double aopt, $/;"	f	class:GMapping::GridSlamProcessor
setMatchingParameters	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::setMatchingParameters(const QParticleViewer::MatchingParameters& mp){$/;"	f	class:QParticleViewer
setMatchingParameters	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^void ScanMatcher::setMatchingParameters$/;"	f	class:GMapping::ScanMatcher
setMatchingParameters	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^void ScanMatcher::setMatchingParameters$/;"	f	class:GMapping::ScanMatcher
setMatchingParameters	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^void ScanMatcherProcessor::setMatchingParameters$/;"	f	class:GMapping::ScanMatcherProcessor
setMax	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setMax(const Vector3& other)$/;"	f	class:tf::Vector3
setMin	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setMin(const Vector3& other)$/;"	f	class:tf::Vector3
setMinToZero	openslam_gmapping/utils/datasmoother.h	/^  void setMinToZero() {$/;"	f	class:GMapping::DataSmoother
setMotionModelParameters	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^void GridSlamProcessor::setMotionModelParameters$/;"	f	class:GMapping::GridSlamProcessor
setName	openslam_gmapping/include/gmapping/sensor/sensor_base/sensor.h	/^		inline void setName(const std::string& name) {m_name=name;}$/;"	f	class:GMapping::Sensor
setOrigin	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE void setOrigin(const Vector3& origin) $/;"	f	class:tf::Transform
setPixmap	openslam_gmapping/gui/qmappainter.h	/^void QMapPainter::setPixmap(unsigned int xsize, unsigned int ysize, Cell** values){$/;"	f	class:QMapPainter
setPointCloud2Fields	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline void PointCloud2Modifier::setPointCloud2Fields(int n_fields, ...)$/;"	f	class:sensor_msgs::PointCloud2Modifier
setPointCloud2FieldsByString	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline void PointCloud2Modifier::setPointCloud2FieldsByString(int n_fields, ...)$/;"	f	class:sensor_msgs::PointCloud2Modifier
setPose	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline void setPose(const OrientedPoint& pose) {m_pose=pose;}$/;"	f	class:GMapping::OdometryReading
setPose	openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h	/^		inline void setPose(const OrientedPoint& pose) {m_pose=pose;}$/;"	f	class:GMapping::RangeReading
setQueueSize	geometry/tf/include/tf/message_filter.h	/^  virtual void setQueueSize( uint32_t new_queue_size )$/;"	f	class:tf::MessageFilter
setRPY	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setRPY(tfScalar roll, tfScalar pitch,tfScalar yaw) { $/;"	f	class:tf::Matrix3x3
setRPY	geometry/tf/include/tf/LinearMath/Quaternion.h	/^  void setRPY(const tfScalar& roll, const tfScalar& pitch, const tfScalar& yaw)$/;"	f	class:tf::Quaternion
setRange	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::setRange(double _min, double _max){$/;"	f	class:QGraphPainter
setRegistrationParameters	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^void ScanMatcherProcessor::setRegistrationParameters(double regScore, double critScore){$/;"	f	class:GMapping::ScanMatcherProcessor
setRotation	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setRotation(const Quaternion& q) $/;"	f	class:tf::Matrix3x3
setRotation	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	void setRotation(const Vector3& axis, const tfScalar& angle)$/;"	f	class:tf::Quaternion
setRotation	geometry/tf/include/tf/LinearMath/Transform.h	/^	TFSIMD_FORCE_INLINE void setRotation(const Quaternion& q)$/;"	f	class:tf::Transform
setSensorMap	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::setSensorMap(const SensorMap& smap){$/;"	f	class:GMapping::GridSlamProcessor
setSensorMap	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^void ScanMatcherProcessor::setSensorMap(const SensorMap& smap, std::string sensorName){$/;"	f	class:GMapping::ScanMatcherProcessor
setSpeed	openslam_gmapping/include/gmapping/sensor/sensor_odometry/odometryreading.h	/^		inline void setSpeed(const OrientedPoint& speed) {m_speed=speed;}$/;"	f	class:GMapping::OdometryReading
setStartParameters	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::setStartParameters(const QParticleViewer::StartParameters& sp){$/;"	f	class:QParticleViewer
setT	geometry/tf/test/testPython.py	/^def setT(t, parent, frame, ti, x):$/;"	f
setTargetFrame	geometry/tf/include/tf/message_filter.h	/^  void setTargetFrame(const std::string& target_frame)$/;"	f	class:tf::MessageFilter
setTargetFrames	geometry/tf/include/tf/message_filter.h	/^  void setTargetFrames(const std::vector<std::string>& target_frames)$/;"	f	class:tf::MessageFilter
setTime	openslam_gmapping/include/gmapping/sensor/sensor_base/sensorreading.h	/^		inline void setTime(double t) {m_time=t;}$/;"	f	class:GMapping::SensorReading
setTitle	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::setTitle(const char* t){$/;"	f	class:QGraphPainter
setTolerance	geometry/tf/include/tf/message_filter.h	/^  void setTolerance(const ros::Duration& tolerance)$/;"	f	class:tf::MessageFilter
setTransform	geometry/tf/src/tf.cpp	/^bool Transformer::setTransform(const StampedTransform& transform, const std::string& authority)$/;"	f	class:Transformer
setTransform	geometry/tf/src/tf/listener.py	/^    def setTransform(self, transform, authority="default_authority"):$/;"	m	class:Transformer
setUp	geometry/tf/test/testPython.py	/^    def setUp(self):$/;"	m	class:TestPython
setUp	geometry/tf/test/test_datatype_conversion.py	/^    def setUp(self):$/;"	m	class:PoseConversions
setUp	geometry/tf_conversions/test/posemath.py	/^    def setUp(self):$/;"	m	class:TestPoseMath
setUpClass	geometry/tf/test/testPython.py	/^    def setUpClass(cls):$/;"	m	class:TestPython
setUpdateDistances	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  void GridSlamProcessor::setUpdateDistances(double linear, double angular, double resampleThreshold){$/;"	f	class:GMapping::GridSlamProcessor
setUpdatePeriod	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^    void setUpdatePeriod(double p) {period_=p;}$/;"	f	class:GMapping::GridSlamProcessor
setUsingDedicatedThread	geometry/tf/include/tf/tf.h	/^  void setUsingDedicatedThread(bool value) { tf2_buffer_.setUsingDedicatedThread(value);};$/;"	f	class:tf::Transformer
setUsingDedicatedThread	geometry/tf/src/tf/listener.py	/^    def setUsingDedicatedThread(self, value):$/;"	m	class:Transformer
setValue	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	void setValue(const tfScalar& xx, const tfScalar& xy, const tfScalar& xz, $/;"	f	class:tf::Matrix3x3
setValue	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setValue(const tfScalar& x, const tfScalar& y, const tfScalar& z,const tfScalar& w)$/;"	f	class:tf::tfVector4
setValue	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void 	setValue(const tfScalar& x, const tfScalar& y, const tfScalar& z)$/;"	f	class:tf::Vector3
setW	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setW(tfScalar w) { m_floats[3] = w;};$/;"	f	class:tf::Vector3
setWeight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      inline void setWeight(double w) {weight=w;}$/;"	f	struct:GMapping::GridSlamProcessor::Particle
setWeight	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	inline void setWeight(double _w) {w=_w;}$/;"	f	struct:Particle
setWeight	openslam_gmapping/particlefilter/range_bearing.cpp	/^	void setWeight(double _w) {w=_w;}$/;"	f	struct:Particle
setX	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setX(tfScalar x) { m_floats[0] = x;};$/;"	f	class:tf::Vector3
setY	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setY(tfScalar y) { m_floats[1] = y;};$/;"	f	class:tf::Vector3
setYReference	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::setYReference(double y){$/;"	f	class:QGraphPainter
setZ	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE void	setZ(tfScalar z) {m_floats[2] = z;};$/;"	f	class:tf::Vector3
setZero	geometry/tf/include/tf/LinearMath/Vector3.h	/^		void	setZero()$/;"	f	class:tf::Vector3
set_field	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^int PointCloud2IteratorBase<T, TT, U, C, V>::set_field(const sensor_msgs::PointCloud2 &cloud_msg, const std::string &field_name)$/;"	f	class:sensor_msgs::impl::PointCloud2IteratorBase
setaxes	geometry/tf/src/tf/transformations.py	/^    def setaxes(self, *axes):$/;"	m	class:Arcball
setconstrain	geometry/tf/src/tf/transformations.py	/^    def setconstrain(self, constrain):$/;"	m	class:Arcball
setmaxMove	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		inline void setmaxMove(double mmove){m_maxMove=mmove;}$/;"	f	class:GMapping::ScanMatcherProcessor
setupTree	geometry/tf/test/tf_unittest.cpp	/^void setupTree(tf::Transformer& mTR, const std::string& mode, const ros::Time & time, const ros::Duration& interpolation_space = ros::Duration())$/;"	f
sg_	slam_gmapping/gmapping/src/nodelet.cpp	/^    boost::shared_ptr<SlamGMapping> sg_;$/;"	m	class:SlamGMappingNodelet	file:
shares	openslam_gmapping/include/gmapping/utils/autoptr.h	/^		unsigned int shares;$/;"	m	struct:GMapping::autoptr::reference
shares	openslam_gmapping/utils/dmatrix.h	/^		int * shares;$/;"	m	class:GMapping::DMatrix
shear_from_matrix	geometry/tf/src/tf/transformations.py	/^def shear_from_matrix(matrix):$/;"	f
shear_matrix	geometry/tf/src/tf/transformations.py	/^def shear_matrix(angle, direction, point, normal):$/;"	f
shortestArcQuat	geometry/tf/include/tf/LinearMath/Quaternion.h	/^shortestArcQuat(const Vector3& v0, const Vector3& v1) \/\/ Game Programming Gems 2.10. make sure v0,v1 are normalized$/;"	f	namespace:tf
shortestArcQuatNormalize2	geometry/tf/include/tf/LinearMath/Quaternion.h	/^shortestArcQuatNormalize2(Vector3& v0,Vector3& v1)$/;"	f	namespace:tf
showBestPath	openslam_gmapping/gui/qparticleviewer.h	/^		bool showBestPath;$/;"	m	class:GMapping::QParticleViewer
showPaths	openslam_gmapping/gui/qparticleviewer.h	/^		bool showPaths;$/;"	m	class:GMapping::QParticleViewer
shutdown_module	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::shutdown_module(int sig){$/;"	f	class:CarmenWrapper
sigma	openslam_gmapping/gui/gsp_thread.h	/^		double sigma;$/;"	m	struct:GridSlamProcessorThread
sigma	openslam_gmapping/particlefilter/range_bearing.cpp	/^	double sigma;$/;"	m	struct:LikelyhoodModel	file:
sigma_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double sigma_;$/;"	m	class:SlamGMapping
signalFailure	geometry/tf/include/tf/message_filter.h	/^  void signalFailure(const MEvent& evt, FilterFailureReason reason)$/;"	f	class:tf::MessageFilter
simulator_truepos_handler	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::simulator_truepos_handler(carmen_simulator_truepos_message* truepos){$/;"	f	class:CarmenWrapper
size	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline size_t PointCloud2Modifier::size() const$/;"	f	class:sensor_msgs::PointCloud2Modifier
sizeOfPointField	common_msgs/sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.h	/^inline int sizeOfPointField(int datatype)$/;"	f	namespace:__anon1
skip	openslam_gmapping/gridfastslam/gfs2stream.cpp	/^	double skip  = 2;$/;"	v
skipMatching	openslam_gmapping/gui/gsp_thread.h	/^		bool skipMatching;$/;"	m	struct:GridSlamProcessorThread
slamFinished	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool slamFinished;$/;"	m	class:QSLAMandNavWidget
slamRestart	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool slamRestart;$/;"	m	class:QSLAMandNavWidget
slerp	geometry/tf/include/tf/LinearMath/Quaternion.h	/^	Quaternion slerp(const Quaternion& q, const tfScalar& t) const$/;"	f	class:tf::Quaternion
slerp	geometry/tf/include/tf/LinearMath/Quaternion.h	/^slerp(const Quaternion& q1, const Quaternion& q2, const tfScalar& t) $/;"	f	namespace:tf
smoothedData	openslam_gmapping/utils/datasmoother.h	/^  double smoothedData(double x) {$/;"	f	class:GMapping::DataSmoother
source_frame_	geometry/tf/src/change_notifier.cpp	/^  std::string source_frame_;$/;"	m	class:FramePair	file:
source_suffix	geometry/tf/conf.py	/^source_suffix = '.rst'$/;"	v
source_suffix	geometry/tf_conversions/conf.py	/^source_suffix = '.rst'$/;"	v
source_to_top_quat	geometry/tf/src/tf.cpp	/^  tf::Quaternion source_to_top_quat;$/;"	m	struct:TransformAccum	file:
source_to_top_vec	geometry/tf/src/tf.cpp	/^  tf::Vector3 source_to_top_vec;$/;"	m	struct:TransformAccum	file:
span	openslam_gmapping/include/gmapping/sensor/sensor_range/rangesensor.h	/^			double span;	\/\/spam=0 indicates a line-like beam$/;"	m	struct:GMapping::RangeSensor::Beam
spin	geometry/tf/src/tf_monitor.cpp	/^  void spin()$/;"	f	class:TFMonitor
sqr	openslam_gmapping/utils/datasmoother.h	/^  double sqr(double x) {$/;"	f	class:GMapping::DataSmoother
sreg	openslam_gmapping/gui/qparticleviewer.h	/^			double ssigma, sreg, scrit;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
srr	openslam_gmapping/gui/gsp_thread.h	/^		double srr, srt, str, stt;$/;"	m	struct:GridSlamProcessorThread
srr	openslam_gmapping/gui/qparticleviewer.h	/^			double srr, srt, str, stt;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
srr	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^	double srr, str, srt, stt;$/;"	m	struct:GMapping::MotionModel
srr_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double srr_;$/;"	m	class:SlamGMapping
srt	openslam_gmapping/gui/gsp_thread.h	/^		double srr, srt, str, stt;$/;"	m	struct:GridSlamProcessorThread
srt	openslam_gmapping/gui/qparticleviewer.h	/^			double srr, srt, str, stt;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
srt	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^	double srr, str, srt, stt;$/;"	m	struct:GMapping::MotionModel
srt_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double srt_;$/;"	m	class:SlamGMapping
ss_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::ServiceServer ss_;	\/\/ dynamic_map service -> map file$/;"	m	class:SlamGMapping
ssigma	openslam_gmapping/gui/qparticleviewer.h	/^			double ssigma, sreg, scrit;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
sst_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::Publisher sst_;	\/\/ map$/;"	m	class:SlamGMapping
sstm_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    ros::Publisher sstm_;	\/\/ map metadata$/;"	m	class:SlamGMapping
st	geometry/tf/src/tf.cpp	/^  TransformStorage st;$/;"	m	struct:CanTransformAccum	file:
st	geometry/tf/src/tf.cpp	/^  TransformStorage st;$/;"	m	struct:TransformAccum	file:
stamp_	geometry/tf/include/tf/time_cache.h	/^  ros::Time stamp_;$/;"	m	class:tf::TransformStorage
stamp_	geometry/tf/include/tf/transform_datatypes.h	/^  ros::Time stamp_; \/\/\/< The timestamp associated with this data$/;"	m	class:tf::Stamped
stamp_	geometry/tf/include/tf/transform_datatypes.h	/^  ros::Time stamp_; \/\/\/< The timestamp associated with this transform$/;"	m	class:tf::StampedTransform
start	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::start(const char* name){$/;"	f	class:CarmenWrapper
start	openslam_gmapping/gui/gfs_simplegui.cpp	/^  void start(int c){$/;"	f	class:GFSMainWindow
start	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::start(){$/;"	f	class:GridSlamProcessorThread
start	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::start(int period){$/;"	f	class:QGraphPainter
start	openslam_gmapping/gui/qmappainter.cpp	/^void QMapPainter::start(int period){$/;"	f	class:QMapPainter
start	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::start(){$/;"	f	class:QParticleViewer
start	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::start(int period){$/;"	f	class:QParticleViewer
startGlobalLocalization	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool startGlobalLocalization;$/;"	m	class:QNavigatorWidget
startLiveSlam	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^void SlamGMapping::startLiveSlam()$/;"	f	class:SlamGMapping
startParameters	openslam_gmapping/gui/qparticleviewer.h	/^		StartParameters startParameters;$/;"	m	class:GMapping::QParticleViewer
startReplay	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^void SlamGMapping::startReplay(const std::string & bag_fname, std::string scan_topic)$/;"	f	class:SlamGMapping
startWalker	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool startWalker;$/;"	m	class:QNavigatorWidget
startWalker	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool startWalker;$/;"	m	class:QSLAMandNavWidget
started	geometry/tf/scripts/python_benchmark.py	/^started = time.time()$/;"	v
static_callback	geometry/tf/src/tf_monitor.cpp	/^  void static_callback(const ros::MessageEvent<tf::tfMessage const>& msg_evt)$/;"	f	class:TFMonitor
step	openslam_gmapping/scanmatcher/lumiles.h	/^OrientedPoint LuMilesProcessors::step(const PointVector& src, const PointVector& dest){$/;"	f	class:GMapping::LuMilesProcessors
stop	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::stop(){$/;"	f	class:GridSlamProcessorThread
stop	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::stop(){$/;"	f	class:QParticleViewer
stopped	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^bool CarmenWrapper::stopped=true;$/;"	m	class:CarmenWrapper	file:
stopped	openslam_gmapping/carmenwrapper/carmenwrapper.h	/^  static bool stopped;$/;"	m	class:GMapping::CarmenWrapper
storage	openslam_gmapping/include/gmapping/grid/map.h	/^		inline Storage& storage() { return m_storage; }$/;"	f	class:GMapping::Map
storage	openslam_gmapping/include/gmapping/grid/map.h	/^		inline const Storage& storage() const { return m_storage; }$/;"	f	class:GMapping::Map
storage_	geometry/tf/include/tf/time_cache.h	/^  L_TransformStorage storage_;$/;"	m	class:tf::TimeCache
str	openslam_gmapping/gui/gsp_thread.h	/^		double srr, srt, str, stt;$/;"	m	struct:GridSlamProcessorThread
str	openslam_gmapping/gui/qparticleviewer.h	/^			double srr, srt, str, stt;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
str	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^	double srr, str, srt, stt;$/;"	m	struct:GMapping::MotionModel
str_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double str_;$/;"	m	class:SlamGMapping
strip_leading_slash	geometry/tf/src/tf.cpp	/^std::string tf::strip_leading_slash(const std::string& frame_name)$/;"	f	class:tf
strip_leading_slash	geometry/tf/src/tf/listener.py	/^def strip_leading_slash(s):$/;"	f
stt	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
stt	openslam_gmapping/gui/gsp_thread.h	/^		double srr, srt, str, stt;$/;"	m	struct:GridSlamProcessorThread
stt	openslam_gmapping/gui/qparticleviewer.h	/^			double srr, srt, str, stt;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
stt	openslam_gmapping/include/gmapping/gridfastslam/motionmodel.h	/^	double srr, str, srt, stt;$/;"	m	struct:GMapping::MotionModel
stt_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double stt_;$/;"	m	class:SlamGMapping
subscriber_tf_	geometry/tf/src/tf_monitor.cpp	/^  ros::Subscriber subscriber_tf_, subscriber_tf_static_;$/;"	m	class:TFMonitor	file:
subscriber_tf_static_	geometry/tf/src/tf_monitor.cpp	/^  ros::Subscriber subscriber_tf_, subscriber_tf_static_;$/;"	m	class:TFMonitor	file:
successful_transform_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t successful_transform_count_;$/;"	m	class:tf::MessageFilter
superimposition_matrix	geometry/tf/src/tf/transformations.py	/^def superimposition_matrix(v0, v1, scaling=False, usesvd=True):$/;"	f
sxt	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
sxx	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
sxy	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
syncOdometryUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::syncOdometryUpdate(){$/;"	f	class:GridSlamProcessorThread
syncResampleUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::syncResampleUpdate(){$/;"	f	class:GridSlamProcessorThread
syncScanmatchUpdate	openslam_gmapping/gui/gsp_thread.cpp	/^void GridSlamProcessorThread::syncScanmatchUpdate(){$/;"	f	class:GridSlamProcessorThread
syt	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
syy	openslam_gmapping/grid/graphmap.cpp	/^	double sxx, sxy, sxt, syy, syt ,stt;$/;"	m	struct:GMapping::Covariance3	file:
t	geometry/tf/scripts/python_benchmark.py	/^t = tf.Transformer()$/;"	v
target_frame_	geometry/tf/src/change_notifier.cpp	/^  std::string target_frame_;$/;"	m	class:FramePair	file:
target_frames_	geometry/tf/include/tf/message_filter.h	/^  std::vector<std::string> target_frames_; \/\/\/< The frames we need to be able to transform to before a message is ready$/;"	m	class:tf::MessageFilter
target_frames_string_	geometry/tf/include/tf/message_filter.h	/^  std::string target_frames_string_;$/;"	m	class:tf::MessageFilter
target_frames_string_mutex_	geometry/tf/include/tf/message_filter.h	/^  boost::mutex target_frames_string_mutex_;$/;"	m	class:tf::MessageFilter
target_to_top_quat	geometry/tf/src/tf.cpp	/^  tf::Quaternion target_to_top_quat;$/;"	m	struct:TransformAccum	file:
target_to_top_vec	geometry/tf/src/tf.cpp	/^  tf::Vector3 target_to_top_vec;$/;"	m	struct:TransformAccum	file:
tdotx	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE tfScalar tdotx(const Vector3& v) const $/;"	f	class:tf::Matrix3x3
tdoty	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE tfScalar tdoty(const Vector3& v) const $/;"	f	class:tf::Matrix3x3
tdotz	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^	TFSIMD_FORCE_INLINE tfScalar tdotz(const Vector3& v) const $/;"	f	class:tf::Matrix3x3
templates_path	geometry/tf/conf.py	/^templates_path = ['_templates']$/;"	v
templates_path	geometry/tf_conversions/conf.py	/^templates_path = ['_templates']$/;"	v
temporalUpdate_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double temporalUpdate_;$/;"	m	class:SlamGMapping
test	geometry/tf/test/testBroadcaster.cpp	/^  void test () {$/;"	f	class:testBroadcaster
test	openslam_gmapping/particlefilter/particlefilter_test.cpp	8;"	d	file:
test	openslam_gmapping/particlefilter/range_bearing.cpp	10;"	d	file:
testBroadcaster	geometry/tf/test/testBroadcaster.cpp	/^  testBroadcaster() : count(0), count1(0){};$/;"	f	class:testBroadcaster
testBroadcaster	geometry/tf/test/testBroadcaster.cpp	/^class testBroadcaster $/;"	c	file:
testMessage	geometry/tf/include/tf/message_filter.h	/^  bool testMessage(const MEvent& evt)$/;"	f	class:tf::MessageFilter
testMessages	geometry/tf/include/tf/message_filter.h	/^  void testMessages()$/;"	f	class:tf::MessageFilter
testOk	openslam_gmapping/particlefilter/particlefilter_test.cpp	9;"	d	file:
testOk	openslam_gmapping/particlefilter/range_bearing.cpp	11;"	d	file:
testQuatRPY	geometry/tf/test/quaternion.cpp	/^void testQuatRPY(tf::Quaternion q_baseline)$/;"	f
test_basic_localization_stage	slam_gmapping/gmapping/test/test_map.py	/^  def test_basic_localization_stage(self):$/;"	m	class:TestGmapping
test_bt_operator_equal_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equal_point(self):$/;"	m	class:PoseConversions
test_bt_operator_equal_point_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equal_point_converted(self):$/;"	m	class:PoseConversions
test_bt_operator_equal_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equal_quaternion(self):$/;"	m	class:PoseConversions
test_bt_operator_equal_quaternion_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equal_quaternion_converted(self):$/;"	m	class:PoseConversions
test_bt_operator_equal_vector_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equal_vector_converted(self):$/;"	m	class:PoseConversions
test_bt_operator_equals_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_equals_pose(self):$/;"	m	class:PoseConversions
test_bt_operator_on_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_bt_operator_on_converted(self):$/;"	m	class:PoseConversions
test_cache_time	geometry/tf/test/testPython.py	/^    def test_cache_time(self):$/;"	m	class:TestPython
test_chain	geometry/tf/test/testPython.py	/^    def test_chain(self):$/;"	m	class:TestPython
test_fromTf	geometry/tf_conversions/test/posemath.py	/^    def test_fromTf(self):$/;"	m	class:TestPoseMath
test_getTFPrefix	geometry/tf/test/testPython.py	/^    def test_getTFPrefix(self):$/;"	m	class:TestPython
test_msg_operator_equal_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_point(self):$/;"	m	class:PoseConversions
test_msg_operator_equal_point_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_point_converted(self):$/;"	m	class:PoseConversions
test_msg_operator_equal_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_quaternion(self):$/;"	m	class:PoseConversions
test_msg_operator_equal_quaternion_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_quaternion_converted(self):$/;"	m	class:PoseConversions
test_msg_operator_equal_vector	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_vector(self):$/;"	m	class:PoseConversions
test_msg_operator_equal_vector_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equal_vector_converted(self):$/;"	m	class:PoseConversions
test_msg_operator_equals_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_equals_pose(self):$/;"	m	class:PoseConversions
test_msg_operator_on_converted	geometry/tf/test/test_datatype_conversion.py	/^    def test_msg_operator_on_converted(self):$/;"	m	class:PoseConversions
test_roundtrip	geometry/tf_conversions/test/posemath.py	/^    def test_roundtrip(self):$/;"	m	class:TestPoseMath
test_smoke	geometry/tf/test/testPython.py	/^    def test_smoke(self):$/;"	m	class:TestPython
test_stamped_to_msg_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_msg_point(self):$/;"	m	class:PoseConversions
test_stamped_to_msg_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_msg_pose(self):$/;"	m	class:PoseConversions
test_stamped_to_msg_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_msg_quaternion(self):$/;"	m	class:PoseConversions
test_stamped_to_msg_vector	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_msg_vector(self):$/;"	m	class:PoseConversions
test_stamped_to_tf_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_tf_point(self):$/;"	m	class:PoseConversions
test_stamped_to_tf_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_tf_pose(self):$/;"	m	class:PoseConversions
test_stamped_to_tf_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_tf_quaternion(self):$/;"	m	class:PoseConversions
test_stamped_to_tf_vector	geometry/tf/test/test_datatype_conversion.py	/^    def test_stamped_to_tf_vector(self):$/;"	m	class:PoseConversions
test_subclass	geometry/tf/test/testPython.py	/^    def test_subclass(self):$/;"	m	class:TestPython
test_to_msg_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_msg_point(self):$/;"	m	class:PoseConversions
test_to_msg_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_msg_pose(self):$/;"	m	class:PoseConversions
test_to_msg_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_msg_quaternion(self):$/;"	m	class:PoseConversions
test_to_msg_vector	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_msg_vector(self):$/;"	m	class:PoseConversions
test_to_tf_point	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_tf_point(self):$/;"	m	class:PoseConversions
test_to_tf_pose	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_tf_pose(self):$/;"	m	class:PoseConversions
test_to_tf_quaternion	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_tf_quaternion(self):$/;"	m	class:PoseConversions
test_to_tf_vector	geometry/tf/test/test_datatype_conversion.py	/^    def test_to_tf_vector(self):$/;"	m	class:PoseConversions
test_transformer_ros	geometry/tf/test/testPython.py	/^    def test_transformer_ros(self):$/;"	m	class:TestPython
test_transformer_wait_for_transform	geometry/tf/test/testPython.py	/^    def test_transformer_wait_for_transform(self):$/;"	m	class:TestPython
test_transformer_wait_for_transform_dedicated_thread	geometry/tf/test/testPython.py	/^    def test_transformer_wait_for_transform_dedicated_thread(self):$/;"	m	class:TestPython
test_twist	geometry/tf/test/testPython.py	/^    def test_twist(self):$/;"	m	class:TestPython
test_vector	geometry/tf/test/testBroadcaster.cpp	/^  void test_vector () {$/;"	f	class:testBroadcaster
test_wait_for_transform	geometry/tf/test/testPython.py	/^    def test_wait_for_transform(self):$/;"	m	class:TestPython
text	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	string text;$/;"	m	struct:CommentRecord	file:
text	openslam_gmapping/gridfastslam/gfsreader.h	/^	string text;$/;"	m	struct:GMapping::GFSReader::CommentRecord
tf	geometry/eigen_conversions/include/eigen_conversions/eigen_kdl.h	/^namespace tf {$/;"	n
tf	geometry/eigen_conversions/include/eigen_conversions/eigen_msg.h	/^namespace tf {$/;"	n
tf	geometry/eigen_conversions/src/eigen_kdl.cpp	/^namespace tf {$/;"	n	file:
tf	geometry/eigen_conversions/src/eigen_msg.cpp	/^namespace tf {$/;"	n	file:
tf	geometry/kdl_conversions/include/kdl_conversions/kdl_msg.h	/^namespace tf {$/;"	n
tf	geometry/kdl_conversions/src/kdl_msg.cpp	/^namespace tf {$/;"	n	file:
tf	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/LinearMath/QuadWord.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/LinearMath/Quaternion.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/LinearMath/Transform.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/LinearMath/Vector3.h	/^namespace tf{$/;"	n
tf	geometry/tf/include/tf/exceptions.h	/^namespace tf{$/;"	n
tf	geometry/tf/include/tf/message_filter.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/tf.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/time_cache.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/transform_broadcaster.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/transform_datatypes.h	/^namespace tf$/;"	n
tf	geometry/tf/include/tf/transform_listener.h	/^namespace tf{$/;"	n
tf	geometry/tf/src/tf_echo.cpp	/^  tf::TransformListener tf;$/;"	m	class:echoListener	file:
tf	geometry/tf/src/transform_broadcaster.cpp	/^namespace tf {$/;"	n	file:
tf	geometry/tf_conversions/include/tf_conversions/tf_eigen.h	/^namespace tf {$/;"	n
tf	geometry/tf_conversions/include/tf_conversions/tf_kdl.h	/^namespace tf$/;"	n
tf	geometry/tf_conversions/src/tf_eigen.cpp	/^namespace tf {$/;"	n	file:
tf	geometry/tf_conversions/src/tf_kdl.cpp	/^namespace tf {$/;"	n	file:
tf2_broadcaster_	geometry/tf/include/tf/transform_broadcaster.h	/^  tf2_ros::TransformBroadcaster tf2_broadcaster_;$/;"	m	class:tf::TransformBroadcaster
tf2_buffer_	geometry/tf/include/tf/tf.h	/^  tf2_ros::Buffer tf2_buffer_;$/;"	m	class:tf::Transformer
tf2_listener_	geometry/tf/include/tf/transform_listener.h	/^  tf2_ros::TransformListener tf2_listener_;$/;"	m	class:tf::TransformListener
tfAcos	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfAcos(tfScalar x) { if (x<tfScalar(-1))	x=tfScalar(-1); if (x>tfScalar(1))	x=tfScalar(1); return acos(x); }$/;"	f
tfAngle	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfAngle(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
tfAsin	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfAsin(tfScalar x) { if (x<tfScalar(-1))	x=tfScalar(-1); if (x>tfScalar(1))	x=tfScalar(1); return asin(x); }$/;"	f
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	114;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	116;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	143;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	145;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	71;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	73;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	92;"	d
tfAssert	geometry/tf/include/tf/LinearMath/Scalar.h	94;"	d
tfAtan	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfAtan(tfScalar x) { return atan(x); }$/;"	f
tfAtan2	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfAtan2(tfScalar x, tfScalar y) { return atan2(x, y); }$/;"	f
tfAtan2Fast	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfAtan2Fast(tfScalar y, tfScalar x) $/;"	f
tfB_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    tf::TransformBroadcaster* tfB_;$/;"	m	class:SlamGMapping
tfCos	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfCos(tfScalar x) { return cos(x); }$/;"	f
tfCross	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfCross(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
tfDegrees	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfDegrees(tfScalar x) { return x * TFSIMD_DEGS_PER_RAD; }$/;"	f
tfDistance	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfDistance(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
tfDistance2	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfDistance2(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
tfDot	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfDot(const Vector3& v1, const Vector3& v2) $/;"	f	namespace:tf
tfEqual	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE bool	tfEqual(tfScalar a, tfScalar eps) {$/;"	f
tfExp	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfExp(tfScalar x) { return exp(x); }$/;"	f
tfFabs	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfFabs(tfScalar x) { return fabs(x); }$/;"	f
tfFmod	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfFmod(tfScalar x,tfScalar y) { return fmod(x,y); }$/;"	f
tfFsel	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfFsel(tfScalar a, tfScalar b, tfScalar c)$/;"	f
tfFsel	geometry/tf/include/tf/LinearMath/Scalar.h	61;"	d
tfFsels	geometry/tf/include/tf/LinearMath/Scalar.h	248;"	d
tfFullAssert	geometry/tf/include/tf/LinearMath/Scalar.h	119;"	d
tfFullAssert	geometry/tf/include/tf/LinearMath/Scalar.h	149;"	d
tfFullAssert	geometry/tf/include/tf/LinearMath/Scalar.h	76;"	d
tfFullAssert	geometry/tf/include/tf/LinearMath/Scalar.h	97;"	d
tfFuzzyZero	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE bool      tfFuzzyZero(tfScalar x) { return tfFabs(x) < TFSIMD_EPSILON; }$/;"	f
tfGreaterEqual	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE bool	tfGreaterEqual (tfScalar a, tfScalar eps) {$/;"	f
tfIsNegative	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE int       tfIsNegative(tfScalar x) {$/;"	f
tfLikely	geometry/tf/include/tf/LinearMath/Scalar.h	122;"	d
tfLikely	geometry/tf/include/tf/LinearMath/Scalar.h	150;"	d
tfLikely	geometry/tf/include/tf/LinearMath/Scalar.h	78;"	d
tfLikely	geometry/tf/include/tf/LinearMath/Scalar.h	99;"	d
tfLog	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfLog(tfScalar x) { return log(x); }$/;"	f
tfMachineIsLittleEndian	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE bool tfMachineIsLittleEndian()$/;"	f
tfMax	geometry/tf/include/tf/LinearMath/MinMax.h	/^TFSIMD_FORCE_INLINE const T& tfMax(const T& a, const T& b) $/;"	f
tfMin	geometry/tf/include/tf/LinearMath/MinMax.h	/^TFSIMD_FORCE_INLINE const T& tfMin(const T& a, const T& b) $/;"	f
tfNormalizeAngle	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfNormalizeAngle(tfScalar angleInRadians) $/;"	f
tfPlaneSpace1	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void tfPlaneSpace1 (const Vector3& n, Vector3& p, Vector3& q)$/;"	f	namespace:tf
tfPow	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfPow(tfScalar x,tfScalar y) { return pow(x,y); }$/;"	f
tfRadians	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfRadians(tfScalar x) { return x * TFSIMD_RADS_PER_DEG; }$/;"	f
tfRecipSqrt	geometry/tf/include/tf/LinearMath/Scalar.h	201;"	d
tfScalar	geometry/tf/include/tf/LinearMath/Scalar.h	/^typedef double tfScalar;$/;"	t
tfSelect	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE float tfSelect(unsigned condition, float valueIfConditionNonZero, float valueIfConditionZero)$/;"	f
tfSelect	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE int tfSelect(unsigned condition, int valueIfConditionNonZero, int valueIfConditionZero)$/;"	f
tfSelect	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned tfSelect(unsigned condition, unsigned valueIfConditionNonZero, unsigned valueIfConditionZero) $/;"	f
tfSetMax	geometry/tf/include/tf/LinearMath/MinMax.h	/^TFSIMD_FORCE_INLINE void tfSetMax(T& a, const T& b) $/;"	f
tfSetMin	geometry/tf/include/tf/LinearMath/MinMax.h	/^TFSIMD_FORCE_INLINE void tfSetMin(T& a, const T& b) $/;"	f
tfSin	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfSin(tfScalar x) { return sin(x); }$/;"	f
tfSqrt	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfSqrt(tfScalar x) { return sqrt(x); }$/;"	f
tfSwap	geometry/tf/include/tf/LinearMath/Scalar.h	/^template<typename T> TFSIMD_FORCE_INLINE void tfSwap(T& a, T& b)$/;"	f
tfSwapEndian	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned short tfSwapEndian(short val)$/;"	f
tfSwapEndian	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned short tfSwapEndian(unsigned short val)$/;"	f
tfSwapEndian	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned tfSwapEndian(int val)$/;"	f
tfSwapEndian	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned tfSwapEndian(unsigned val)$/;"	f
tfSwapEndianDouble	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE void  tfSwapEndianDouble(double d, unsigned char* dst)$/;"	f
tfSwapEndianFloat	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE unsigned int  tfSwapEndianFloat(float d)$/;"	f
tfSwapScalarEndian	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	tfSwapScalarEndian(const tfScalar& sourceVal, tfScalar& destVal)$/;"	f	namespace:tf
tfSwapVector3Endian	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	tfSwapVector3Endian(const Vector3& sourceVec, Vector3& destVec)$/;"	f	namespace:tf
tfTan	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE tfScalar tfTan(tfScalar x) { return tan(x); }$/;"	f
tfTransform_H	geometry/tf/include/tf/LinearMath/Transform.h	18;"	d
tfTriple	geometry/tf/include/tf/LinearMath/Vector3.h	/^tfTriple(const Vector3& v1, const Vector3& v2, const Vector3& v3)$/;"	f	namespace:tf
tfTypedObject	geometry/tf/include/tf/LinearMath/Scalar.h	/^	tfTypedObject(int objectType)$/;"	f	struct:tfTypedObject
tfTypedObject	geometry/tf/include/tf/LinearMath/Scalar.h	/^struct tfTypedObject$/;"	s
tfUnSwapVector3Endian	geometry/tf/include/tf/LinearMath/Vector3.h	/^TFSIMD_FORCE_INLINE void	tfUnSwapVector3Endian(Vector3& vector)$/;"	f	namespace:tf
tfUnlikely	geometry/tf/include/tf/LinearMath/Scalar.h	100;"	d
tfUnlikely	geometry/tf/include/tf/LinearMath/Scalar.h	123;"	d
tfUnlikely	geometry/tf/include/tf/LinearMath/Scalar.h	151;"	d
tfUnlikely	geometry/tf/include/tf/LinearMath/Scalar.h	79;"	d
tfUnswapEndianDouble	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE double tfUnswapEndianDouble(const unsigned char *src) $/;"	f
tfUnswapEndianFloat	geometry/tf/include/tf/LinearMath/Scalar.h	/^TFSIMD_FORCE_INLINE float tfUnswapEndianFloat(unsigned int a) $/;"	f
tfVector4	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfVector4() {}$/;"	f	class:tf::tfVector4
tfVector4	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfVector4(const tfScalar& x, const tfScalar& y, const tfScalar& z,const tfScalar& w) $/;"	f	class:tf::tfVector4
tfVector4	geometry/tf/include/tf/LinearMath/Vector3.h	/^class tfVector4 : public Vector3$/;"	c	namespace:tf
tf_	geometry/tf/include/tf/message_filter.h	/^  Transformer& tf_; \/\/\/< The Transformer used to determine if transformation data is available$/;"	m	class:tf::MessageFilter
tf_	geometry/tf/src/tf_monitor.cpp	/^  TransformListener tf_;$/;"	m	class:TFMonitor	file:
tf_	geometry/tf/test/transform_twist_test.cpp	/^  tf::TransformListener tf_;$/;"	m	class:TransformTwistAngularTest	file:
tf_	geometry/tf/test/transform_twist_test.cpp	/^  tf::TransformListener tf_;$/;"	m	class:TransformTwistLinearTest	file:
tf_	geometry/tf/test/velocity_test.cpp	/^  tf::Transformer tf_;$/;"	m	class:AngularVelocitySquareTest	file:
tf_	geometry/tf/test/velocity_test.cpp	/^  tf::Transformer tf_;$/;"	m	class:LinearVelocitySquareTest	file:
tf_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    tf::TransformListener tf_;$/;"	m	class:SlamGMapping
tf_connection_	geometry/tf/include/tf/message_filter.h	/^  boost::signals2::connection tf_connection_;$/;"	m	class:tf::MessageFilter
tf_delay_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double tf_delay_;   $/;"	m	class:SlamGMapping
tf_errors	geometry/tf/src/tf/tfwtf.py	/^tf_errors = [$/;"	v
tf_prefix_	geometry/tf/include/tf/tf.h	/^  std::string tf_prefix_;$/;"	m	class:tf::Transformer
tf_warnings	geometry/tf/src/tf/tfwtf.py	/^tf_warnings = [$/;"	v
tfl	geometry/tf/test/python_debug_test.py	/^    tfl = tf.TransformListener()$/;"	v
theta	openslam_gmapping/include/gmapping/utils/point.h	/^	A theta;$/;"	m	struct:GMapping::orientedpoint
throttle_scans_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    int throttle_scans_;$/;"	m	class:SlamGMapping
time	geometry/tf/src/tf.cpp	/^  ros::Time time;$/;"	m	struct:TransformAccum	file:
time	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	double time;$/;"	m	struct:Record	file:
time	openslam_gmapping/gridfastslam/gfsreader.h	/^	double time;$/;"	m	struct:GMapping::GFSReader::Record
time_tolerance_	geometry/tf/include/tf/message_filter.h	/^  ros::Duration time_tolerance_; \/\/\/< Provide additional tolerance on time for messages which are stamped but can have associated duration$/;"	m	class:tf::MessageFilter
timer	openslam_gmapping/gui/qgraphpainter.h	/^		int timer;$/;"	m	class:QGraphPainter
timer	openslam_gmapping/gui/qmappainter.h	/^		int timer;$/;"	m	class:QMapPainter
timer	openslam_gmapping/gui/qparticleviewer.h	/^		int timer;$/;"	m	class:GMapping::QParticleViewer
timerEvent	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::timerEvent(QTimerEvent * te) {$/;"	f	class:QGraphPainter
timerEvent	openslam_gmapping/gui/qmappainter.cpp	/^void QMapPainter::timerEvent(QTimerEvent * te) {$/;"	f	class:QMapPainter
timerEvent	openslam_gmapping/gui/qparticleviewer.cpp	/^void QParticleViewer::timerEvent(QTimerEvent * te) {$/;"	f	class:QParticleViewer
timesTranspose	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::timesTranspose(const Matrix3x3& m) const$/;"	f	class:tf::Matrix3x3
tis	openslam_gmapping/gui/qparticleviewer.h	/^		QTextStream* tis;$/;"	m	class:GMapping::QParticleViewer
title	openslam_gmapping/gui/qgraphpainter.h	/^		QString title;$/;"	m	class:QGraphPainter
tm	geometry/tf/scripts/python_benchmark.py	/^tm = tfMessage([mkm() for i in range(20)])$/;"	v
toDoubleArray	openslam_gmapping/include/gmapping/grid/map.h	/^DoubleArray2D* Map<Cell,Storage,isClass>::toDoubleArray() const{$/;"	f	class:GMapping::Map
toDoubleMap	openslam_gmapping/include/gmapping/grid/map.h	/^Map<double, DoubleArray2D, false>* Map<Cell,Storage,isClass>::toDoubleMap() const{$/;"	f	class:GMapping::Map
toLogForm	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^void toLogForm(OutputIterator& out, const Iterator & begin, const Iterator & end, Numeric lmax){$/;"	f
toLogForm	openslam_gmapping/particlefilter/pf.h	/^void toLogForm(OutputIterator& out, const Iterator & begin, const Iterator & end, Numeric lmax){$/;"	f
toMatrix	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def toMatrix(f):$/;"	f
toMsg	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def toMsg(f):$/;"	f
toNormalForm	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^double toNormalForm(OutputIterator& out, const Iterator & begin, const Iterator & end){$/;"	f
toNormalForm	openslam_gmapping/particlefilter/pf.h	/^double toNormalForm(OutputIterator& out, const Iterator & begin, const Iterator & end){$/;"	f
toTf	geometry/tf_conversions/src/tf_conversions/posemath.py	/^def toTf(f):$/;"	f
took	geometry/tf/scripts/python_benchmark.py	/^took = time.time() - started$/;"	v
tql2	openslam_gmapping/scanmatcher/eig3.cpp	/^static void tql2(double V[n][n], double d[n], double e[n]) {$/;"	f	file:
tr	geometry/tf/test/python_debug_test.py	/^    tr = tf.TransformStamped()$/;"	v
trajectoryEntropy	openslam_gmapping/gridfastslam/gfsreader.h	/^	double trajectoryEntropy;$/;"	m	struct:GMapping::GFSReader::EntropyRecord
trajectoryPoints	openslam_gmapping/gui/qnavigatorwidget.h	/^		std::list<GMapping::IntPoint > trajectoryPoints;$/;"	m	class:QNavigatorWidget
trajectoryPoints	openslam_gmapping/gui/qslamandnavwidget.h	/^		std::list<GMapping::IntPoint > trajectoryPoints;$/;"	m	class:QSLAMandNavWidget
trajectorySent	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool trajectorySent;$/;"	m	class:QNavigatorWidget
trajectorySent	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool trajectorySent;$/;"	m	class:QSLAMandNavWidget
transformEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void transformEigenToKDL(const Eigen::Affine3d &e, KDL::Frame &k)$/;"	f	namespace:tf
transformEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void transformEigenToKDL(const Eigen::Isometry3d &e, KDL::Frame &k)$/;"	f	namespace:tf
transformEigenToKDLImpl	geometry/eigen_conversions/src/eigen_kdl.cpp	/^  void transformEigenToKDLImpl(const T &e, KDL::Frame &k)$/;"	f	namespace:tf::__anon3
transformEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void transformEigenToMsg(const Eigen::Affine3d &e, geometry_msgs::Transform &m)$/;"	f	namespace:tf
transformEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void transformEigenToMsg(const Eigen::Isometry3d &e, geometry_msgs::Transform &m)$/;"	f	namespace:tf
transformEigenToMsgImpl	geometry/eigen_conversions/src/eigen_msg.cpp	/^  void transformEigenToMsgImpl(const T &e, geometry_msgs::Transform &m)$/;"	f	namespace:tf::__anon2
transformEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void transformEigenToTF(const Eigen::Affine3d &e, tf::Transform &t)$/;"	f	namespace:tf
transformEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void transformEigenToTF(const Eigen::Isometry3d &e, tf::Transform &t)$/;"	f	namespace:tf
transformEigenToTFImpl	geometry/tf_conversions/src/tf_eigen.cpp	/^    void transformEigenToTFImpl(const T &e, tf::Transform &t)$/;"	f	namespace:tf::__anon4
transformKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void transformKDLToEigen(const KDL::Frame &k, Eigen::Affine3d &e)$/;"	f	namespace:tf
transformKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void transformKDLToEigen(const KDL::Frame &k, Eigen::Isometry3d &e)$/;"	f	namespace:tf
transformKDLToEigenImpl	geometry/eigen_conversions/src/eigen_kdl.cpp	/^  void transformKDLToEigenImpl(const KDL::Frame &k, T &e)$/;"	f	namespace:tf::__anon3
transformKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void transformKDLToMsg(const KDL::Frame &k, geometry_msgs::Transform &m)$/;"	f	namespace:tf
transformKDLToTF	geometry/tf_conversions/src/tf_kdl.cpp	/^  void transformKDLToTF(const KDL::Frame &k, tf::Transform &t)$/;"	f	namespace:tf
transformMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void transformMsgToEigen(const geometry_msgs::Transform &m, Eigen::Affine3d &e)$/;"	f	namespace:tf
transformMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void transformMsgToEigen(const geometry_msgs::Transform &m, Eigen::Isometry3d &e)$/;"	f	namespace:tf
transformMsgToEigenImpl	geometry/eigen_conversions/src/eigen_msg.cpp	/^  void transformMsgToEigenImpl(const geometry_msgs::Transform &m, T &e)$/;"	f	namespace:tf::__anon2
transformMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void transformMsgToKDL(const geometry_msgs::Transform &m, KDL::Frame &k)$/;"	f	namespace:tf
transformMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void transformMsgToTF(const geometry_msgs::Transform& msg, Transform& bt)$/;"	f	namespace:tf
transformPoint	geometry/tf/src/tf.cpp	/^void Transformer::transformPoint(const std::string& target_frame, const Stamped<Point>& stamped_in, Stamped<Point>& stamped_out) const$/;"	f	class:Transformer
transformPoint	geometry/tf/src/tf.cpp	/^void Transformer::transformPoint(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:Transformer
transformPoint	geometry/tf/src/tf/listener.py	/^    def transformPoint(self, target_frame, ps):$/;"	m	class:TransformerROS
transformPoint	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPoint(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:TransformListener
transformPoint	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPoint(const std::string& target_frame,$/;"	f	class:TransformListener
transformPointCloud	geometry/tf/src/tf/listener.py	/^    def transformPointCloud(self, target_frame, point_cloud):$/;"	m	class:TransformerROS
transformPointCloud	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPointCloud(const std::string & target_frame, const sensor_msgs::PointCloud & cloudIn, sensor_msgs::PointCloud & cloudOut) const$/;"	f	class:TransformListener
transformPointCloud	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPointCloud(const std::string & target_frame, const tf::Transform& net_transform,$/;"	f	class:TransformListener
transformPointCloud	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPointCloud(const std::string& target_frame, const ros::Time& target_time, $/;"	f	class:TransformListener
transformPointMatVec	geometry/tf/src/transform_listener.cpp	/^inline void transformPointMatVec(const tf::Vector3 &origin, const tf::Matrix3x3 &basis, const geometry_msgs::Point32 &in, geometry_msgs::Point32 &out)$/;"	f
transformPose	geometry/tf/src/tf.cpp	/^void Transformer::transformPose(const std::string& target_frame, const Stamped<Pose>& stamped_in, Stamped<Pose>& stamped_out) const$/;"	f	class:Transformer
transformPose	geometry/tf/src/tf.cpp	/^void Transformer::transformPose(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:Transformer
transformPose	geometry/tf/src/tf/listener.py	/^    def transformPose(self, target_frame, ps):$/;"	m	class:TransformerROS
transformPose	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPose(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:TransformListener
transformPose	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformPose(const std::string& target_frame,$/;"	f	class:TransformListener
transformQuaternion	geometry/tf/src/tf.cpp	/^void Transformer::transformQuaternion(const std::string& target_frame, const Stamped<Quaternion>& stamped_in, Stamped<Quaternion>& stamped_out) const$/;"	f	class:Transformer
transformQuaternion	geometry/tf/src/tf.cpp	/^void Transformer::transformQuaternion(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:Transformer
transformQuaternion	geometry/tf/src/tf/listener.py	/^    def transformQuaternion(self, target_frame, ps):$/;"	m	class:TransformerROS
transformQuaternion	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformQuaternion(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:TransformListener
transformQuaternion	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformQuaternion(const std::string& target_frame,$/;"	f	class:TransformListener
transformStampedMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void transformStampedMsgToTF(const geometry_msgs::TransformStamped & msg, StampedTransform& bt)$/;"	f	namespace:tf
transformStampedTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void transformStampedTFToMsg(const StampedTransform& bt, geometry_msgs::TransformStamped & msg)$/;"	f	namespace:tf
transformTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void transformTFToEigen(const tf::Transform &t, Eigen::Affine3d &e)$/;"	f	namespace:tf
transformTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void transformTFToEigen(const tf::Transform &t, Eigen::Isometry3d &e)$/;"	f	namespace:tf
transformTFToEigenImpl	geometry/tf_conversions/src/tf_eigen.cpp	/^    void transformTFToEigenImpl(const tf::Transform &t, Transform & e)$/;"	f	namespace:tf::__anon4
transformTFToKDL	geometry/tf_conversions/src/tf_kdl.cpp	/^  void transformTFToKDL(const tf::Transform &t, KDL::Frame &k)$/;"	f	namespace:tf
transformTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void transformTFToMsg(const Transform& bt, geometry_msgs::Transform& msg)$/;"	f	namespace:tf
transformVector	geometry/tf/src/tf.cpp	/^void Transformer::transformVector(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:Transformer
transformVector	geometry/tf/src/tf.cpp	/^void Transformer::transformVector(const std::string& target_frame,$/;"	f	class:Transformer
transformVector	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformVector(const std::string& target_frame, const ros::Time& target_time,$/;"	f	class:TransformListener
transformVector	geometry/tf/src/transform_listener.cpp	/^void TransformListener::transformVector(const std::string& target_frame,$/;"	f	class:TransformListener
transformVector3	geometry/tf/src/tf/listener.py	/^    def transformVector3(self, target_frame, v3s):$/;"	m	class:TransformerROS
transform_	geometry/tf/src/static_transform_publisher.cpp	/^  tf::StampedTransform transform_;$/;"	m	class:TransformSender	file:
transform_message_count_	geometry/tf/include/tf/message_filter.h	/^  uint64_t transform_message_count_;$/;"	m	class:tf::MessageFilter
transform_publish_period_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double transform_publish_period_;$/;"	m	class:SlamGMapping
transform_stamped	geometry/tf/test/method_test.py	/^    transform_stamped = tf.TransformStamped()$/;"	v
transform_stamped	geometry/tf/test/python_debug_test.py	/^    transform_stamped = tf.TransformStamped()$/;"	v
transform_thread_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    boost::thread* transform_thread_;$/;"	m	class:SlamGMapping
transformsChanged	geometry/tf/include/tf/message_filter.h	/^  void transformsChanged()$/;"	f	class:tf::MessageFilter
translation_	geometry/tf/include/tf/time_cache.h	/^  tf::Vector3 translation_;$/;"	m	class:tf::TransformStorage
translation_from_matrix	geometry/tf/src/tf/transformations.py	/^def translation_from_matrix(matrix):$/;"	f
translation_matrix	geometry/tf/src/tf/transformations.py	/^def translation_matrix(direction):$/;"	f
translational_update_distance_	geometry/tf/src/change_notifier.cpp	/^  double translational_update_distance_;$/;"	m	class:FramePair	file:
transpose	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::transpose() const $/;"	f	class:tf::Matrix3x3
transpose	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X> DMatrix<X>::transpose() const {$/;"	f	class:GMapping::DMatrix
transposeTimes	geometry/tf/include/tf/LinearMath/Matrix3x3.h	/^Matrix3x3::transposeTimes(const Matrix3x3& m) const$/;"	f	class:tf::Matrix3x3
tred2	openslam_gmapping/scanmatcher/eig3.cpp	/^static void tred2(double V[n][n], double d[n], double e[n]) {$/;"	f	file:
triple	geometry/tf/include/tf/LinearMath/Vector3.h	/^	TFSIMD_FORCE_INLINE tfScalar triple(const Vector3& v1, const Vector3& v2) const$/;"	f	class:tf::Vector3
truePos	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	bool truePos;$/;"	m	struct:PoseRecord	file:
truePos	openslam_gmapping/gridfastslam/gfsreader.h	/^	bool truePos;$/;"	m	struct:GMapping::GFSReader::PoseRecord
tt	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
tw_	geometry/tf/test/transform_twist_test.cpp	/^  geometry_msgs::TwistStamped tw_;$/;"	m	class:TransformTwistLinearTest	file:
tw_x	geometry/tf/test/transform_twist_test.cpp	/^  geometry_msgs::TwistStamped tw_x, tw_y, tw_z;$/;"	m	class:TransformTwistAngularTest	file:
tw_y	geometry/tf/test/transform_twist_test.cpp	/^  geometry_msgs::TwistStamped tw_x, tw_y, tw_z;$/;"	m	class:TransformTwistAngularTest	file:
tw_z	geometry/tf/test/transform_twist_test.cpp	/^  geometry_msgs::TwistStamped tw_x, tw_y, tw_z;$/;"	m	class:TransformTwistAngularTest	file:
twistEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void twistEigenToKDL(const Eigen::Matrix<double, 6, 1> &e, KDL::Twist &k)$/;"	f	namespace:tf
twistEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void twistEigenToMsg(const Eigen::Matrix<double,6,1> &e, geometry_msgs::Twist &m)$/;"	f	namespace:tf
twistKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void twistKDLToEigen(const KDL::Twist &k, Eigen::Matrix<double, 6, 1> &e)$/;"	f	namespace:tf
twistKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void twistKDLToMsg(const KDL::Twist &t, geometry_msgs::Twist &m)$/;"	f	namespace:tf
twistMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void twistMsgToEigen(const geometry_msgs::Twist &m, Eigen::Matrix<double,6,1> &e)$/;"	f	namespace:tf
twistMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void twistMsgToKDL(const geometry_msgs::Twist &m, KDL::Twist &t)$/;"	f	namespace:tf
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::FLOAT32> { typedef float    type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::FLOAT64> { typedef double   type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT16>   { typedef int16_t  type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT32>   { typedef int32_t  type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::INT8>    { typedef int8_t   type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT16>  { typedef uint16_t type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT32>  { typedef uint32_t type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
type	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct pointFieldTypeAsType<sensor_msgs::PointField::UINT8>   { typedef uint8_t  type; };$/;"	t	struct:sensor_msgs::pointFieldTypeAsType
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<double>   { static const uint8_t value = sensor_msgs::PointField::FLOAT64; };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<float>    { static const uint8_t value = sensor_msgs::PointField::FLOAT32; };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int16_t>  { static const uint8_t value = sensor_msgs::PointField::INT16;   };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int32_t>  { static const uint8_t value = sensor_msgs::PointField::INT32;   };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int8_t>   { static const uint8_t value = sensor_msgs::PointField::INT8;    };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint16_t> { static const uint8_t value = sensor_msgs::PointField::UINT16;  };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint32_t> { static const uint8_t value = sensor_msgs::PointField::UINT32;  };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint8_t>  { static const uint8_t value = sensor_msgs::PointField::UINT8;   };$/;"	s	namespace:sensor_msgs
typeAsPointFieldType	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<typename T> struct typeAsPointFieldType {};$/;"	s	namespace:sensor_msgs
uint	openslam_gmapping/include/gmapping/utils/gvalues.h	/^  typedef unsigned int uint;$/;"	t
ul	openslam_gmapping/utils/orientedboundingbox.h	/^  Point ul;$/;"	m	class:GMapping::OrientedBoundingBox
uniform_resampler	openslam_gmapping/include/gmapping/particlefilter/particlefilter.h	/^struct uniform_resampler{$/;"	s
unit_vector	geometry/tf/src/tf/transformations.py	/^def unit_vector(data, axis=None, out=None):$/;"	f
unknown_ptr	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	static PointAccumulator* unknown_ptr;$/;"	m	struct:GMapping::PointAccumulator
unknown_ptr	openslam_gmapping/scanmatcher/smmap.cpp	/^PointAccumulator* PointAccumulator::unknown_ptr=0;$/;"	m	class:GMapping::PointAccumulator	file:
unlock	openslam_gmapping/carmenwrapper/carmenwrapper.cpp	/^void CarmenWrapper::unlock(){$/;"	f	class:CarmenWrapper
unnamespaced_rules	geometry/tf/scripts/bullet_migration_sed.py	/^unnamespaced_rules = [$/;"	v
update	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^void PointAccumulator::update(bool value, const Point& p){$/;"	f	class:GMapping::PointAccumulator
updateBeamsLookup	openslam_gmapping/sensor/sensor_range/rangesensor.cpp	/^void RangeSensor::updateBeamsLookup(){$/;"	f	class:GMapping::RangeSensor
updateMap	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::updateMap(const sensor_msgs::LaserScan& scan)$/;"	f	class:SlamGMapping
updateTreeWeights	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^void  GridSlamProcessor::updateTreeWeights(bool weightsAlreadyNormalized){$/;"	f	class:GMapping::GridSlamProcessor
ur	openslam_gmapping/utils/orientedboundingbox.h	/^  Point ur;$/;"	m	class:GMapping::OrientedBoundingBox
urange	openslam_gmapping/gui/qparticleviewer.h	/^			double maxrange, urange;$/;"	m	struct:GMapping::QParticleViewer::MatchingParameters
useICP	openslam_gmapping/scanmatcher/scanmatcherprocessor.h	/^		bool useICP;$/;"	m	class:GMapping::ScanMatcherProcessor
using_specific_chain_	geometry/tf/src/tf_monitor.cpp	/^  bool using_specific_chain_;$/;"	m	class:TFMonitor	file:
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<double>   { static const uint8_t value = sensor_msgs::PointField::FLOAT64; };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<float>    { static const uint8_t value = sensor_msgs::PointField::FLOAT32; };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int16_t>  { static const uint8_t value = sensor_msgs::PointField::INT16;   };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int32_t>  { static const uint8_t value = sensor_msgs::PointField::INT32;   };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<int8_t>   { static const uint8_t value = sensor_msgs::PointField::INT8;    };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint16_t> { static const uint8_t value = sensor_msgs::PointField::UINT16;  };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint32_t> { static const uint8_t value = sensor_msgs::PointField::UINT32;  };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^  template<> struct typeAsPointFieldType<uint8_t>  { static const uint8_t value = sensor_msgs::PointField::UINT8;   };$/;"	m	struct:sensor_msgs::typeAsPointFieldType
value	openslam_gmapping/grid/map_test.cpp	/^	int value;$/;"	m	struct:SimpleCell	file:
valueAdded	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::valueAdded(double v){$/;"	f	class:QGraphPainter
valueAdded	openslam_gmapping/gui/qgraphpainter.cpp	/^void QGraphPainter::valueAdded(double v, double _min, double _max){$/;"	f	class:QGraphPainter
values	openslam_gmapping/gui/qgraphpainter.h	/^		DoubleDeque values;$/;"	m	class:QGraphPainter
vector3MsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void vector3MsgToTF(const geometry_msgs::Vector3& msg_v, Vector3& bt_v) {bt_v = Vector3(msg_v.x, msg_v.y, msg_v.z);};$/;"	f	namespace:tf
vector3StampedMsgToTF	geometry/tf/include/tf/transform_datatypes.h	/^static inline void vector3StampedMsgToTF(const geometry_msgs::Vector3Stamped & msg, Stamped<Vector3>& bt)$/;"	f	namespace:tf
vector3StampedTFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void vector3StampedTFToMsg(const Stamped<Vector3>& bt, geometry_msgs::Vector3Stamped & msg)$/;"	f	namespace:tf
vector3TFToMsg	geometry/tf/include/tf/transform_datatypes.h	/^static inline void vector3TFToMsg(const Vector3& bt_v, geometry_msgs::Vector3& msg_v) {msg_v.x = bt_v.x(); msg_v.y = bt_v.y(); msg_v.z = bt_v.z();};$/;"	f	namespace:tf
vectorEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void vectorEigenToKDL(const Eigen::Matrix<double, 3, 1> &e, KDL::Vector &k)$/;"	f	namespace:tf
vectorEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void vectorEigenToMsg(const Eigen::Vector3d &e, geometry_msgs::Vector3 &m)$/;"	f	namespace:tf
vectorEigenToTF	geometry/tf_conversions/src/tf_eigen.cpp	/^  void vectorEigenToTF(const Eigen::Vector3d& e, tf::Vector3& t)$/;"	f	namespace:tf
vectorKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void vectorKDLToEigen(const KDL::Vector &k, Eigen::Matrix<double, 3, 1> &e)$/;"	f	namespace:tf
vectorKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void vectorKDLToMsg(const KDL::Vector &k, geometry_msgs::Vector3 &m)$/;"	f	namespace:tf
vectorKDLToTF	geometry/tf_conversions/src/tf_kdl.cpp	/^  void vectorKDLToTF(const KDL::Vector& k, tf::Vector3& t)$/;"	f	namespace:tf
vectorMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void vectorMsgToEigen(const geometry_msgs::Vector3 &m, Eigen::Vector3d &e)$/;"	f	namespace:tf
vectorMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void vectorMsgToKDL(const geometry_msgs::Vector3 &m, KDL::Vector &k)$/;"	f	namespace:tf
vectorTFToEigen	geometry/tf_conversions/src/tf_eigen.cpp	/^  void vectorTFToEigen(const tf::Vector3& t, Eigen::Vector3d& e)$/;"	f	namespace:tf
vectorTFToKDL	geometry/tf_conversions/src/tf_kdl.cpp	/^  void vectorTFToKDL(const tf::Vector3& t, KDL::Vector& k)$/;"	f	namespace:tf
vector_norm	geometry/tf/src/tf/transformations.py	/^def vector_norm(data, axis=None, out=None):$/;"	f
version	geometry/tf/conf.py	/^version = '0.1'$/;"	v
version	geometry/tf_conversions/conf.py	/^version = '0.1'$/;"	v
viewCenter	openslam_gmapping/gui/qparticleviewer.h	/^		Point viewCenter;$/;"	m	class:GMapping::QParticleViewer
visitCounter	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      mutable unsigned int visitCounter;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
visits	openslam_gmapping/include/gmapping/scanmatcher/smmap.h	/^	int n, visits;$/;"	m	struct:GMapping::PointAccumulator
w	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& w() const { return m_floats[3]; }$/;"	f	class:tf::Vector3
w	openslam_gmapping/particlefilter/particlefilter_test.cpp	/^	double w;$/;"	m	struct:Particle	file:
w	openslam_gmapping/particlefilter/range_bearing.cpp	/^	double w;$/;"	m	struct:Particle	file:
waitForTransform	geometry/tf/src/tf.cpp	/^bool Transformer::waitForTransform(const std::string& target_frame, const std::string& source_frame,$/;"	f	class:Transformer
waitForTransform	geometry/tf/src/tf.cpp	/^bool Transformer::waitForTransform(const std::string& target_frame,const ros::Time& target_time, const std::string& source_frame,$/;"	f	class:Transformer
waitForTransform	geometry/tf/src/tf/listener.py	/^    def waitForTransform(self, target_frame, source_frame, time, timeout, polling_sleep_duration=None):$/;"	m	class:Transformer
waitForTransformFull	geometry/tf/src/tf/listener.py	/^    def waitForTransformFull(self, target_frame, target_time, source_frame, source_time, fixed_frame, timeout, polling_sleep_duration=None):$/;"	m	class:Transformer
wantsQuit	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool wantsQuit;$/;"	m	class:QNavigatorWidget
wantsQuit	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool wantsQuit;$/;"	m	class:QSLAMandNavWidget
warned_about_empty_frame_id_	geometry/tf/include/tf/message_filter.h	/^  bool warned_about_empty_frame_id_;$/;"	m	class:tf::MessageFilter
warned_about_unresolved_name_	geometry/tf/include/tf/message_filter.h	/^  bool warned_about_unresolved_name_;$/;"	m	class:tf::MessageFilter
weight	openslam_gmapping/gridfastslam/gfsreader.h	/^	double weight;$/;"	m	struct:GMapping::GFSReader::LaserRecord
weight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double weight;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
weight	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double weight;$/;"	m	struct:GMapping::GridSlamProcessor::TNode
weightSum	openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h	/^      double weightSum;$/;"	m	struct:GMapping::GridSlamProcessor::Particle
weightSums	openslam_gmapping/gui/gsp_thread.h	/^			std::vector<double> weightSums;$/;"	m	struct:GridSlamProcessorThread::ParticleMoveEvent
weightSums	openslam_gmapping/gui/gsp_thread.h	/^		std::vector<double> weightSums;$/;"	m	struct:GridSlamProcessorThread
weights	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	vector<double> weights;$/;"	m	struct:ScanMatchRecord	file:
weights	openslam_gmapping/gridfastslam/gfsreader.h	/^	vector<double> weights;$/;"	m	struct:GMapping::GFSReader::ScanMatchRecord
world2map	openslam_gmapping/include/gmapping/grid/map.h	/^		inline IntPoint world2map(double x, double y) const $/;"	f	class:GMapping::Map
world2map	openslam_gmapping/include/gmapping/grid/map.h	/^IntPoint Map<Cell,Storage,isClass>::world2map(const Point& p) const{$/;"	f	class:GMapping::Map
wrenchEigenToKDL	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void wrenchEigenToKDL(const Eigen::Matrix<double, 6, 1> &e, KDL::Wrench &k)$/;"	f	namespace:tf
wrenchEigenToMsg	geometry/eigen_conversions/src/eigen_msg.cpp	/^void wrenchEigenToMsg(const Eigen::Matrix<double,6,1> &e, geometry_msgs::Wrench &m)$/;"	f	namespace:tf
wrenchKDLToEigen	geometry/eigen_conversions/src/eigen_kdl.cpp	/^void wrenchKDLToEigen(const KDL::Wrench &k, Eigen::Matrix<double, 6, 1> &e)$/;"	f	namespace:tf
wrenchKDLToMsg	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void wrenchKDLToMsg(const KDL::Wrench &k, geometry_msgs::Wrench &m)$/;"	f	namespace:tf
wrenchMsgToEigen	geometry/eigen_conversions/src/eigen_msg.cpp	/^void wrenchMsgToEigen(const geometry_msgs::Wrench &m, Eigen::Matrix<double,6,1> &e)$/;"	f	namespace:tf
wrenchMsgToKDL	geometry/kdl_conversions/src/kdl_msg.cpp	/^  void wrenchMsgToKDL(const geometry_msgs::Wrench &m, KDL::Wrench &k)$/;"	f	namespace:tf
write	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void write(ostream& os){$/;"	f	struct:CommentRecord
write	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void write(ostream& os){$/;"	f	struct:LaserRecord
write	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void write(ostream& os){$/;"	f	struct:NeffRecord
write	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void write(ostream& os){$/;"	f	struct:PoseRecord
write	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual void write(ostream& os){};$/;"	f	struct:Record
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void CommentRecord::write(ostream& os){$/;"	f	class:GMapping::GFSReader::CommentRecord
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void EntropyRecord::write(ostream& os){$/;"	f	class:GMapping::GFSReader::EntropyRecord
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void LaserRecord::write(ostream& os){$/;"	f	class:GMapping::GFSReader::LaserRecord
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void NeffRecord::write(ostream& os){$/;"	f	class:GMapping::GFSReader::NeffRecord
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void PoseRecord::write(ostream& os){$/;"	f	class:GMapping::GFSReader::PoseRecord
write	openslam_gmapping/gridfastslam/gfsreader.cpp	/^void Record::write(ostream& os){};$/;"	f	class:GMapping::GFSReader::Record
writeImages	openslam_gmapping/gui/qnavigatorwidget.h	/^		bool writeImages;$/;"	m	class:QNavigatorWidget
writeImages	openslam_gmapping/gui/qslamandnavwidget.h	/^		bool writeImages;$/;"	m	class:QSLAMandNavWidget
writePointCloud2BufferValue	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^    inline void writePointCloud2BufferValue(unsigned char* data_ptr, T value){$/;"	f	namespace:sensor_msgs
writePointCloud2BufferValue	common_msgs/sensor_msgs/include/sensor_msgs/point_field_conversion.h	/^    inline void writePointCloud2BufferValue(unsigned char* data_ptr, const unsigned char datatype, T value){$/;"	f	namespace:sensor_msgs
writeToFile	openslam_gmapping/gui/qparticleviewer.h	/^		int writeToFile;$/;"	m	class:GMapping::QParticleViewer
write_file	common_msgs/actionlib_msgs/scripts/genaction.py	/^def write_file(filename, text):$/;"	f
x	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& x() const { return m_floats[0]; }$/;"	f	class:tf::Vector3
x	openslam_gmapping/include/gmapping/utils/point.h	/^	T x, y;$/;"	m	struct:GMapping::point
x	openslam_gmapping/utils/datasmoother.h	/^    double x;$/;"	m	struct:GMapping::DataSmoother::DataPoint
xf	geometry/tf/src/tf/listener.py	/^        def xf(p):$/;"	f	function:TransformerROS.transformPointCloud
xmax	openslam_gmapping/gui/gsp_thread.h	/^		double xmax;$/;"	m	struct:GridSlamProcessorThread
xmax	openslam_gmapping/gui/qparticleviewer.h	/^			double xmin, ymin, xmax, ymax, delta;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
xmax_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double xmax_;$/;"	m	class:SlamGMapping
xmin	openslam_gmapping/gui/gsp_thread.h	/^		double xmin;$/;"	m	struct:GridSlamProcessorThread
xmin	openslam_gmapping/gui/qparticleviewer.h	/^			double xmin, ymin, xmax, ymax, delta;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
xmin_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double xmin_;$/;"	m	class:SlamGMapping
xt	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
xx	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
xy	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
xyz_to_mat44	geometry/tf/src/tf/listener.py	/^def xyz_to_mat44(pos):$/;"	f
xyzw_to_mat44	geometry/tf/src/tf/listener.py	/^def xyzw_to_mat44(ori):$/;"	f
y	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& y() const { return m_floats[1]; }$/;"	f	class:tf::Vector3
y	openslam_gmapping/include/gmapping/utils/point.h	/^	T x, y;$/;"	m	struct:GMapping::point
y	openslam_gmapping/utils/datasmoother.h	/^    double y;$/;"	m	struct:GMapping::DataSmoother::DataPoint
ymax	openslam_gmapping/gui/gsp_thread.h	/^		double ymax;$/;"	m	struct:GridSlamProcessorThread
ymax	openslam_gmapping/gui/qparticleviewer.h	/^			double xmin, ymin, xmax, ymax, delta;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
ymax_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double ymax_;$/;"	m	class:SlamGMapping
ymin	openslam_gmapping/gui/gsp_thread.h	/^		double ymin;$/;"	m	struct:GridSlamProcessorThread
ymin	openslam_gmapping/gui/qparticleviewer.h	/^			double xmin, ymin, xmax, ymax, delta;$/;"	m	struct:GMapping::QParticleViewer::StartParameters
ymin_	slam_gmapping/gmapping/src/slam_gmapping.h	/^    double ymin_;$/;"	m	class:SlamGMapping
yt	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
yy	openslam_gmapping/include/gmapping/utils/stat.h	/^	double xx, yy, tt, xy, xt, yt;$/;"	m	struct:GMapping::Covariance3
z	geometry/tf/include/tf/LinearMath/Vector3.h	/^		TFSIMD_FORCE_INLINE const tfScalar& z() const { return m_floats[2]; }$/;"	f	class:tf::Vector3
zero	openslam_gmapping/include/gmapping/utils/stat.h	/^	static Covariance3 zero;$/;"	m	struct:GMapping::Covariance3
~AngularVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^  virtual ~AngularVelocitySquareTest() {$/;"	f	class:AngularVelocitySquareTest
~Array2D	openslam_gmapping/include/gmapping/grid/array2d.h	/^Array2D<Cell,debug>::~Array2D(){$/;"	f	class:GMapping::Array2D
~Configuration	openslam_gmapping/log/configuration.cpp	/^Configuration::~Configuration(){$/;"	f	class:GMapping::Configuration
~DMatrix	openslam_gmapping/utils/dmatrix.h	/^template <class X> DMatrix<X>::~DMatrix() {$/;"	f	class:GMapping::DMatrix
~DataSmoother	openslam_gmapping/utils/datasmoother.h	/^  virtual ~DataSmoother() {$/;"	f	class:GMapping::DataSmoother
~Event	openslam_gmapping/gui/gsp_thread.cpp	/^GridSlamProcessorThread::Event::~Event(){}$/;"	f	class:GridSlamProcessorThread::Event
~GridSlamProcessor	openslam_gmapping/gridfastslam/gridslamprocessor.cpp	/^  GridSlamProcessor::~GridSlamProcessor(){$/;"	f	class:GMapping::GridSlamProcessor
~GridSlamProcessorThread	openslam_gmapping/gui/gsp_thread.cpp	/^GridSlamProcessorThread::~GridSlamProcessorThread(){$/;"	f	class:GridSlamProcessorThread
~HierarchicalArray2D	openslam_gmapping/include/gmapping/grid/harray2d.h	/^		virtual ~HierarchicalArray2D(){}$/;"	f	class:GMapping::HierarchicalArray2D
~LinearVelocitySquareTest	geometry/tf/test/velocity_test.cpp	/^  virtual ~LinearVelocitySquareTest() {$/;"	f	class:LinearVelocitySquareTest
~MapClientTest	slam_gmapping/gmapping/test/rtest.cpp	/^    ~MapClientTest()$/;"	f	class:MapClientTest
~MapEvent	openslam_gmapping/gui/gsp_thread.cpp	/^GridSlamProcessorThread::MapEvent::~MapEvent(){$/;"	f	class:GridSlamProcessorThread::MapEvent
~MessageFilter	geometry/tf/include/tf/message_filter.h	/^  ~MessageFilter()$/;"	f	class:tf::MessageFilter
~MessageFilterBase	geometry/tf/include/tf/message_filter.h	/^  virtual ~MessageFilterBase(){}$/;"	f	class:tf::MessageFilterBase
~QGraphPainter	openslam_gmapping/gui/qgraphpainter.cpp	/^QGraphPainter::~QGraphPainter(){$/;"	f	class:QGraphPainter
~QMapPainter	openslam_gmapping/gui/qmappainter.cpp	/^QMapPainter::~QMapPainter(){$/;"	f	class:QMapPainter
~QNavigatorWidget	openslam_gmapping/gui/qnavigatorwidget.cpp	/^QNavigatorWidget::~QNavigatorWidget(){}$/;"	f	class:QNavigatorWidget
~QParticleViewer	openslam_gmapping/gui/qparticleviewer.cpp	/^QParticleViewer::~QParticleViewer(){$/;"	f	class:QParticleViewer
~QSLAMandNavWidget	openslam_gmapping/gui/qslamandnavwidget.cpp	/^QSLAMandNavWidget::~QSLAMandNavWidget(){}$/;"	f	class:QSLAMandNavWidget
~RangeReading	openslam_gmapping/sensor/sensor_range/rangereading.cpp	/^RangeReading::~RangeReading(){$/;"	f	class:GMapping::RangeReading
~Record	openslam_gmapping/gridfastslam/gfs2rec.cpp	/^	virtual ~Record(){}$/;"	f	struct:Record
~Record	openslam_gmapping/gridfastslam/gfsreader.cpp	/^Record::~Record(){}$/;"	f	class:GMapping::GFSReader::Record
~ScanMatcher	openslam_gmapping/scanmatcher/scanmatcher.cpp	/^ScanMatcher::~ScanMatcher(){$/;"	f	class:GMapping::ScanMatcher
~ScanMatcher	openslam_gmapping/scanmatcher/scanmatcher.new.cpp	/^ScanMatcher::~ScanMatcher(){$/;"	f	class:GMapping::ScanMatcher
~ScanMatcherProcessor	openslam_gmapping/scanmatcher/scanmatcherprocessor.cpp	/^ScanMatcherProcessor::~ScanMatcherProcessor (){$/;"	f	class:GMapping::ScanMatcherProcessor
~Sensor	openslam_gmapping/sensor/sensor_base/sensor.cpp	/^Sensor::~Sensor(){$/;"	f	class:GMapping::Sensor
~SensorLog	openslam_gmapping/log/sensorlog.cpp	/^SensorLog::~SensorLog(){$/;"	f	class:GMapping::SensorLog
~SensorReading	openslam_gmapping/sensor/sensor_base/sensorreading.cpp	/^SensorReading::~SensorReading(){$/;"	f	class:GMapping::SensorReading
~SensorStream	openslam_gmapping/log/sensorstream.cpp	/^SensorStream::~SensorStream(){}$/;"	f	class:GMapping::SensorStream
~SlamGMapping	slam_gmapping/gmapping/src/slam_gmapping.cpp	/^SlamGMapping::~SlamGMapping()$/;"	f	class:SlamGMapping
~SlamGMappingNodelet	slam_gmapping/gmapping/src/nodelet.cpp	/^    ~SlamGMappingNodelet() {}$/;"	f	class:SlamGMappingNodelet
~TNode	openslam_gmapping/gridfastslam/gridslamprocessor_tree.cpp	/^GridSlamProcessor::TNode::~TNode(){$/;"	f	class:GMapping::GridSlamProcessor::TNode
~TransformListener	geometry/tf/src/transform_listener.cpp	/^TransformListener::~TransformListener()$/;"	f	class:TransformListener
~TransformSender	geometry/tf/src/static_transform_publisher.cpp	/^  ~TransformSender() { }$/;"	f	class:TransformSender
~TransformTwistAngularTest	geometry/tf/test/transform_twist_test.cpp	/^  virtual ~TransformTwistAngularTest() {$/;"	f	class:TransformTwistAngularTest
~TransformTwistLinearTest	geometry/tf/test/transform_twist_test.cpp	/^  virtual ~TransformTwistLinearTest() {$/;"	f	class:TransformTwistLinearTest
~Transformer	geometry/tf/src/tf.cpp	/^Transformer::~Transformer()$/;"	f	class:Transformer
~autoptr	openslam_gmapping/include/gmapping/utils/autoptr.h	/^autoptr<X>::~autoptr(){$/;"	f	class:GMapping::autoptr
~echoListener	geometry/tf/src/tf_echo.cpp	/^  ~echoListener()$/;"	f	class:echoListener
~testBroadcaster	geometry/tf/test/testBroadcaster.cpp	/^  ~testBroadcaster() { }$/;"	f	class:testBroadcaster
